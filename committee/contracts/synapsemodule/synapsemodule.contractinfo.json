{"solidity/SynapseModule.sol:Address":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207fd66680dbba401560e5bd7a20ff9a60188fe281871d78dfb3436c67a2d2327d64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212207fd66680dbba401560e5bd7a20ff9a60188fe281871d78dfb3436c67a2d2327d64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"4763:6066:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;4763:6066:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"4763:6066:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"address","name":"target","type":"address"}],"name":"AddressEmptyCode","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"AddressInsufficientBalance","type":"error"},{"inputs":[],"name":"FailedInnerCall","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Collection of functions related to the address type","errors":{"AddressEmptyCode(address)":[{"details":"There's no code at `target` (it is not a contract)."}],"AddressInsufficientBalance(address)":[{"details":"The ETH balance of the account is not enough to perform the operation."}],"FailedInnerCall()":[{"details":"A call to an address target failed. The target may have reverted."}]},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"target\",\"type\":\"address\"}],\"name\":\"AddressEmptyCode\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"Collection of functions related to the address type\",\"errors\":{\"AddressEmptyCode(address)\":[{\"details\":\"There's no code at `target` (it is not a contract).\"}],\"AddressInsufficientBalance(address)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"Address\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"Context\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:ECDSA":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122081c47133b0e4803ff58a49d637609ae3d767447ebb1de02aeadc8d236137332564736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122081c47133b0e4803ff58a49d637609ae3d767447ebb1de02aeadc8d236137332564736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"12152:7386:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;12152:7386:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"12152:7386:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"ECDSAInvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ECDSAInvalidSignatureLength","type":"error"},{"inputs":[{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"ECDSAInvalidSignatureS","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Elliptic Curve Digital Signature Algorithm (ECDSA) operations. These functions can be used to verify that a message was signed by the holder of the private keys of a given address.","errors":{"ECDSAInvalidSignature()":[{"details":"The signature derives the `address(0)`."}],"ECDSAInvalidSignatureLength(uint256)":[{"details":"The signature has an invalid length."}],"ECDSAInvalidSignatureS(bytes32)":[{"details":"The signature has an S value that is in the upper half order."}]},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"ECDSAInvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ECDSAInvalidSignatureLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"ECDSAInvalidSignatureS\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"Elliptic Curve Digital Signature Algorithm (ECDSA) operations. These functions can be used to verify that a message was signed by the holder of the private keys of a given address.\",\"errors\":{\"ECDSAInvalidSignature()\":[{\"details\":\"The signature derives the `address(0)`.\"}],\"ECDSAInvalidSignatureLength(uint256)\":[{\"details\":\"The signature has an invalid length.\"}],\"ECDSAInvalidSignatureS(bytes32)\":[{\"details\":\"The signature has an S value that is in the upper half order.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"ECDSA\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:EnumerableSet":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b53c66d1f9c9c8f34d42f5605648d688033a4d72bb38f04152844fd515c8a37864736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b53c66d1f9c9c8f34d42f5605648d688033a4d72bb38f04152844fd515c8a37864736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"37281:11640:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;37281:11640:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"37281:11640:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ```solidity contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported. [WARNING] ==== Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable. See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info. In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet. ====","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ```solidity contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported. [WARNING] ==== Trying to delete such a structure from storage will likely result in data corruption, rendering the structure unusable. See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info. In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an array of EnumerableSet. ====\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"EnumerableSet\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:IGasOracle":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"remoteChainId","type":"uint256"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"convertRemoteValueToLocalUnits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"remoteChainId","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"calldataSize","type":"uint256"}],"name":"estimateTxCostInLocalUnits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"remoteChainId","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"calldataSize","type":"uint256"}],"name":"estimateTxCostInRemoteUnits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"convertRemoteValueToLocalUnits(uint256,uint256)":{"notice":"Convert a value from the native token of a remote chain to the local native token."},"estimateTxCostInLocalUnits(uint256,uint256,uint256)":{"notice":"Estimate the cost of execution a transaction on a remote chain, and convert it to the local native token."},"estimateTxCostInRemoteUnits(uint256,uint256,uint256)":{"notice":"Estimate the cost of execution a transaction on a remote chain, and return it as is in the remote chain's native token."}},"version":1},"developerDoc":{"kind":"dev","methods":{"convertRemoteValueToLocalUnits(uint256,uint256)":{"details":"Will revert if no price is available for the remote chain.","params":{"remoteChainId":"The chain id of the remote chain.","value":"The value to convert."}},"estimateTxCostInLocalUnits(uint256,uint256,uint256)":{"details":"Will revert if no price is available for the remote chain.","params":{"calldataSize":"The size of the transaction calldata.","gasLimit":"The gas limit of the transaction.","remoteChainId":"The chain id of the remote chain."}},"estimateTxCostInRemoteUnits(uint256,uint256,uint256)":{"details":"Will revert if no price is available for the remote chain.","params":{"calldataSize":"The size of the transaction calldata.","gasLimit":"The gas limit of the transaction.","remoteChainId":"The chain id of the remote chain."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remoteChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"convertRemoteValueToLocalUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remoteChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calldataSize\",\"type\":\"uint256\"}],\"name\":\"estimateTxCostInLocalUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remoteChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calldataSize\",\"type\":\"uint256\"}],\"name\":\"estimateTxCostInRemoteUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"convertRemoteValueToLocalUnits(uint256,uint256)\":{\"details\":\"Will revert if no price is available for the remote chain.\",\"params\":{\"remoteChainId\":\"The chain id of the remote chain.\",\"value\":\"The value to convert.\"}},\"estimateTxCostInLocalUnits(uint256,uint256,uint256)\":{\"details\":\"Will revert if no price is available for the remote chain.\",\"params\":{\"calldataSize\":\"The size of the transaction calldata.\",\"gasLimit\":\"The gas limit of the transaction.\",\"remoteChainId\":\"The chain id of the remote chain.\"}},\"estimateTxCostInRemoteUnits(uint256,uint256,uint256)\":{\"details\":\"Will revert if no price is available for the remote chain.\",\"params\":{\"calldataSize\":\"The size of the transaction calldata.\",\"gasLimit\":\"The gas limit of the transaction.\",\"remoteChainId\":\"The chain id of the remote chain.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"convertRemoteValueToLocalUnits(uint256,uint256)\":{\"notice\":\"Convert a value from the native token of a remote chain to the local native token.\"},\"estimateTxCostInLocalUnits(uint256,uint256,uint256)\":{\"notice\":\"Estimate the cost of execution a transaction on a remote chain, and convert it to the local native token.\"},\"estimateTxCostInRemoteUnits(uint256,uint256,uint256)\":{\"notice\":\"Estimate the cost of execution a transaction on a remote chain, and return it as is in the remote chain's native token.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"IGasOracle\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{"convertRemoteValueToLocalUnits(uint256,uint256)":"1e7b9287","estimateTxCostInLocalUnits(uint256,uint256,uint256)":"5cbd3c48","estimateTxCostInRemoteUnits(uint256,uint256,uint256)":"fd6a7167"}},"solidity/SynapseModule.sol:IInterchainDB":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__BatchDoesNotExist","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"InterchainDB__BatchNotFinalized","type":"error"},{"inputs":[{"internalType":"address","name":"module","type":"address"},{"internalType":"bytes32","name":"existingBatchRoot","type":"bytes32"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"newBatch","type":"tuple"}],"name":"InterchainDB__ConflictingBatches","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"uint64","name":"batchSize","type":"uint64"}],"name":"InterchainDB__EntryIndexOutOfRange","type":"error"},{"inputs":[{"internalType":"uint256","name":"actualFee","type":"uint256"},{"internalType":"uint256","name":"expectedFee","type":"uint256"}],"name":"InterchainDB__IncorrectFeeAmount","type":"error"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"InterchainDB__InvalidEntryRange","type":"error"},{"inputs":[],"name":"InterchainDB__NoModulesSpecified","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainDB__SameChainId","type":"error"},{"inputs":[{"internalType":"address","name":"dstModule","type":"address"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"},{"internalType":"bytes32","name":"srcWriter","type":"bytes32"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"internalType":"struct InterchainEntry","name":"entry","type":"tuple"},{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"name":"checkVerification","outputs":[{"internalType":"uint256","name":"moduleVerifiedAt","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getBatch","outputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getBatchLeafs","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"start","type":"uint64"},{"internalType":"uint64","name":"end","type":"uint64"}],"name":"getBatchLeafsPaginated","outputs":[{"internalType":"bytes32[]","name":"","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getBatchSize","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getDBNonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryProof","outputs":[{"internalType":"bytes32[]","name":"proof","type":"bytes32[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"name":"getEntryValue","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"getInterchainFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getNextEntryIndex","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"batch","type":"tuple"}],"name":"verifyRemoteBatch","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"dataHash","type":"bytes32"}],"name":"writeEntry","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"bytes32","name":"dataHash","type":"bytes32"},{"internalType":"address[]","name":"srcModules","type":"address[]"}],"name":"writeEntryWithVerification","outputs":[{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"uint64","name":"entryIndex","type":"uint64"}],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])":{"notice":"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry."},"getBatch(uint256)":{"notice":"Get the finalized Interchain Batch with the given nonce."},"getBatchLeafs(uint256)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together)."},"getBatchLeafsPaginated(uint256,uint64,uint64)":{"notice":"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error."},"getBatchSize(uint256)":{"notice":"Returns the size of the finalized batch with the given nonce."},"getDBNonce()":{"notice":"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch."},"getEntryProof(uint256,uint64)":{"notice":"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce."},"getEntryValue(uint256,uint64)":{"notice":"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value."},"getInterchainFee(uint256,address[])":{"notice":"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules."},"getNextEntryIndex()":{"notice":"Get the index of the next entry to be written to the database."},"requestBatchVerification(uint256,uint256,address[])":{"notice":"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch."},"verifyRemoteBatch((uint256,uint256,bytes32))":{"notice":"Allows the Interchain Module to verify the batch coming from the remote chain."},"writeEntry(bytes32)":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain."},"writeEntryWithVerification(uint256,bytes32,address[])":{"notice":"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details."}},"version":1},"developerDoc":{"kind":"dev","methods":{"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])":{"params":{"dstModule":"The destination chain addresses of the Interchain Modules to use for verification","entry":"The Interchain Entry to read"},"returns":{"moduleVerifiedAt":"  The block timestamp at which the entry was verified by the module,                             or ZERO if the module has not verified the entry."}},"getBatch(uint256)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafs(uint256)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getBatchLeafsPaginated(uint256,uint64,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.","params":{"dbNonce":"The database nonce of the finalized batch","end":"The end index of the paginated leafs, exclusive","start":"The start index of the paginated leafs, inclusive"}},"getBatchSize(uint256)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized.","params":{"dbNonce":"The database nonce of the finalized batch"}},"getEntryProof(uint256,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the finalized batch","entryIndex":"The index of the written entry within the batch"},"returns":{"proof":"      The Merkle proof of inclusion for the entry"}},"getEntryValue(uint256,uint64)":{"details":"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.","params":{"dbNonce":"The database nonce of the existing batch","entryIndex":"The index of the written entry within the batch"}},"getInterchainFee(uint256,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"getNextEntryIndex()":{"returns":{"dbNonce":"     The database nonce of the batch including the next entry","entryIndex":"  The index of the next entry within that batch"}},"requestBatchVerification(uint256,uint256,address[])":{"details":"Will revert if the batch with the given nonce does not exist.","params":{"dbNonce":"The database nonce of the existing batch","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"}},"verifyRemoteBatch((uint256,uint256,bytes32))":{"params":{"batch":"The Interchain Batch to confirm"}},"writeEntry(bytes32)":{"params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}},"writeEntryWithVerification(uint256,bytes32,address[])":{"details":"Will revert if the empty array of modules is provided.","params":{"dataHash":"The hash of the data to be written to the Interchain DataBase as a new entry","dstChainId":"The chain id of the destination chain","srcModules":"The source chain addresses of the Interchain Modules to use for verification"},"returns":{"dbNonce":"    The database nonce of the batch containing the written entry","entryIndex":" The index of the written entry within the batch"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__BatchDoesNotExist\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__BatchNotFinalized\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"module\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"existingBatchRoot\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"newBatch\",\"type\":\"tuple\"}],\"name\":\"InterchainDB__ConflictingBatches\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"batchSize\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__EntryIndexOutOfRange\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actualFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"expectedFee\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__IncorrectFeeAmount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"InterchainDB__InvalidEntryRange\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InterchainDB__NoModulesSpecified\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainDB__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"dstModule\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"},{\"internalType\":\"bytes32\",\"name\":\"srcWriter\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainEntry\",\"name\":\"entry\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"checkVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"moduleVerifiedAt\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getBatch\",\"outputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getBatchLeafs\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"start\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"end\",\"type\":\"uint64\"}],\"name\":\"getBatchLeafsPaginated\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getBatchSize\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDBNonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryProof\",\"outputs\":[{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"name\":\"getEntryValue\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"getInterchainFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getNextEntryIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"verifyRemoteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"writeEntry\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"internalType\":\"address[]\",\"name\":\"srcModules\",\"type\":\"address[]\"}],\"name\":\"writeEntryWithVerification\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"entryIndex\",\"type\":\"uint64\"}],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])\":{\"params\":{\"dstModule\":\"The destination chain addresses of the Interchain Modules to use for verification\",\"entry\":\"The Interchain Entry to read\"},\"returns\":{\"moduleVerifiedAt\":\"  The block timestamp at which the entry was verified by the module,                             or ZERO if the module has not verified the entry.\"}},\"getBatch(uint256)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafs(uint256)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getBatchLeafsPaginated(uint256,uint64,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the provided range is invalid.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"end\":\"The end index of the paginated leafs, exclusive\",\"start\":\"The start index of the paginated leafs, inclusive\"}},\"getBatchSize(uint256)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\"}},\"getEntryProof(uint256,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or is not finalized. Will revert if the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the finalized batch\",\"entryIndex\":\"The index of the written entry within the batch\"},\"returns\":{\"proof\":\"      The Merkle proof of inclusion for the entry\"}},\"getEntryValue(uint256,uint64)\":{\"details\":\"Will revert if the batch with the given nonce does not exist, or the entry with the given index does not exist within the batch.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"entryIndex\":\"The index of the written entry within the batch\"}},\"getInterchainFee(uint256,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"getNextEntryIndex()\":{\"returns\":{\"dbNonce\":\"     The database nonce of the batch including the next entry\",\"entryIndex\":\"  The index of the next entry within that batch\"}},\"requestBatchVerification(uint256,uint256,address[])\":{\"details\":\"Will revert if the batch with the given nonce does not exist.\",\"params\":{\"dbNonce\":\"The database nonce of the existing batch\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"}},\"verifyRemoteBatch((uint256,uint256,bytes32))\":{\"params\":{\"batch\":\"The Interchain Batch to confirm\"}},\"writeEntry(bytes32)\":{\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"details\":\"Will revert if the empty array of modules is provided.\",\"params\":{\"dataHash\":\"The hash of the data to be written to the Interchain DataBase as a new entry\",\"dstChainId\":\"The chain id of the destination chain\",\"srcModules\":\"The source chain addresses of the Interchain Modules to use for verification\"},\"returns\":{\"dbNonce\":\"    The database nonce of the batch containing the written entry\",\"entryIndex\":\" The index of the written entry within the batch\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])\":{\"notice\":\"Read the data written on specific source chain by a specific writer, and verify it on the destination chain using the provided Interchain Module. Note: returned zero value indicates that the module has not verified the entry.\"},\"getBatch(uint256)\":{\"notice\":\"Get the finalized Interchain Batch with the given nonce.\"},\"getBatchLeafs(uint256)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce. Note: the leafs are ordered by the index of the written entry in the current batch, and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\"},\"getBatchLeafsPaginated(uint256,uint64,uint64)\":{\"notice\":\"Returns the list of leafs of the finalized batch with the given nonce, paginated by the given start and end indexes. The end index is exclusive. Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs` would result in a gas limit exceeded error.\"},\"getBatchSize(uint256)\":{\"notice\":\"Returns the size of the finalized batch with the given nonce.\"},\"getDBNonce()\":{\"notice\":\"Get the nonce of the database, which is incremented every time a new batch is finalized. This is the nonce of the current non-finalized batch.\"},\"getEntryProof(uint256,uint64)\":{\"notice\":\"Get the Merkle proof of inclusion for the entry with the given index in the finalized batch with the given nonce.\"},\"getEntryValue(uint256,uint64)\":{\"notice\":\"Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index. Entry value is calculated as the hash of the writer address and the written data hash. Note: the batch does not have to be finalized to fetch the entry value.\"},\"getInterchainFee(uint256,address[])\":{\"notice\":\"Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain using the provided Interchain Modules.\"},\"getNextEntryIndex()\":{\"notice\":\"Get the index of the next entry to be written to the database.\"},\"requestBatchVerification(uint256,uint256,address[])\":{\"notice\":\"Request the given Interchain Modules to verify an existing batch. If the batch is not finalized, the module will verify it after finalization. For the finalized batch the batch root is already available, and the module can verify it immediately. Note: every module has a separate fee paid in the native gas token of the source chain, and `msg.value` must be equal to the sum of all fees. Note: this method is permissionless, and anyone can request verification for any batch.\"},\"verifyRemoteBatch((uint256,uint256,bytes32))\":{\"notice\":\"Allows the Interchain Module to verify the batch coming from the remote chain.\"},\"writeEntry(bytes32)\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Note: there are no guarantees that this entry will be available for reading on any of the remote chains. Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\"},\"writeEntryWithVerification(uint256,bytes32,address[])\":{\"notice\":\"Write data to the Interchain DataBase as a new entry in the current batch. Then request the Interchain Modules to verify the batch containing the written entry on the destination chain. See `writeEntry` and `requestBatchVerification` for more details.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"IInterchainDB\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{"checkVerification(address,(uint256,uint256,uint64,bytes32,bytes32),bytes32[])":"67b1f42e","getBatch(uint256)":"5ac44282","getBatchLeafs(uint256)":"d63020bb","getBatchLeafsPaginated(uint256,uint64,uint64)":"25a1641d","getBatchSize(uint256)":"b955e9b9","getDBNonce()":"f338140e","getEntryProof(uint256,uint64)":"4f84d040","getEntryValue(uint256,uint64)":"afa25005","getInterchainFee(uint256,address[])":"fc7686ec","getNextEntryIndex()":"aa2f06ae","requestBatchVerification(uint256,uint256,address[])":"84b1c8b8","verifyRemoteBatch((uint256,uint256,bytes32))":"05d0728c","writeEntry(bytes32)":"2ad8c706","writeEntryWithVerification(uint256,bytes32,address[])":"67c769af"}},"solidity/SynapseModule.sol:IInterchainModule":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__IncorrectSourceChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainModule__InsufficientFee","type":"error"},{"inputs":[{"internalType":"address","name":"caller","type":"address"}],"name":"InterchainModule__NotInterchainDB","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getModuleFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"batch","type":"tuple"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getModuleFee(uint256,uint256)":{"notice":"Get the Module fee for verifying a batch on the specified destination chain."},"requestBatchVerification(uint256,(uint256,uint256,bytes32))":{"notice":"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering."}},"notice":"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.","version":1},"developerDoc":{"kind":"dev","methods":{"getModuleFee(uint256,uint256)":{"params":{"dbNonce":"The database nonce of the batch on the source chain","dstChainId":"The chain id of the destination chain"}},"requestBatchVerification(uint256,(uint256,uint256,bytes32))":{"details":"Could be only called by the Interchain DataBase contract.","params":{"batch":"The batch to verify","dstChainId":"The chain id of the destination chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__IncorrectSourceChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__InsufficientFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"InterchainModule__NotInterchainDB\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getModuleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getModuleFee(uint256,uint256)\":{\"params\":{\"dbNonce\":\"The database nonce of the batch on the source chain\",\"dstChainId\":\"The chain id of the destination chain\"}},\"requestBatchVerification(uint256,(uint256,uint256,bytes32))\":{\"details\":\"Could be only called by the Interchain DataBase contract.\",\"params\":{\"batch\":\"The batch to verify\",\"dstChainId\":\"The chain id of the destination chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getModuleFee(uint256,uint256)\":{\"notice\":\"Get the Module fee for verifying a batch on the specified destination chain.\"},\"requestBatchVerification(uint256,(uint256,uint256,bytes32))\":{\"notice\":\"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering.\"}},\"notice\":\"Every Module may opt a different method to confirm the verified entries on destination chain, therefore this is not a part of a common interface.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"IInterchainModule\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{"getModuleFee(uint256,uint256)":"4a114f72","requestBatchVerification(uint256,(uint256,uint256,bytes32))":"3fdcec74"}},"solidity/SynapseModule.sol:ISynapseGasOracle":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"remoteChainId","type":"uint256"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"convertRemoteValueToLocalUnits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"remoteChainId","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"calldataSize","type":"uint256"}],"name":"estimateTxCostInLocalUnits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"remoteChainId","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"},{"internalType":"uint256","name":"calldataSize","type":"uint256"}],"name":"estimateTxCostInRemoteUnits","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getLocalGasData","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"receiveRemoteGasData","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"convertRemoteValueToLocalUnits(uint256,uint256)":{"notice":"Convert a value from the native token of a remote chain to the local native token."},"estimateTxCostInLocalUnits(uint256,uint256,uint256)":{"notice":"Estimate the cost of execution a transaction on a remote chain, and convert it to the local native token."},"estimateTxCostInRemoteUnits(uint256,uint256,uint256)":{"notice":"Estimate the cost of execution a transaction on a remote chain, and return it as is in the remote chain's native token."},"getLocalGasData()":{"notice":"Gets the gas data for the local chain."},"receiveRemoteGasData(uint256,bytes)":{"notice":"Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle."}},"version":1},"developerDoc":{"kind":"dev","methods":{"convertRemoteValueToLocalUnits(uint256,uint256)":{"details":"Will revert if no price is available for the remote chain.","params":{"remoteChainId":"The chain id of the remote chain.","value":"The value to convert."}},"estimateTxCostInLocalUnits(uint256,uint256,uint256)":{"details":"Will revert if no price is available for the remote chain.","params":{"calldataSize":"The size of the transaction calldata.","gasLimit":"The gas limit of the transaction.","remoteChainId":"The chain id of the remote chain."}},"estimateTxCostInRemoteUnits(uint256,uint256,uint256)":{"details":"Will revert if no price is available for the remote chain.","params":{"calldataSize":"The size of the transaction calldata.","gasLimit":"The gas limit of the transaction.","remoteChainId":"The chain id of the remote chain."}},"receiveRemoteGasData(uint256,bytes)":{"details":"Could only be called by Synapse Module.","params":{"data":"The gas data from the remote chain.","srcChainId":"The chain id of the remote chain."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remoteChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"convertRemoteValueToLocalUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remoteChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calldataSize\",\"type\":\"uint256\"}],\"name\":\"estimateTxCostInLocalUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remoteChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"calldataSize\",\"type\":\"uint256\"}],\"name\":\"estimateTxCostInRemoteUnits\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLocalGasData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveRemoteGasData\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"convertRemoteValueToLocalUnits(uint256,uint256)\":{\"details\":\"Will revert if no price is available for the remote chain.\",\"params\":{\"remoteChainId\":\"The chain id of the remote chain.\",\"value\":\"The value to convert.\"}},\"estimateTxCostInLocalUnits(uint256,uint256,uint256)\":{\"details\":\"Will revert if no price is available for the remote chain.\",\"params\":{\"calldataSize\":\"The size of the transaction calldata.\",\"gasLimit\":\"The gas limit of the transaction.\",\"remoteChainId\":\"The chain id of the remote chain.\"}},\"estimateTxCostInRemoteUnits(uint256,uint256,uint256)\":{\"details\":\"Will revert if no price is available for the remote chain.\",\"params\":{\"calldataSize\":\"The size of the transaction calldata.\",\"gasLimit\":\"The gas limit of the transaction.\",\"remoteChainId\":\"The chain id of the remote chain.\"}},\"receiveRemoteGasData(uint256,bytes)\":{\"details\":\"Could only be called by Synapse Module.\",\"params\":{\"data\":\"The gas data from the remote chain.\",\"srcChainId\":\"The chain id of the remote chain.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"convertRemoteValueToLocalUnits(uint256,uint256)\":{\"notice\":\"Convert a value from the native token of a remote chain to the local native token.\"},\"estimateTxCostInLocalUnits(uint256,uint256,uint256)\":{\"notice\":\"Estimate the cost of execution a transaction on a remote chain, and convert it to the local native token.\"},\"estimateTxCostInRemoteUnits(uint256,uint256,uint256)\":{\"notice\":\"Estimate the cost of execution a transaction on a remote chain, and return it as is in the remote chain's native token.\"},\"getLocalGasData()\":{\"notice\":\"Gets the gas data for the local chain.\"},\"receiveRemoteGasData(uint256,bytes)\":{\"notice\":\"Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"ISynapseGasOracle\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{"convertRemoteValueToLocalUnits(uint256,uint256)":"1e7b9287","estimateTxCostInLocalUnits(uint256,uint256,uint256)":"5cbd3c48","estimateTxCostInRemoteUnits(uint256,uint256,uint256)":"fd6a7167","getLocalGasData()":"6f928aa7","receiveRemoteGasData(uint256,bytes)":"52999769"}},"solidity/SynapseModule.sol:ISynapseModule":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__IncorrectSourceChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainModule__InsufficientFee","type":"error"},{"inputs":[{"internalType":"address","name":"caller","type":"address"}],"name":"InterchainModule__NotInterchainDB","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__SameChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"claimFeeFraction","type":"uint256"}],"name":"SynapseModule__ClaimFeeFractionExceedsMax","type":"error"},{"inputs":[],"name":"SynapseModule__FeeCollectorNotSet","type":"error"},{"inputs":[{"internalType":"address","name":"gasOracle","type":"address"}],"name":"SynapseModule__GasOracleNotContract","type":"error"},{"inputs":[],"name":"SynapseModule__GasOracleNotSet","type":"error"},{"inputs":[],"name":"SynapseModule__NoFeesToClaim","type":"error"},{"inputs":[{"internalType":"address","name":"verifier","type":"address"}],"name":"addVerifier","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"verifiers","type":"address[]"}],"name":"addVerifiers","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"feeCollector","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"gasOracle","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getClaimFeeAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getClaimFeeFraction","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getModuleFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getThreshold","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVerifiers","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getVerifyGasLimit","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"isVerifier","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"verifier","type":"address"}],"name":"removeVerifier","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"verifiers","type":"address[]"}],"name":"removeVerifiers","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"batch","type":"tuple"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"claimFeeFraction","type":"uint256"}],"name":"setClaimFeeFraction","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"feeCollector_","type":"address"}],"name":"setFeeCollector","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"gasOracle_","type":"address"}],"name":"setGasOracle","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"threshold","type":"uint256"}],"name":"setThreshold","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"}],"name":"setVerifyGasLimit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedBatch","type":"bytes"},{"internalType":"bytes","name":"signatures","type":"bytes"}],"name":"verifyRemoteBatch","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"addVerifier(address)":{"notice":"Adds a new verifier to the module."},"addVerifiers(address[])":{"notice":"Adds a list of new verifiers to the module."},"claimFees()":{"notice":"Transfers the accumulated fees to the fee collector. Message caller receives a percentage of the fees, this ensures that the module is self-sustainable. The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees will be transferred to the fee collector."},"feeCollector()":{"notice":"Returns the address of the fee collector for the module."},"gasOracle()":{"notice":"Returns the address of the gas oracle used for estimating the verification fees."},"getClaimFeeAmount()":{"notice":"Returns the current claim fee to be paid to the caller of `claimFees`."},"getClaimFeeFraction()":{"notice":"Returns the fraction of the fees to be paid to the caller of `claimFees`. The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees."},"getModuleFee(uint256,uint256)":{"notice":"Get the Module fee for verifying a batch on the specified destination chain."},"getThreshold()":{"notice":"Gets the threshold of the module. This is the minimum number of signatures required for verification."},"getVerifiers()":{"notice":"Returns the list of verifiers for the module."},"getVerifyGasLimit(uint256)":{"notice":"Returns the estimated gas limit for verifying a batch on the given chain. Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set."},"isVerifier(address)":{"notice":"Checks if the given account is a verifier for the module."},"removeVerifier(address)":{"notice":"Removes a verifier from the module."},"removeVerifiers(address[])":{"notice":"Removes a list of verifiers from the module."},"requestBatchVerification(uint256,(uint256,uint256,bytes32))":{"notice":"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering."},"setClaimFeeFraction(uint256)":{"notice":"Sets the fraction of the accumulated fees to be paid to caller of `claimFees`. This encourages rational actors to call the function as soon as claim fee is higher than the gas cost."},"setFeeCollector(address)":{"notice":"Sets the address of the fee collector, which will have the verification fees forwarded to it."},"setGasOracle(address)":{"notice":"Sets the address of the gas oracle to be used for estimating the verification fees."},"setThreshold(uint256)":{"notice":"Sets the threshold of the module."},"setVerifyGasLimit(uint256,uint256)":{"notice":"Sets the estimated gas limit for verifying a batch on the given chain."},"verifyRemoteBatch(bytes,bytes)":{"notice":"Verifies a batch from the remote chain using a set of verifier signatures. If the threshold is met, the batch will be marked as verified in the Interchain DataBase."}},"version":1},"developerDoc":{"kind":"dev","methods":{"addVerifier(address)":{"details":"Could be only called by the owner. Will revert if the verifier is already added.","params":{"verifier":"The address of the verifier to add"}},"addVerifiers(address[])":{"details":"Could be only called by the owner. Will revert if any of the verifiers is already added.","params":{"verifiers":"The list of addresses of the verifiers to add"}},"claimFees()":{"details":"Will revert if the fee collector is not set."},"getModuleFee(uint256,uint256)":{"params":{"dbNonce":"The database nonce of the batch on the source chain","dstChainId":"The chain id of the destination chain"}},"removeVerifier(address)":{"details":"Could be only called by the owner. Will revert if the verifier is not added.","params":{"verifier":"The address of the verifier to remove"}},"removeVerifiers(address[])":{"details":"Could be only called by the owner. Will revert if any of the verifiers is not added.","params":{"verifiers":"The list of addresses of the verifiers to remove"}},"requestBatchVerification(uint256,(uint256,uint256,bytes32))":{"details":"Could be only called by the Interchain DataBase contract.","params":{"batch":"The batch to verify","dstChainId":"The chain id of the destination chain"}},"setClaimFeeFraction(uint256)":{"details":"Could be only called by the owner. Could not exceed 1%.","params":{"claimFeeFraction":"The fraction of the fees to be paid to the claimer (100% = 1e18)"}},"setFeeCollector(address)":{"details":"Could be only called by the owner.","params":{"feeCollector_":"The address of the fee collector"}},"setGasOracle(address)":{"details":"Could be only called by the owner. Will revert if the gas oracle is not a contract.","params":{"gasOracle_":"The address of the gas oracle contract"}},"setThreshold(uint256)":{"details":"Could be only called by the owner. Will revert if the threshold is zero.","params":{"threshold":"The new threshold value"}},"setVerifyGasLimit(uint256,uint256)":{"details":"Could be only called by the owner.","params":{"chainId":"The chain ID for which to set the gas limit","gasLimit":"The new gas limit"}},"verifyRemoteBatch(bytes,bytes)":{"details":"List of recovered signers from the signatures must be sorted in the ascending order.","params":{"encodedBatch":"The encoded batch to verify","signatures":"Signatures used to verify the batch, concatenated"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__IncorrectSourceChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__InsufficientFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"InterchainModule__NotInterchainDB\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimFeeFraction\",\"type\":\"uint256\"}],\"name\":\"SynapseModule__ClaimFeeFractionExceedsMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SynapseModule__FeeCollectorNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gasOracle\",\"type\":\"address\"}],\"name\":\"SynapseModule__GasOracleNotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SynapseModule__GasOracleNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SynapseModule__NoFeesToClaim\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"addVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"verifiers\",\"type\":\"address[]\"}],\"name\":\"addVerifiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimFeeFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getModuleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVerifiers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getVerifyGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isVerifier\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"removeVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"verifiers\",\"type\":\"address[]\"}],\"name\":\"removeVerifiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimFeeFraction\",\"type\":\"uint256\"}],\"name\":\"setClaimFeeFraction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeCollector_\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gasOracle_\",\"type\":\"address\"}],\"name\":\"setGasOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"setVerifyGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedBatch\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"verifyRemoteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addVerifier(address)\":{\"details\":\"Could be only called by the owner. Will revert if the verifier is already added.\",\"params\":{\"verifier\":\"The address of the verifier to add\"}},\"addVerifiers(address[])\":{\"details\":\"Could be only called by the owner. Will revert if any of the verifiers is already added.\",\"params\":{\"verifiers\":\"The list of addresses of the verifiers to add\"}},\"claimFees()\":{\"details\":\"Will revert if the fee collector is not set.\"},\"getModuleFee(uint256,uint256)\":{\"params\":{\"dbNonce\":\"The database nonce of the batch on the source chain\",\"dstChainId\":\"The chain id of the destination chain\"}},\"removeVerifier(address)\":{\"details\":\"Could be only called by the owner. Will revert if the verifier is not added.\",\"params\":{\"verifier\":\"The address of the verifier to remove\"}},\"removeVerifiers(address[])\":{\"details\":\"Could be only called by the owner. Will revert if any of the verifiers is not added.\",\"params\":{\"verifiers\":\"The list of addresses of the verifiers to remove\"}},\"requestBatchVerification(uint256,(uint256,uint256,bytes32))\":{\"details\":\"Could be only called by the Interchain DataBase contract.\",\"params\":{\"batch\":\"The batch to verify\",\"dstChainId\":\"The chain id of the destination chain\"}},\"setClaimFeeFraction(uint256)\":{\"details\":\"Could be only called by the owner. Could not exceed 1%.\",\"params\":{\"claimFeeFraction\":\"The fraction of the fees to be paid to the claimer (100% = 1e18)\"}},\"setFeeCollector(address)\":{\"details\":\"Could be only called by the owner.\",\"params\":{\"feeCollector_\":\"The address of the fee collector\"}},\"setGasOracle(address)\":{\"details\":\"Could be only called by the owner. Will revert if the gas oracle is not a contract.\",\"params\":{\"gasOracle_\":\"The address of the gas oracle contract\"}},\"setThreshold(uint256)\":{\"details\":\"Could be only called by the owner. Will revert if the threshold is zero.\",\"params\":{\"threshold\":\"The new threshold value\"}},\"setVerifyGasLimit(uint256,uint256)\":{\"details\":\"Could be only called by the owner.\",\"params\":{\"chainId\":\"The chain ID for which to set the gas limit\",\"gasLimit\":\"The new gas limit\"}},\"verifyRemoteBatch(bytes,bytes)\":{\"details\":\"List of recovered signers from the signatures must be sorted in the ascending order.\",\"params\":{\"encodedBatch\":\"The encoded batch to verify\",\"signatures\":\"Signatures used to verify the batch, concatenated\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addVerifier(address)\":{\"notice\":\"Adds a new verifier to the module.\"},\"addVerifiers(address[])\":{\"notice\":\"Adds a list of new verifiers to the module.\"},\"claimFees()\":{\"notice\":\"Transfers the accumulated fees to the fee collector. Message caller receives a percentage of the fees, this ensures that the module is self-sustainable. The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees will be transferred to the fee collector.\"},\"feeCollector()\":{\"notice\":\"Returns the address of the fee collector for the module.\"},\"gasOracle()\":{\"notice\":\"Returns the address of the gas oracle used for estimating the verification fees.\"},\"getClaimFeeAmount()\":{\"notice\":\"Returns the current claim fee to be paid to the caller of `claimFees`.\"},\"getClaimFeeFraction()\":{\"notice\":\"Returns the fraction of the fees to be paid to the caller of `claimFees`. The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\"},\"getModuleFee(uint256,uint256)\":{\"notice\":\"Get the Module fee for verifying a batch on the specified destination chain.\"},\"getThreshold()\":{\"notice\":\"Gets the threshold of the module. This is the minimum number of signatures required for verification.\"},\"getVerifiers()\":{\"notice\":\"Returns the list of verifiers for the module.\"},\"getVerifyGasLimit(uint256)\":{\"notice\":\"Returns the estimated gas limit for verifying a batch on the given chain. Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\"},\"isVerifier(address)\":{\"notice\":\"Checks if the given account is a verifier for the module.\"},\"removeVerifier(address)\":{\"notice\":\"Removes a verifier from the module.\"},\"removeVerifiers(address[])\":{\"notice\":\"Removes a list of verifiers from the module.\"},\"requestBatchVerification(uint256,(uint256,uint256,bytes32))\":{\"notice\":\"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering.\"},\"setClaimFeeFraction(uint256)\":{\"notice\":\"Sets the fraction of the accumulated fees to be paid to caller of `claimFees`. This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\"},\"setFeeCollector(address)\":{\"notice\":\"Sets the address of the fee collector, which will have the verification fees forwarded to it.\"},\"setGasOracle(address)\":{\"notice\":\"Sets the address of the gas oracle to be used for estimating the verification fees.\"},\"setThreshold(uint256)\":{\"notice\":\"Sets the threshold of the module.\"},\"setVerifyGasLimit(uint256,uint256)\":{\"notice\":\"Sets the estimated gas limit for verifying a batch on the given chain.\"},\"verifyRemoteBatch(bytes,bytes)\":{\"notice\":\"Verifies a batch from the remote chain using a set of verifier signatures. If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"ISynapseModule\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{"addVerifier(address)":"9000b3d6","addVerifiers(address[])":"b5344257","claimFees()":"d294f093","feeCollector()":"c415b95c","gasOracle()":"5d62a8dd","getClaimFeeAmount()":"20c8eed2","getClaimFeeFraction()":"6adb16b5","getModuleFee(uint256,uint256)":"4a114f72","getThreshold()":"e75235b8","getVerifiers()":"a935e766","getVerifyGasLimit(uint256)":"66d02393","isVerifier(address)":"33105218","removeVerifier(address)":"ca2dfd0a","removeVerifiers(address[])":"86ae47f0","requestBatchVerification(uint256,(uint256,uint256,bytes32))":"3fdcec74","setClaimFeeFraction(uint256)":"9a96f35b","setFeeCollector(address)":"a42dce80","setGasOracle(address)":"a87b8152","setThreshold(uint256)":"960bfe04","setVerifyGasLimit(uint256,uint256)":"178977c9","verifyRemoteBatch(bytes,bytes)":"b80cb14b"}},"solidity/SynapseModule.sol:InterchainBatchLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212205c3790150260a0cd6269b865473174da3b8fd67952396586331d7701f106bc8264736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212205c3790150260a0cd6269b865473174da3b8fd67952396586331d7701f106bc8264736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"3408:842:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;3408:842:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"3408:842:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"InterchainBatchLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:InterchainEntryLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a125f2af9065e2fc89b733daf8e1d5753ad44402a87ef96990d6f50bfcce031f64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220a125f2af9065e2fc89b733daf8e1d5753ad44402a87ef96990d6f50bfcce031f64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"50340:1633:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;50340:1633:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"50340:1633:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"InterchainEntryLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:InterchainModule":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__IncorrectSourceChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainModule__InsufficientFee","type":"error"},{"inputs":[{"internalType":"address","name":"caller","type":"address"}],"name":"InterchainModule__NotInterchainDB","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__SameChainId","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"batch","type":"bytes"},{"indexed":false,"internalType":"bytes32","name":"ethSignedBatchHash","type":"bytes32"}],"name":"BatchVerificationRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"batch","type":"bytes"},{"indexed":false,"internalType":"bytes32","name":"ethSignedBatchHash","type":"bytes32"}],"name":"BatchVerified","type":"event"},{"inputs":[],"name":"INTERCHAIN_DB","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getModuleFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"batch","type":"tuple"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"getModuleFee(uint256,uint256)":{"notice":"Get the Module fee for verifying a batch on the specified destination chain."},"requestBatchVerification(uint256,(uint256,uint256,bytes32))":{"notice":"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering."}},"notice":"Common logic for all Interchain Modules.","version":1},"developerDoc":{"kind":"dev","methods":{"getModuleFee(uint256,uint256)":{"params":{"dbNonce":"The database nonce of the batch on the source chain","dstChainId":"The chain id of the destination chain"}},"requestBatchVerification(uint256,(uint256,uint256,bytes32))":{"details":"Could be only called by the Interchain DataBase contract.","params":{"batch":"The batch to verify","dstChainId":"The chain id of the destination chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__IncorrectSourceChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__InsufficientFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"InterchainModule__NotInterchainDB\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__SameChainId\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"batch\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ethSignedBatchHash\",\"type\":\"bytes32\"}],\"name\":\"BatchVerificationRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"batch\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ethSignedBatchHash\",\"type\":\"bytes32\"}],\"name\":\"BatchVerified\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"INTERCHAIN_DB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getModuleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getModuleFee(uint256,uint256)\":{\"params\":{\"dbNonce\":\"The database nonce of the batch on the source chain\",\"dstChainId\":\"The chain id of the destination chain\"}},\"requestBatchVerification(uint256,(uint256,uint256,bytes32))\":{\"details\":\"Could be only called by the Interchain DataBase contract.\",\"params\":{\"batch\":\"The batch to verify\",\"dstChainId\":\"The chain id of the destination chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getModuleFee(uint256,uint256)\":{\"notice\":\"Get the Module fee for verifying a batch on the specified destination chain.\"},\"requestBatchVerification(uint256,(uint256,uint256,bytes32))\":{\"notice\":\"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering.\"}},\"notice\":\"Common logic for all Interchain Modules.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"InterchainModule\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{"INTERCHAIN_DB()":"e4c61247","getModuleFee(uint256,uint256)":"4a114f72","requestBatchVerification(uint256,(uint256,uint256,bytes32))":"3fdcec74"}},"solidity/SynapseModule.sol:InterchainModuleEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"batch","type":"bytes"},{"indexed":false,"internalType":"bytes32","name":"ethSignedBatchHash","type":"bytes32"}],"name":"BatchVerificationRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"batch","type":"bytes"},{"indexed":false,"internalType":"bytes32","name":"ethSignedBatchHash","type":"bytes32"}],"name":"BatchVerified","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"batch\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ethSignedBatchHash\",\"type\":\"bytes32\"}],\"name\":\"BatchVerificationRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"batch\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ethSignedBatchHash\",\"type\":\"bytes32\"}],\"name\":\"BatchVerified\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"InterchainModuleEvents\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:Math":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ae7948e9935b96dc2c5dd402f78e89c19a1830998d95d906e739ad7eb0b9d22f64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ae7948e9935b96dc2c5dd402f78e89c19a1830998d95d906e739ad7eb0b9d22f64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"19746:14914:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;19746:14914:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"19746:14914:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"MathOverflowedMulDiv","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Standard math utilities missing in the Solidity language.","errors":{"MathOverflowedMulDiv()":[{"details":"Muldiv operation overflow."}]},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"MathOverflowedMulDiv\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"Standard math utilities missing in the Solidity language.\",\"errors\":{\"MathOverflowedMulDiv()\":[{\"details\":\"Muldiv operation overflow.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"Math\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:MessageHashUtils":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220141836ee6c49c04d217b532816e18b3c19ae8b9d8313a70da2d4d085fdcc58b164736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220141836ee6c49c04d217b532816e18b3c19ae8b9d8313a70da2d4d085fdcc58b164736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"73950:3235:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;73950:3235:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"73950:3235:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing. The library provides methods for generating a hash of a message that conforms to the https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712] specifications.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing. The library provides methods for generating a hash of a message that conforms to the https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712] specifications.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"MessageHashUtils\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:ModuleBatchLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220fbb39345c2b35e7a62bc61d4a03e8ca7bb3db85e1253dd9229879c10979c543b64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220fbb39345c2b35e7a62bc61d4a03e8ca7bb3db85e1253dd9229879c10979c543b64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"52010:1013:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;52010:1013:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"52010:1013:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"ModuleBatchLib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:Ownable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the address provided by the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the address provided by the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"Ownable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{"owner()":"8da5cb5b","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}},"solidity/SynapseModule.sol:SignedMath":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220e1022bc288badb91944fab6e982d5f0b912798204994d917c988d1d3f72a9ddd64736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220e1022bc288badb91944fab6e982d5f0b912798204994d917c988d1d3f72a9ddd64736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"34887:1047:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;34887:1047:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"34887:1047:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Standard signed math utilities missing in the Solidity language.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Standard signed math utilities missing in the Solidity language.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"SignedMath\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:Strings":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122053b760071d8fd50390db42618b2c6c1d328a30be5b6b3fdaf79797238f220be364736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122053b760071d8fd50390db42618b2c6c1d328a30be5b6b3fdaf79797238f220be364736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"60969:2847:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;60969:2847:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"60969:2847:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"length","type":"uint256"}],"name":"StringsInsufficientHexLength","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"String operations.","errors":{"StringsInsufficientHexLength(uint256,uint256)":[{"details":"The `value` string doesn't fit in the specified `length`."}]},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"StringsInsufficientHexLength\",\"type\":\"error\"}],\"devdoc\":{\"details\":\"String operations.\",\"errors\":{\"StringsInsufficientHexLength(uint256,uint256)\":[{\"details\":\"The `value` string doesn't fit in the specified `length`.\"}]},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"Strings\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:SynapseModule":{"code":"0x60a06040523480156200001157600080fd5b5060405162002417380380620024178339810160408190526200003491620000ec565b6001600160a01b03808316608052819081166200006b57604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b62000076816200007f565b50505062000124565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b0381168114620000e757600080fd5b919050565b600080604083850312156200010057600080fd5b6200010b83620000cf565b91506200011b60208401620000cf565b90509250929050565b6080516122c96200014e600039600081816104c7015281816105c901526113ec01526122c96000f3fe6080604052600436106101a15760003560e01c80639a96f35b116100e1578063c415b95c1161008a578063e232d19111610064578063e232d1911461049e578063e4c61247146104b5578063e75235b8146104e9578063f2fde38b146104fe57600080fd5b8063c415b95c1461043c578063ca2dfd0a14610469578063d294f0931461048957600080fd5b8063a935e766116100bb578063a935e766146103da578063b5344257146103fc578063b80cb14b1461041c57600080fd5b80639a96f35b1461037a578063a42dce801461039a578063a87b8152146103ba57600080fd5b806366d023931161014e57806386ae47f01161012857806386ae47f0146102ef5780638da5cb5b1461030f5780639000b3d61461033a578063960bfe041461035a57600080fd5b806366d02393146102a55780636adb16b5146102c5578063715018a6146102da57600080fd5b80633fdcec741161017f5780633fdcec74146102205780634a114f72146102335780635d62a8dd1461025357600080fd5b8063178977c9146101a657806320c8eed2146101c857806333105218146101f0575b600080fd5b3480156101b257600080fd5b506101c66101c1366004611bab565b61051e565b005b3480156101d457600080fd5b506101dd610576565b6040519081526020015b60405180910390f35b3480156101fc57600080fd5b5061021061020b366004611bcd565b61059e565b60405190151581526020016101e7565b6101c661022e366004611c5b565b6105b1565b34801561023f57600080fd5b506101dd61024e366004611bab565b610792565b34801561025f57600080fd5b506009546102809073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101e7565b3480156102b157600080fd5b506101dd6102c0366004611cd2565b6107a5565b3480156102d157600080fd5b506004546101dd565b3480156102e657600080fd5b506101c66107c7565b3480156102fb57600080fd5b506101c661030a366004611ceb565b6107db565b34801561031b57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff16610280565b34801561034657600080fd5b506101c6610355366004611bcd565b610834565b34801561036657600080fd5b506101c6610375366004611cd2565b610848565b34801561038657600080fd5b506101c6610395366004611cd2565b610892565b3480156103a657600080fd5b506101c66103b5366004611bcd565b610913565b3480156103c657600080fd5b506101c66103d5366004611bcd565b61098e565b3480156103e657600080fd5b506103ef610a72565b6040516101e79190611d60565b34801561040857600080fd5b506101c6610417366004611ceb565b610a7e565b34801561042857600080fd5b506101c6610437366004611e03565b610ad1565b34801561044857600080fd5b506008546102809073ffffffffffffffffffffffffffffffffffffffff1681565b34801561047557600080fd5b506101c6610484366004611bcd565b610b76565b34801561049557600080fd5b506101c6610b87565b3480156104aa57600080fd5b506101dd620186a081565b3480156104c157600080fd5b506102807f000000000000000000000000000000000000000000000000000000000000000081565b3480156104f557600080fd5b506101dd610cb6565b34801561050a57600080fd5b506101c6610519366004611bcd565b610cc1565b610526610d22565b60008281526005602090815260409182902083905581518481529081018390527f16fd6efb66614022ccb496c36757ea86f51445694c2d6433be02d0ddc23be06991015b60405180910390a15050565b6000670de0b6b3a76400006004544761058f9190611e9e565b6105999190611eb5565b905090565b60006105ab600183610d75565b92915050565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610627576040517fb90af10e0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b468203610662576040517fad5612e300000000000000000000000000000000000000000000000000000000815246600482015260240161061e565b805146146106a25780516040517f23e3bbe8000000000000000000000000000000000000000000000000000000008152600481019190915260240161061e565b60006106b2838360200151610d84565b9050803410156106f7576040517f87ba450a0000000000000000000000000000000000000000000000000000000081523460048201526024810182905260440161061e565b6000610707848460200151610e57565b905060006107158483610f86565b805160208201207f19457468657265756d205369676e6564204d6573736167653a0a3332000000006000908152601c91909152603c812091925050857f99dfc0061f727d353cc6eb34ccdd188242f0b6e6ed2df287a551edf53219f2048383604051610782929190611f5e565b60405180910390a2505050505050565b600061079e8383610d84565b9392505050565b600081815260056020526040812054908190036107c25750620186a05b919050565b6107cf610d22565b6107d96000610fb2565b565b6107e3610d22565b8060005b8181101561082e5761081e84848381811061080457610804611f80565b90506020020160208101906108199190611bcd565b611027565b61082781611faf565b90506107e7565b50505050565b61083c610d22565b61084581611078565b50565b610850610d22565b61085b6001826110c9565b6040518181527f6c4ce60fd690e1216286a10b875c5662555f10774484e58142cedd7a90781baa906020015b60405180910390a150565b61089a610d22565b662386f26fc100008111156108de576040517f8a7acbcd0000000000000000000000000000000000000000000000000000000081526004810182905260240161061e565b60048190556040518181527fff6eea4807f1d9f8369b26f163207ca7fbbc91ec6bf92c3cd02119f9dcbb299b90602001610887565b61091b610d22565b600880547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f9c1996a14d26c3ecd833c10222d012447ef07b09b15000f3a34318ff039c0bdc90602001610887565b610996610d22565b8073ffffffffffffffffffffffffffffffffffffffff163b6000036109ff576040517fd129a3eb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8216600482015260240161061e565b600980547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f1c045b93ecd363a3ccd287c43f9ab97490903b354e7d99b149992b1e244254a990602001610887565b60606105996001611107565b610a86610d22565b8060005b8181101561082e57610ac1848483818110610aa757610aa7611f80565b9050602002016020810190610abc9190611bcd565b611078565b610aca81611faf565b9050610a8a565b6000610b218585604051610ae6929190611fe7565b60405180910390207f19457468657265756d205369676e6564204d6573736167653a0a3332000000006000908152601c91909152603c902090565b9050610b306001828585611115565b610b6f85858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061136092505050565b5050505050565b610b7e610d22565b61084581611027565b60085473ffffffffffffffffffffffffffffffffffffffff16610bd6576040517fcaa4422900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b47600003610c10576040517f1dd7191300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610c1a610576565b90506000610c288247611ff7565b600854909150610c4e9073ffffffffffffffffffffffffffffffffffffffff16826114dd565b610c5833836114dd565b6008546040805173ffffffffffffffffffffffffffffffffffffffff9092168252602082018390523390820152606081018390527ff4e6bc0a6951927d4db8490fb63528b3c4ccb43865870fe4e3db7a090cbb14b19060800161056a565b600061059960015490565b610cc9610d22565b73ffffffffffffffffffffffffffffffffffffffff8116610d19576040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526000600482015260240161061e565b61084581610fb2565b60005473ffffffffffffffffffffffffffffffffffffffff1633146107d9576040517f118cdaa700000000000000000000000000000000000000000000000000000000815233600482015260240161061e565b600061079e60018401836115b8565b6000610d8e6115e7565b73ffffffffffffffffffffffffffffffffffffffff16635cbd3c4884610db3866107a5565b610dbb610cb6565b610dc6906040611e9e565b610dd29061010461200a565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b168152600481019390935260248301919091526044820152606401602060405180830381865afa158015610e33573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061079e919061201d565b6060610e616115e7565b73ffffffffffffffffffffffffffffffffffffffff16636f928aa76040518163ffffffff1660e01b8152600401600060405180830381865afa158015610eab573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052610ef191908101906120dc565b8051909150156105ab578051602080830191909120600085815260069092526040909120548103610f3357604051806020016040528060008152509150610f7f565b60008481526006602052604090819020829055517fc8f0247ee5309fd4ba1e0bb1827f91d488ef9aa208d06a77ac10d7771f85b2e490610f769086908590612119565b60405180910390a15b5092915050565b60608282604051602001610f9b929190612132565b604051602081830303815290604052905092915050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b61103260018261163a565b60405173ffffffffffffffffffffffffffffffffffffffff821681527f44a3cd4eb5cc5748f6169df057b1cb2ae4c383e87cd94663c430e095d4cba42490602001610887565b61108360018261169a565b60405173ffffffffffffffffffffffffffffffffffffffff821681527f6d05492139c5ea989514a5d2150c028041e5c087e2a39967f67dc7d2655adb8190602001610887565b80600003611103576040517f9a6378d400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b9055565b60606105ab82600101611747565b6000611122604183611eb5565b905081611130604183611e9e565b1461116a576040517fca4f91000000000000000000000000000000000000000000000000000000000081526004810183905260240161061e565b845460008190036111a7576040517f9a6378d400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000806000805b858110156113105760008885896111c660418361200a565b926111d393929190612160565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525093945083925061121791508d905084611754565b50909250905060008160038111156112315761123161218a565b1461126a57826040517fec8565ea00000000000000000000000000000000000000000000000000000000815260040161061e91906121b9565b8473ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16116112cf576040517f0da2019900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8194506112dc8d83610d75565b156112ef576112ec60018761200a565b95505b6112fa60418861200a565b96505050508061130990611faf565b90506111ae565b5083821015611355576040517fdfc0bbc8000000000000000000000000000000000000000000000000000000008152600481018390526024810185905260440161061e565b505050505050505050565b60008061136c836117a1565b91509150468260000151036113af576040517fad5612e300000000000000000000000000000000000000000000000000000000815246600482015260240161061e565b6040517f05d0728c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906305d0728c906114219085906004016121cc565b600060405180830381600087803b15801561143b57600080fd5b505af115801561144f573d6000803e3d6000fd5b5050505061146682600001518360200151836117dd565b8151835160208501207f19457468657265756d205369676e6564204d6573736167653a0a3332000000006000908152601c91909152603c90206040517f3753b65288c95291b47fb4665e4dfc7531eb8d9301de678db6d54ebed5d2ae54916114d091879190611f5e565b60405180910390a2505050565b80471015611519576040517fcd78605900000000000000000000000000000000000000000000000000000000815230600482015260240161061e565b60008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d8060008114611573576040519150601f19603f3d011682016040523d82523d6000602084013e611578565b606091505b50509050806115b3576040517f1425ea4200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050565b73ffffffffffffffffffffffffffffffffffffffff81166000908152600183016020526040812054151561079e565b60095473ffffffffffffffffffffffffffffffffffffffff1680611637576040517fb31c611e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b90565b600061164960018401836118cf565b9050806115b3576040517f5689319100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8316600482015260240161061e565b73ffffffffffffffffffffffffffffffffffffffff81166116e7576040517fe5ff8d7200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006116f660018401836118f1565b9050806115b3576040517ff09690b100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8316600482015260240161061e565b6060600061079e83611913565b6000806000835160410361178e5760208401516040850151606086015160001a6117808882858561196f565b95509550955050505061179a565b50508151600091506002905b9250925092565b60408051606081018252600080825260208201819052918101919091526060828060200190518101906117d491906121ed565b91509150915091565b80516000036117eb57505050565b60008381526007602052604090205480158061180657508281105b1561082e5760008481526007602052604090208390556118246115e7565b73ffffffffffffffffffffffffffffffffffffffff16635299976985846040518363ffffffff1660e01b815260040161185e929190612119565b600060405180830381600087803b15801561187857600080fd5b505af115801561188c573d6000803e3d6000fd5b505050507fca8f9b769e73367330805ba4c14b20e6976ebc6478999c6a9be1cfa9dc2d432b84836040516118c1929190612119565b60405180910390a150505050565b600061079e8373ffffffffffffffffffffffffffffffffffffffff8416611a69565b600061079e8373ffffffffffffffffffffffffffffffffffffffff8416611b5c565b60608160000180548060200260200160405190810160405280929190818152602001828054801561196357602002820191906000526020600020905b81548152602001906001019080831161194f575b50505050509050919050565b600080807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08411156119aa5750600091506003905082611a5f565b604080516000808252602082018084528a905260ff891692820192909252606081018790526080810186905260019060a0016020604051602081039080840390855afa1580156119fe573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff8116611a5557506000925060019150829050611a5f565b9250600091508190505b9450945094915050565b60008181526001830160205260408120548015611b52576000611a8d600183611ff7565b8554909150600090611aa190600190611ff7565b9050808214611b06576000866000018281548110611ac157611ac1611f80565b9060005260206000200154905080876000018481548110611ae457611ae4611f80565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080611b1757611b17612264565b6001900381819060005260206000200160009055905585600101600086815260200190815260200160002060009055600193505050506105ab565b60009150506105ab565b6000818152600183016020526040812054611ba3575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556105ab565b5060006105ab565b60008060408385031215611bbe57600080fd5b50508035926020909101359150565b600060208284031215611bdf57600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461079e57600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff81118282101715611c5557611c55611c03565b60405290565b6000808284036080811215611c6f57600080fd5b8335925060607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082011215611ca357600080fd5b50611cac611c32565b602084013581526040840135602082015260608401356040820152809150509250929050565b600060208284031215611ce457600080fd5b5035919050565b60008060208385031215611cfe57600080fd5b823567ffffffffffffffff80821115611d1657600080fd5b818501915085601f830112611d2a57600080fd5b813581811115611d3957600080fd5b8660208260051b8501011115611d4e57600080fd5b60209290920196919550909350505050565b6020808252825182820181905260009190848201906040850190845b81811015611dae57835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101611d7c565b50909695505050505050565b60008083601f840112611dcc57600080fd5b50813567ffffffffffffffff811115611de457600080fd5b602083019150836020828501011115611dfc57600080fd5b9250929050565b60008060008060408587031215611e1957600080fd5b843567ffffffffffffffff80821115611e3157600080fd5b611e3d88838901611dba565b90965094506020870135915080821115611e5657600080fd5b50611e6387828801611dba565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b80820281158282048414176105ab576105ab611e6f565b600082611eeb577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60005b83811015611f0b578181015183820152602001611ef3565b50506000910152565b60008151808452611f2c816020860160208601611ef0565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b604081526000611f716040830185611f14565b90508260208301529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611fe057611fe0611e6f565b5060010190565b8183823760009101908152919050565b818103818111156105ab576105ab611e6f565b808201808211156105ab576105ab611e6f565b60006020828403121561202f57600080fd5b5051919050565b600082601f83011261204757600080fd5b815167ffffffffffffffff8082111561206257612062611c03565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019082821181831017156120a8576120a8611c03565b816040528381528660208588010111156120c157600080fd5b6120d2846020830160208901611ef0565b9695505050505050565b6000602082840312156120ee57600080fd5b815167ffffffffffffffff81111561210557600080fd5b61211184828501612036565b949350505050565b8281526040602082015260006121116040830184611f14565b8251815260208084015190820152604080840151908201526080606082015260006121116080830184611f14565b6000808585111561217057600080fd5b8386111561217d57600080fd5b5050820193919092039150565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60208152600061079e6020830184611f14565b815181526020808301519082015260408083015190820152606081016105ab565b600080828403608081121561220157600080fd5b606081121561220f57600080fd5b50612218611c32565b83518152602084015160208201526040840151604082015280925050606083015167ffffffffffffffff81111561224e57600080fd5b61225a85828601612036565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fdfea264697066735822122050d227aeb49931ca7e8a4fffdf20c879305b787f8695727f8900c20815daf50964736f6c63430008140033","runtime-code":"0x6080604052600436106101a15760003560e01c80639a96f35b116100e1578063c415b95c1161008a578063e232d19111610064578063e232d1911461049e578063e4c61247146104b5578063e75235b8146104e9578063f2fde38b146104fe57600080fd5b8063c415b95c1461043c578063ca2dfd0a14610469578063d294f0931461048957600080fd5b8063a935e766116100bb578063a935e766146103da578063b5344257146103fc578063b80cb14b1461041c57600080fd5b80639a96f35b1461037a578063a42dce801461039a578063a87b8152146103ba57600080fd5b806366d023931161014e57806386ae47f01161012857806386ae47f0146102ef5780638da5cb5b1461030f5780639000b3d61461033a578063960bfe041461035a57600080fd5b806366d02393146102a55780636adb16b5146102c5578063715018a6146102da57600080fd5b80633fdcec741161017f5780633fdcec74146102205780634a114f72146102335780635d62a8dd1461025357600080fd5b8063178977c9146101a657806320c8eed2146101c857806333105218146101f0575b600080fd5b3480156101b257600080fd5b506101c66101c1366004611bab565b61051e565b005b3480156101d457600080fd5b506101dd610576565b6040519081526020015b60405180910390f35b3480156101fc57600080fd5b5061021061020b366004611bcd565b61059e565b60405190151581526020016101e7565b6101c661022e366004611c5b565b6105b1565b34801561023f57600080fd5b506101dd61024e366004611bab565b610792565b34801561025f57600080fd5b506009546102809073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101e7565b3480156102b157600080fd5b506101dd6102c0366004611cd2565b6107a5565b3480156102d157600080fd5b506004546101dd565b3480156102e657600080fd5b506101c66107c7565b3480156102fb57600080fd5b506101c661030a366004611ceb565b6107db565b34801561031b57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff16610280565b34801561034657600080fd5b506101c6610355366004611bcd565b610834565b34801561036657600080fd5b506101c6610375366004611cd2565b610848565b34801561038657600080fd5b506101c6610395366004611cd2565b610892565b3480156103a657600080fd5b506101c66103b5366004611bcd565b610913565b3480156103c657600080fd5b506101c66103d5366004611bcd565b61098e565b3480156103e657600080fd5b506103ef610a72565b6040516101e79190611d60565b34801561040857600080fd5b506101c6610417366004611ceb565b610a7e565b34801561042857600080fd5b506101c6610437366004611e03565b610ad1565b34801561044857600080fd5b506008546102809073ffffffffffffffffffffffffffffffffffffffff1681565b34801561047557600080fd5b506101c6610484366004611bcd565b610b76565b34801561049557600080fd5b506101c6610b87565b3480156104aa57600080fd5b506101dd620186a081565b3480156104c157600080fd5b506102807f000000000000000000000000000000000000000000000000000000000000000081565b3480156104f557600080fd5b506101dd610cb6565b34801561050a57600080fd5b506101c6610519366004611bcd565b610cc1565b610526610d22565b60008281526005602090815260409182902083905581518481529081018390527f16fd6efb66614022ccb496c36757ea86f51445694c2d6433be02d0ddc23be06991015b60405180910390a15050565b6000670de0b6b3a76400006004544761058f9190611e9e565b6105999190611eb5565b905090565b60006105ab600183610d75565b92915050565b3373ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001614610627576040517fb90af10e0000000000000000000000000000000000000000000000000000000081523360048201526024015b60405180910390fd5b468203610662576040517fad5612e300000000000000000000000000000000000000000000000000000000815246600482015260240161061e565b805146146106a25780516040517f23e3bbe8000000000000000000000000000000000000000000000000000000008152600481019190915260240161061e565b60006106b2838360200151610d84565b9050803410156106f7576040517f87ba450a0000000000000000000000000000000000000000000000000000000081523460048201526024810182905260440161061e565b6000610707848460200151610e57565b905060006107158483610f86565b805160208201207f19457468657265756d205369676e6564204d6573736167653a0a3332000000006000908152601c91909152603c812091925050857f99dfc0061f727d353cc6eb34ccdd188242f0b6e6ed2df287a551edf53219f2048383604051610782929190611f5e565b60405180910390a2505050505050565b600061079e8383610d84565b9392505050565b600081815260056020526040812054908190036107c25750620186a05b919050565b6107cf610d22565b6107d96000610fb2565b565b6107e3610d22565b8060005b8181101561082e5761081e84848381811061080457610804611f80565b90506020020160208101906108199190611bcd565b611027565b61082781611faf565b90506107e7565b50505050565b61083c610d22565b61084581611078565b50565b610850610d22565b61085b6001826110c9565b6040518181527f6c4ce60fd690e1216286a10b875c5662555f10774484e58142cedd7a90781baa906020015b60405180910390a150565b61089a610d22565b662386f26fc100008111156108de576040517f8a7acbcd0000000000000000000000000000000000000000000000000000000081526004810182905260240161061e565b60048190556040518181527fff6eea4807f1d9f8369b26f163207ca7fbbc91ec6bf92c3cd02119f9dcbb299b90602001610887565b61091b610d22565b600880547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f9c1996a14d26c3ecd833c10222d012447ef07b09b15000f3a34318ff039c0bdc90602001610887565b610996610d22565b8073ffffffffffffffffffffffffffffffffffffffff163b6000036109ff576040517fd129a3eb00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8216600482015260240161061e565b600980547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f1c045b93ecd363a3ccd287c43f9ab97490903b354e7d99b149992b1e244254a990602001610887565b60606105996001611107565b610a86610d22565b8060005b8181101561082e57610ac1848483818110610aa757610aa7611f80565b9050602002016020810190610abc9190611bcd565b611078565b610aca81611faf565b9050610a8a565b6000610b218585604051610ae6929190611fe7565b60405180910390207f19457468657265756d205369676e6564204d6573736167653a0a3332000000006000908152601c91909152603c902090565b9050610b306001828585611115565b610b6f85858080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061136092505050565b5050505050565b610b7e610d22565b61084581611027565b60085473ffffffffffffffffffffffffffffffffffffffff16610bd6576040517fcaa4422900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b47600003610c10576040517f1dd7191300000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000610c1a610576565b90506000610c288247611ff7565b600854909150610c4e9073ffffffffffffffffffffffffffffffffffffffff16826114dd565b610c5833836114dd565b6008546040805173ffffffffffffffffffffffffffffffffffffffff9092168252602082018390523390820152606081018390527ff4e6bc0a6951927d4db8490fb63528b3c4ccb43865870fe4e3db7a090cbb14b19060800161056a565b600061059960015490565b610cc9610d22565b73ffffffffffffffffffffffffffffffffffffffff8116610d19576040517f1e4fbdf70000000000000000000000000000000000000000000000000000000081526000600482015260240161061e565b61084581610fb2565b60005473ffffffffffffffffffffffffffffffffffffffff1633146107d9576040517f118cdaa700000000000000000000000000000000000000000000000000000000815233600482015260240161061e565b600061079e60018401836115b8565b6000610d8e6115e7565b73ffffffffffffffffffffffffffffffffffffffff16635cbd3c4884610db3866107a5565b610dbb610cb6565b610dc6906040611e9e565b610dd29061010461200a565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e086901b168152600481019390935260248301919091526044820152606401602060405180830381865afa158015610e33573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061079e919061201d565b6060610e616115e7565b73ffffffffffffffffffffffffffffffffffffffff16636f928aa76040518163ffffffff1660e01b8152600401600060405180830381865afa158015610eab573d6000803e3d6000fd5b505050506040513d6000823e601f3d9081017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0168201604052610ef191908101906120dc565b8051909150156105ab578051602080830191909120600085815260069092526040909120548103610f3357604051806020016040528060008152509150610f7f565b60008481526006602052604090819020829055517fc8f0247ee5309fd4ba1e0bb1827f91d488ef9aa208d06a77ac10d7771f85b2e490610f769086908590612119565b60405180910390a15b5092915050565b60608282604051602001610f9b929190612132565b604051602081830303815290604052905092915050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b61103260018261163a565b60405173ffffffffffffffffffffffffffffffffffffffff821681527f44a3cd4eb5cc5748f6169df057b1cb2ae4c383e87cd94663c430e095d4cba42490602001610887565b61108360018261169a565b60405173ffffffffffffffffffffffffffffffffffffffff821681527f6d05492139c5ea989514a5d2150c028041e5c087e2a39967f67dc7d2655adb8190602001610887565b80600003611103576040517f9a6378d400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b9055565b60606105ab82600101611747565b6000611122604183611eb5565b905081611130604183611e9e565b1461116a576040517fca4f91000000000000000000000000000000000000000000000000000000000081526004810183905260240161061e565b845460008190036111a7576040517f9a6378d400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000806000805b858110156113105760008885896111c660418361200a565b926111d393929190612160565b8080601f016020809104026020016040519081016040528093929190818152602001838380828437600092018290525093945083925061121791508d905084611754565b50909250905060008160038111156112315761123161218a565b1461126a57826040517fec8565ea00000000000000000000000000000000000000000000000000000000815260040161061e91906121b9565b8473ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16116112cf576040517f0da2019900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8194506112dc8d83610d75565b156112ef576112ec60018761200a565b95505b6112fa60418861200a565b96505050508061130990611faf565b90506111ae565b5083821015611355576040517fdfc0bbc8000000000000000000000000000000000000000000000000000000008152600481018390526024810185905260440161061e565b505050505050505050565b60008061136c836117a1565b91509150468260000151036113af576040517fad5612e300000000000000000000000000000000000000000000000000000000815246600482015260240161061e565b6040517f05d0728c00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016906305d0728c906114219085906004016121cc565b600060405180830381600087803b15801561143b57600080fd5b505af115801561144f573d6000803e3d6000fd5b5050505061146682600001518360200151836117dd565b8151835160208501207f19457468657265756d205369676e6564204d6573736167653a0a3332000000006000908152601c91909152603c90206040517f3753b65288c95291b47fb4665e4dfc7531eb8d9301de678db6d54ebed5d2ae54916114d091879190611f5e565b60405180910390a2505050565b80471015611519576040517fcd78605900000000000000000000000000000000000000000000000000000000815230600482015260240161061e565b60008273ffffffffffffffffffffffffffffffffffffffff168260405160006040518083038185875af1925050503d8060008114611573576040519150601f19603f3d011682016040523d82523d6000602084013e611578565b606091505b50509050806115b3576040517f1425ea4200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505050565b73ffffffffffffffffffffffffffffffffffffffff81166000908152600183016020526040812054151561079e565b60095473ffffffffffffffffffffffffffffffffffffffff1680611637576040517fb31c611e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b90565b600061164960018401836118cf565b9050806115b3576040517f5689319100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8316600482015260240161061e565b73ffffffffffffffffffffffffffffffffffffffff81166116e7576040517fe5ff8d7200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006116f660018401836118f1565b9050806115b3576040517ff09690b100000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8316600482015260240161061e565b6060600061079e83611913565b6000806000835160410361178e5760208401516040850151606086015160001a6117808882858561196f565b95509550955050505061179a565b50508151600091506002905b9250925092565b60408051606081018252600080825260208201819052918101919091526060828060200190518101906117d491906121ed565b91509150915091565b80516000036117eb57505050565b60008381526007602052604090205480158061180657508281105b1561082e5760008481526007602052604090208390556118246115e7565b73ffffffffffffffffffffffffffffffffffffffff16635299976985846040518363ffffffff1660e01b815260040161185e929190612119565b600060405180830381600087803b15801561187857600080fd5b505af115801561188c573d6000803e3d6000fd5b505050507fca8f9b769e73367330805ba4c14b20e6976ebc6478999c6a9be1cfa9dc2d432b84836040516118c1929190612119565b60405180910390a150505050565b600061079e8373ffffffffffffffffffffffffffffffffffffffff8416611a69565b600061079e8373ffffffffffffffffffffffffffffffffffffffff8416611b5c565b60608160000180548060200260200160405190810160405280929190818152602001828054801561196357602002820191906000526020600020905b81548152602001906001019080831161194f575b50505050509050919050565b600080807f7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a08411156119aa5750600091506003905082611a5f565b604080516000808252602082018084528a905260ff891692820192909252606081018790526080810186905260019060a0016020604051602081039080840390855afa1580156119fe573d6000803e3d6000fd5b50506040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0015191505073ffffffffffffffffffffffffffffffffffffffff8116611a5557506000925060019150829050611a5f565b9250600091508190505b9450945094915050565b60008181526001830160205260408120548015611b52576000611a8d600183611ff7565b8554909150600090611aa190600190611ff7565b9050808214611b06576000866000018281548110611ac157611ac1611f80565b9060005260206000200154905080876000018481548110611ae457611ae4611f80565b6000918252602080832090910192909255918252600188019052604090208390555b8554869080611b1757611b17612264565b6001900381819060005260206000200160009055905585600101600086815260200190815260200160002060009055600193505050506105ab565b60009150506105ab565b6000818152600183016020526040812054611ba3575081546001818101845560008481526020808220909301849055845484825282860190935260409020919091556105ab565b5060006105ab565b60008060408385031215611bbe57600080fd5b50508035926020909101359150565b600060208284031215611bdf57600080fd5b813573ffffffffffffffffffffffffffffffffffffffff8116811461079e57600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516060810167ffffffffffffffff81118282101715611c5557611c55611c03565b60405290565b6000808284036080811215611c6f57600080fd5b8335925060607fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe082011215611ca357600080fd5b50611cac611c32565b602084013581526040840135602082015260608401356040820152809150509250929050565b600060208284031215611ce457600080fd5b5035919050565b60008060208385031215611cfe57600080fd5b823567ffffffffffffffff80821115611d1657600080fd5b818501915085601f830112611d2a57600080fd5b813581811115611d3957600080fd5b8660208260051b8501011115611d4e57600080fd5b60209290920196919550909350505050565b6020808252825182820181905260009190848201906040850190845b81811015611dae57835173ffffffffffffffffffffffffffffffffffffffff1683529284019291840191600101611d7c565b50909695505050505050565b60008083601f840112611dcc57600080fd5b50813567ffffffffffffffff811115611de457600080fd5b602083019150836020828501011115611dfc57600080fd5b9250929050565b60008060008060408587031215611e1957600080fd5b843567ffffffffffffffff80821115611e3157600080fd5b611e3d88838901611dba565b90965094506020870135915080821115611e5657600080fd5b50611e6387828801611dba565b95989497509550505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b80820281158282048414176105ab576105ab611e6f565b600082611eeb577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b60005b83811015611f0b578181015183820152602001611ef3565b50506000910152565b60008151808452611f2c816020860160208601611ef0565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b604081526000611f716040830185611f14565b90508260208301529392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8203611fe057611fe0611e6f565b5060010190565b8183823760009101908152919050565b818103818111156105ab576105ab611e6f565b808201808211156105ab576105ab611e6f565b60006020828403121561202f57600080fd5b5051919050565b600082601f83011261204757600080fd5b815167ffffffffffffffff8082111561206257612062611c03565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019082821181831017156120a8576120a8611c03565b816040528381528660208588010111156120c157600080fd5b6120d2846020830160208901611ef0565b9695505050505050565b6000602082840312156120ee57600080fd5b815167ffffffffffffffff81111561210557600080fd5b61211184828501612036565b949350505050565b8281526040602082015260006121116040830184611f14565b8251815260208084015190820152604080840151908201526080606082015260006121116080830184611f14565b6000808585111561217057600080fd5b8386111561217d57600080fd5b5050820193919092039150565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b60208152600061079e6020830184611f14565b815181526020808301519082015260408083015190820152606081016105ab565b600080828403608081121561220157600080fd5b606081121561220f57600080fd5b50612218611c32565b83518152602084015160208201526040840151604082015280925050606083015167ffffffffffffffff81111561224e57600080fd5b61225a85828601612036565b9150509250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fdfea264697066735822122050d227aeb49931ca7e8a4fffdf20c879305b787f8695727f8900c20815daf50964736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"88596:10304:0:-:0;;;89719:211;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;85579:28:0;;;;;89808:6;;54253:26;;54249:95;;54302:31;;-1:-1:-1;;;54302:31:0;;54330:1;54302:31;;;640:51:1;613:18;;54302:31:0;;;;;;;54249:95;54353:32;54372:12;54353:18;:32::i;:::-;54205:187;89719:211;;88596:10304;;55892:187;55965:16;55984:6;;-1:-1:-1;;;;;56000:17:0;;;-1:-1:-1;;;;;;56000:17:0;;;;;;56032:40;;55984:6;;;;;;;56032:40;;55965:16;56032:40;55955:124;55892:187;:::o;14:177:1:-;93:13;;-1:-1:-1;;;;;135:31:1;;125:42;;115:70;;181:1;178;171:12;115:70;14:177;;;:::o;196:293::-;275:6;283;336:2;324:9;315:7;311:23;307:32;304:52;;;352:1;349;342:12;304:52;375:40;405:9;375:40;:::i;:::-;365:50;;434:49;479:2;468:9;464:18;434:49;:::i;:::-;424:59;;196:293;;;;;:::o;494:203::-;88596:10304:0;;;;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"88596:10304:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;92172:188;;;;;;;;;;-1:-1:-1;92172:188:0;;;;;:::i;:::-;;:::i;:::-;;94446:140;;;;;;;;;;;;;:::i;:::-;;;413:25:1;;;401:2;386:18;94446:140:0;;;;;;;;94287:118;;;;;;;;;;-1:-1:-1;94287:118:0;;;;;:::i;:::-;;:::i;:::-;;;928:14:1;;921:22;903:41;;891:2;876:18;94287:118:0;763:187:1;85658:1126:0;;;;;;:::i;:::-;;:::i;86828:149::-;;;;;;;;;;-1:-1:-1;86828:149:0;;;;;:::i;:::-;;:::i;89688:24::-;;;;;;;;;;-1:-1:-1;89688:24:0;;;;;;;;;;;2195:42:1;2183:55;;;2165:74;;2153:2;2138:18;89688:24:0;2019:226:1;94771:232:0;;;;;;;;;;-1:-1:-1;94771:232:0;;;;;:::i;:::-;;:::i;93989:104::-;;;;;;;;;;-1:-1:-1;94069:17:0;;93989:104;;55273:101;;;;;;;;;;;;;:::i;90832:224::-;;;;;;;;;;-1:-1:-1;90832:224:0;;;;;:::i;:::-;;:::i;54618:85::-;;;;;;;;;;-1:-1:-1;54664:7:0;54690:6;;;54618:85;;90291:97;;;;;;;;;;-1:-1:-1;90291:97:0;;;;;:::i;:::-;;:::i;91097:156::-;;;;;;;;;;-1:-1:-1;91097:156:0;;;;;:::i;:::-;;:::i;91496:330::-;;;;;;;;;;-1:-1:-1;91496:330:0;;;;;:::i;:::-;;:::i;91294:161::-;;;;;;;;;;-1:-1:-1;91294:161:0;;;;;:::i;:::-;;:::i;91867:264::-;;;;;;;;;;-1:-1:-1;91867:264:0;;;;;:::i;:::-;;:::i;94134:112::-;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;90429:218::-;;;;;;;;;;-1:-1:-1;90429:218:0;;;;;:::i;:::-;;:::i;93317:297::-;;;;;;;;;;-1:-1:-1;93317:297:0;;;;;:::i;:::-;;:::i;89620:27::-;;;;;;;;;;-1:-1:-1;89620:27:0;;;;;;;;90688:103;;;;;;;;;;-1:-1:-1;90688:103:0;;;;;:::i;:::-;;:::i;92717:559::-;;;;;;;;;;;;;:::i;88750:58::-;;;;;;;;;;;;88801:7;88750:58;;85490:38;;;;;;;;;;;;;;;94627:103;;;;;;;;;;;;;:::i;55523:215::-;;;;;;;;;;-1:-1:-1;55523:215:0;;;;;:::i;:::-;;:::i;92172:188::-;54511:13;:11;:13::i;:::-;92263:24:::1;::::0;;;:15:::1;:24;::::0;;;;;;;;:35;;;92313:40;;4989:25:1;;;5030:18;;;5023:34;;;92313:40:0::1;::::0;4962:18:1;92313:40:0::1;;;;;;;;92172:188:::0;;:::o;94446:140::-;94496:7;88927:4;94546:17;;94522:21;:41;;;;:::i;:::-;:57;;;;:::i;:::-;94515:64;;94446:140;:::o;94287:118::-;94347:4;94370:28;:10;94390:7;94370:19;:28::i;:::-;94363:35;94287:118;-1:-1:-1;;94287:118:0:o;85658:1126::-;85773:10;:27;85787:13;85773:27;;85769:110;;85823:45;;;;;85857:10;85823:45;;;2165:74:1;2138:18;;85823:45:0;;;;;;;;85769:110;85906:13;85892:10;:27;85888:109;;85942:44;;;;;85972:13;85942:44;;;413:25:1;386:18;;85942:44:0;267:177:1;85888:109:0;86010:16;;86030:13;86010:33;86006:140;;86117:16;;86066:69;;;;;;;;413:25:1;;;;386:18;;86066:69:0;267:177:1;86006:140:0;86155:19;86177:40;86191:10;86203:5;:13;;;86177;:40::i;:::-;86155:62;;86243:11;86231:9;:23;86227:138;;;86277:77;;;;;86320:9;86277:77;;;4989:25:1;5030:18;;;5023:34;;;4962:18;;86277:77:0;4815:248:1;86227:138:0;86374:23;86400:42;86416:10;86428:5;:13;;;86400:15;:42::i;:::-;86374:68;;86452:25;86480:51;86513:5;86520:10;86480:32;:51::i;:::-;86610:23;;;;;;74832:34;86541:26;74819:48;;;74928:4;74921:25;;;;75026:4;75010:21;;86452:79;;-1:-1:-1;86541:93:0;86732:10;86705:72;86744:12;86758:18;86705:72;;;;;;;:::i;:::-;;;;;;;;85759:1025;;;;85658:1126;;:::o;86828:149::-;86910:7;86936:34;86950:10;86962:7;86936:13;:34::i;:::-;86929:41;86828:149;-1:-1:-1;;;86828:149:0:o;94771:232::-;94845:16;94884:24;;;:15;:24;;;;;;;94922:13;;;94918:79;;-1:-1:-1;88801:7:0;94918:79;94771:232;;;:::o;55273:101::-;54511:13;:11;:13::i;:::-;55337:30:::1;55364:1;55337:18;:30::i;:::-;55273:101::o:0;90832:224::-;54511:13;:11;:13::i;:::-;90933:9;90916:14:::1;90959:91;90983:6;90979:1;:10;90959:91;;;91010:29;91026:9;;91036:1;91026:12;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;91010:15;:29::i;:::-;90991:3;::::0;::::1;:::i;:::-;;;90959:91;;;;90906:150;90832:224:::0;;:::o;90291:97::-;54511:13;:11;:13::i;:::-;90359:22:::1;90372:8;90359:12;:22::i;:::-;90291:97:::0;:::o;91097:156::-;54511:13;:11;:13::i;:::-;91167:37:::1;:10;91194:9:::0;91167:26:::1;:37::i;:::-;91219:27;::::0;413:25:1;;;91219:27:0::1;::::0;401:2:1;386:18;91219:27:0::1;;;;;;;;91097:156:::0;:::o;91496:330::-;54511:13;:11;:13::i;:::-;88866:7:::1;91584:16;:41;91580:138;;;91648:59;::::0;::::1;::::0;;::::1;::::0;::::1;413:25:1::0;;;386:18;;91648:59:0::1;267:177:1::0;91580:138:0::1;91727:17;:36:::0;;;91778:41:::1;::::0;413:25:1;;;91778:41:0::1;::::0;401:2:1;386:18;91778:41:0::1;267:177:1::0;91294:161:0;54511:13;:11;:13::i;:::-;91371:12:::1;:28:::0;;;::::1;;::::0;::::1;::::0;;::::1;::::0;;;91414:34:::1;::::0;2165:74:1;;;91414:34:0::1;::::0;2153:2:1;2138:18;91414:34:0::1;2019:226:1::0;91867:264:0;54511:13;:11;:13::i;:::-;91942:10:::1;:22;;;91968:1;91942:27:::0;91938:112:::1;;91992:47;::::0;::::1;::::0;;2195:42:1;2183:55;;91992:47:0::1;::::0;::::1;2165:74:1::0;2138:18;;91992:47:0::1;2019:226:1::0;91938:112:0::1;92059:9;:22:::0;;;::::1;;::::0;::::1;::::0;;::::1;::::0;;;92096:28:::1;::::0;2165:74:1;;;92096:28:0::1;::::0;2153:2:1;2138:18;92096:28:0::1;2019:226:1::0;94134:112:0;94181:16;94216:23;:10;:21;:23::i;90429:218::-;54511:13;:11;:13::i;:::-;90527:9;90510:14:::1;90553:88;90577:6;90573:1;:10;90553:88;;;90604:26;90617:9;;90627:1;90617:12;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;90604;:26::i;:::-;90585:3;::::0;::::1;:::i;:::-;;;90553:88;;93317:297:::0;93419:21;93443:64;93493:12;;93483:23;;;;;;;:::i;:::-;;;;;;;;74832:34;74727:14;74819:48;;;74928:4;74921:25;;;;75026:4;75010:21;;;74651:460;93443:64;93419:88;-1:-1:-1;93517:54:0;:10;93419:88;93560:10;;93517:27;:54::i;:::-;93581:26;93594:12;;93581:26;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;93581:12:0;;-1:-1:-1;;;93581:26:0:i;:::-;93409:205;93317:297;;;;:::o;90688:103::-;54511:13;:11;:13::i;:::-;90759:25:::1;90775:8;90759:15;:25::i;92717:559::-:0;92761:12;;:26;:12;92757:99;;92810:35;;;;;;;;;;;;;;92757:99;92869:21;92894:1;92869:26;92865:94;;92918:30;;;;;;;;;;;;;;92865:94;92968:16;92987:19;:17;:19::i;:::-;92968:38;-1:-1:-1;93016:20:0;93039:32;92968:38;93039:21;:32;:::i;:::-;93107:12;;93016:55;;-1:-1:-1;93081:54:0;;93107:12;;93016:55;93081:17;:54::i;:::-;93145:48;93171:10;93184:8;93145:17;:48::i;:::-;93220:12;;93208:61;;;93220:12;;;;7681:34:1;;7746:2;7731:18;;7724:34;;;93248:10:0;7774:18:1;;;7767:43;7841:2;7826:18;;7819:34;;;93208:61:0;;7607:3:1;7592:19;93208:61:0;7389:470:1;94627:103:0;94672:7;94698:25;:10;58512:15;;58412:122;55523:215;54511:13;:11;:13::i;:::-;55607:22:::1;::::0;::::1;55603:91;;55652:31;::::0;::::1;::::0;;55680:1:::1;55652:31;::::0;::::1;2165:74:1::0;2138:18;;55652:31:0::1;2019:226:1::0;55603:91:0::1;55703:28;55722:8;55703:18;:28::i;54776:162::-:0;54664:7;54690:6;54835:23;54690:6;11567:10;54835:23;54831:101;;54881:40;;;;;11567:10;54881:40;;;2165:74:1;2138:18;;54881:40:0;2019:226:1;58010:148:0;58097:4;58120:31;:13;;;58143:7;58120:22;:31::i;97678:844::-;97827:7;98309:22;:20;:22::i;:::-;:49;;;98388:10;98422:29;98440:10;98422:17;:29::i;:::-;98490:14;:12;:14::i;:::-;98485:19;;:2;:19;:::i;:::-;98479:25;;:3;:25;:::i;:::-;98309:206;;;;;;;;;;;;;8196:25:1;;;;8237:18;;;8230:34;;;;8280:18;;;8273:34;8169:18;;98309:206:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;95905:666::-;96043:23;96095:22;:20;:22::i;:::-;:38;;;:40;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;96188:17;;96082:53;;-1:-1:-1;96184:70:0;96226:17;96184:70;96282:21;;;;;;;;;;96263:16;96371:28;;;:16;:28;;;;;;;;96359:40;;96355:210;;96415:15;;;;;;;;;;;;;;96355:210;;;96461:28;;;;:16;:28;;;;;;;:39;;;96519:35;;;;;96478:10;;96543;;96519:35;:::i;:::-;;;;;;;;96355:210;96072:499;95905:666;;;;:::o;52259:222::-;52410:12;52456:5;52463:10;52445:29;;;;;;;;;:::i;:::-;;;;;;;;;;;;;52438:36;;52259:222;;;;:::o;55892:187::-;55965:16;55984:6;;;56000:17;;;;;;;;;;56032:40;;55984:6;;;;;;;56032:40;;55965:16;56032:40;55955:124;55892:187;:::o;95668:142::-;95730:33;:10;95754:8;95730:23;:33::i;:::-;95778:25;;2195:42:1;2183:55;;2165:74;;95778:25:0;;2153:2:1;2138:18;95778:25:0;2019:226:1;95424:134:0;95483:30;:10;95504:8;95483:20;:30::i;:::-;95528:23;;2195:42:1;2183:55;;2165:74;;95528:23:0;;2153:2:1;2138:18;95528:23:0;2019:226:1;57735:218:0;57831:9;57844:1;57831:14;57827:83;;57868:31;;;;;;;;;;;;;;57827:83;57919:27;;57735:218::o;58211:136::-;58283:16;58318:22;:4;:13;;:20;:22::i;59052:1750::-;59238:24;59265:36;56429:2;59265:10;:36;:::i;:::-;59238:63;-1:-1:-1;59354:10:0;59315:35;56429:2;59238:63;59315:35;:::i;:::-;:56;59311:154;;59394:60;;;;;;;;413:25:1;;;386:18;;59394:60:0;267:177:1;59311:154:0;59582:15;;59562:17;59611:14;;;59607:83;;59648:31;;;;;;;;;;;;;;59607:83;59699:14;59727:23;59764:18;59810:9;59805:854;59829:16;59825:1;:20;59805:854;;;59866:22;59891:10;59902:6;59891:10;59909:25;56429:2;59902:6;59909:25;:::i;:::-;59891:44;;;;;;;:::i;:::-;59866:69;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;59866:69:0;;-1:-1:-1;59866:69:0;;-1:-1:-1;59998:33:0;;-1:-1:-1;60015:4:0;;-1:-1:-1;59866:69:0;59998:16;:33::i;:::-;-1:-1:-1;59949:82:0;;-1:-1:-1;59949:82:0;-1:-1:-1;60058:26:0;60049:5;:35;;;;;;;;:::i;:::-;;60045:124;;60144:9;60111:43;;;;;;;;;;;:::i;60045:124::-;60277:10;60264:23;;:9;:23;;;60260:112;;60314:43;;;;;;;;;;;;;;60260:112;60398:9;60385:22;;60529:25;60538:4;60544:9;60529:8;:25::i;:::-;60525:84;;;60574:20;60593:1;60574:20;;:::i;:::-;;;60525:84;60622:26;56429:2;60622:26;;:::i;:::-;;;59852:807;;;59847:3;;;;:::i;:::-;;;59805:854;;;;60690:9;60672:15;:27;60668:128;;;60722:63;;;;;;;;4989:25:1;;;5030:18;;;5023:34;;;4962:18;;60722:63:0;4815:248:1;60668:128:0;59162:1640;;;;;59052:1750;;;;:::o;87106:587::-;87175:28;87205:23;87232:46;87265:12;87232:32;:46::i;:::-;87174:104;;;;87312:13;87292:5;:16;;;:33;87288:115;;87348:44;;;;;87378:13;87348:44;;;413:25:1;386:18;;87348:44:0;267:177:1;87288:115:0;87412:53;;;;;:46;87426:13;87412:46;;;;:53;;87459:5;;87412:53;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;87475:63;87494:5;:16;;;87512:5;:13;;;87527:10;87475:18;:63::i;:::-;87580:16;;87652:23;;;;;;74832:34;87580:16;74819:48;;;74928:4;74921:25;;;;75026:4;75010:21;;87553:133;;;;;;87652:23;;75010:21;87553:133;:::i;:::-;;;;;;;;87164:529;;87106:587;:::o;6099:331::-;6208:6;6184:21;:30;6180:109;;;6237:41;;;;;6272:4;6237:41;;;2165:74:1;2138:18;;6237:41:0;2019:226:1;6180:109:0;6300:12;6318:9;:14;;6340:6;6318:33;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6299:52;;;6366:7;6361:63;;6396:17;;;;;;;;;;;;;;6361:63;6170:260;6099:331;;:::o;44822:165::-;44955:23;;;44902:4;40311:21;;;:14;;;:21;;;;;;:26;;44925:55;40215:129;98625:273;98763:9;;;;;98783:109;;98849:32;;;;;;;;;;;;;;98783:109;98625:273;:::o;57439:227::-;57526:12;57541:29;:13;;;57562:7;57541:20;:29::i;:::-;57526:44;;57585:7;57580:80;;57615:34;;;;;2195:42:1;2183:55;;57615:34:0;;;2165:74:1;2138:18;;57615:34:0;2019:226:1;57023:294:0;57111:21;;;57107:63;;57141:29;;;;;;;;;;;;;;57107:63;57180:10;57193:26;:13;;;57211:7;57193:17;:26::i;:::-;57180:39;;57234:5;57229:82;;57262:38;;;;;2195:42:1;2183:55;;57262:38:0;;;2165:74:1;2138:18;;57262:38:0;2019:226:1;46221:300:0;46284:16;46312:22;46337:19;46345:3;46337:7;:19::i;13937:766::-;14018:7;14027:12;14041:7;14064:9;:16;14084:2;14064:22;14060:637;;14400:4;14385:20;;14379:27;14449:4;14434:20;;14428:27;14506:4;14491:20;;14485:27;14102:9;14477:36;14547:25;14558:4;14477:36;14379:27;14428;14547:10;:25::i;:::-;14540:32;;;;;;;;;;;14060:637;-1:-1:-1;;14668:16:0;;14619:1;;-1:-1:-1;14623:35:0;;14060:637;13937:766;;;;;:::o;52775:246::-;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;52912:23:0;52969:18;52958:56;;;;;;;;;;;;:::i;:::-;52951:63;;;;52775:246;;;:::o;96672:575::-;96833:10;:17;96854:1;96833:22;96829:59;;96672:575;;;:::o;96829:59::-;96936:17;96956:29;;;:17;:29;;;;;;96999:14;;;:37;;;97029:7;97017:9;:19;96999:37;96995:246;;;97052:29;;;;:17;:29;;;;;:39;;;97105:22;:20;:22::i;:::-;:43;;;97149:10;97161;97105:67;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;97191:39;97207:10;97219;97191:39;;;;;;;:::i;:::-;;;;;;;;96780:467;96672:575;;;:::o;44585:156::-;44658:4;44681:53;44689:3;44709:23;;;44681:7;:53::i;44267:150::-;44337:4;44360:50;44365:3;44385:23;;;44360:4;:50::i;41532:109::-;41588:16;41623:3;:11;;41616:18;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;41532:109;;;:::o;16948:1530::-;17074:7;;;18007:66;17994:79;;17990:164;;;-1:-1:-1;18105:1:0;;-1:-1:-1;18109:30:0;;-1:-1:-1;18141:1:0;18089:54;;17990:164;18265:24;;;18248:14;18265:24;;;;;;;;;12645:25:1;;;12718:4;12706:17;;12686:18;;;12679:45;;;;12740:18;;;12733:34;;;12783:18;;;12776:34;;;18265:24:0;;12617:19:1;;18265:24:0;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;18265:24:0;;;;;;-1:-1:-1;;18303:20:0;;;18299:113;;-1:-1:-1;18355:1:0;;-1:-1:-1;18359:29:0;;-1:-1:-1;18355:1:0;;-1:-1:-1;18339:62:0;;18299:113;18430:6;-1:-1:-1;18438:20:0;;-1:-1:-1;18438:20:0;;-1:-1:-1;16948:1530:0;;;;;;;;;:::o;38766:1368::-;38832:4;38961:21;;;:14;;;:21;;;;;;38997:13;;38993:1135;;39364:18;39385:12;39396:1;39385:8;:12;:::i;:::-;39431:18;;39364:33;;-1:-1:-1;39411:17:0;;39431:22;;39452:1;;39431:22;:::i;:::-;39411:42;;39486:9;39472:10;:23;39468:378;;39515:17;39535:3;:11;;39547:9;39535:22;;;;;;;;:::i;:::-;;;;;;;;;39515:42;;39682:9;39656:3;:11;;39668:10;39656:23;;;;;;;;:::i;:::-;;;;;;;;;;;;:35;;;;39795:25;;;:14;;;:25;;;;;:36;;;39468:378;39924:17;;:3;;:17;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;40027:3;:14;;:21;40042:5;40027:21;;;;;;;;;;;40020:28;;;40070:4;40063:11;;;;;;;38993:1135;40112:5;40105:12;;;;;38192:406;38255:4;40311:21;;;:14;;;:21;;;;;;38271:321;;-1:-1:-1;38313:23:0;;;;;;;;:11;:23;;;;;;;;;;;;;38495:18;;38471:21;;;:14;;;:21;;;;;;:42;;;;38527:11;;38271:321;-1:-1:-1;38576:5:0;38569:12;;14:248:1;82:6;90;143:2;131:9;122:7;118:23;114:32;111:52;;;159:1;156;149:12;111:52;-1:-1:-1;;182:23:1;;;252:2;237:18;;;224:32;;-1:-1:-1;14:248:1:o;449:309::-;508:6;561:2;549:9;540:7;536:23;532:32;529:52;;;577:1;574;567:12;529:52;616:9;603:23;666:42;659:5;655:54;648:5;645:65;635:93;;724:1;721;714:12;955:184;1007:77;1004:1;997:88;1104:4;1101:1;1094:15;1128:4;1125:1;1118:15;1144:248;1211:2;1205:9;1253:4;1241:17;;1288:18;1273:34;;1309:22;;;1270:62;1267:88;;;1335:18;;:::i;:::-;1371:2;1364:22;1144:248;:::o;1397:617::-;1497:6;1505;1549:9;1540:7;1536:23;1579:3;1575:2;1571:12;1568:32;;;1596:1;1593;1586:12;1568:32;1632:9;1619:23;1609:33;;1735:4;1666:66;1662:2;1658:75;1654:86;1651:106;;;1753:1;1750;1743:12;1651:106;;1779:17;;:::i;:::-;1847:2;1836:9;1832:18;1819:32;1812:5;1805:47;1912:2;1901:9;1897:18;1884:32;1879:2;1872:5;1868:14;1861:56;1977:4;1966:9;1962:20;1949:34;1944:2;1937:5;1933:14;1926:58;2003:5;1993:15;;;1397:617;;;;;:::o;2250:180::-;2309:6;2362:2;2350:9;2341:7;2337:23;2333:32;2330:52;;;2378:1;2375;2368:12;2330:52;-1:-1:-1;2401:23:1;;2250:180;-1:-1:-1;2250:180:1:o;2435:615::-;2521:6;2529;2582:2;2570:9;2561:7;2557:23;2553:32;2550:52;;;2598:1;2595;2588:12;2550:52;2638:9;2625:23;2667:18;2708:2;2700:6;2697:14;2694:34;;;2724:1;2721;2714:12;2694:34;2762:6;2751:9;2747:22;2737:32;;2807:7;2800:4;2796:2;2792:13;2788:27;2778:55;;2829:1;2826;2819:12;2778:55;2869:2;2856:16;2895:2;2887:6;2884:14;2881:34;;;2911:1;2908;2901:12;2881:34;2964:7;2959:2;2949:6;2946:1;2942:14;2938:2;2934:23;2930:32;2927:45;2924:65;;;2985:1;2982;2975:12;2924:65;3016:2;3008:11;;;;;3038:6;;-1:-1:-1;2435:615:1;;-1:-1:-1;;;;2435:615:1:o;3055:681::-;3226:2;3278:21;;;3348:13;;3251:18;;;3370:22;;;3197:4;;3226:2;3449:15;;;;3423:2;3408:18;;;3197:4;3492:218;3506:6;3503:1;3500:13;3492:218;;;3571:13;;3586:42;3567:62;3555:75;;3685:15;;;;3650:12;;;;3528:1;3521:9;3492:218;;;-1:-1:-1;3727:3:1;;3055:681;-1:-1:-1;;;;;;3055:681:1:o;3741:347::-;3792:8;3802:6;3856:3;3849:4;3841:6;3837:17;3833:27;3823:55;;3874:1;3871;3864:12;3823:55;-1:-1:-1;3897:20:1;;3940:18;3929:30;;3926:50;;;3972:1;3969;3962:12;3926:50;4009:4;4001:6;3997:17;3985:29;;4061:3;4054:4;4045:6;4037;4033:19;4029:30;4026:39;4023:59;;;4078:1;4075;4068:12;4023:59;3741:347;;;;;:::o;4093:717::-;4183:6;4191;4199;4207;4260:2;4248:9;4239:7;4235:23;4231:32;4228:52;;;4276:1;4273;4266:12;4228:52;4316:9;4303:23;4345:18;4386:2;4378:6;4375:14;4372:34;;;4402:1;4399;4392:12;4372:34;4441:58;4491:7;4482:6;4471:9;4467:22;4441:58;:::i;:::-;4518:8;;-1:-1:-1;4415:84:1;-1:-1:-1;4606:2:1;4591:18;;4578:32;;-1:-1:-1;4622:16:1;;;4619:36;;;4651:1;4648;4641:12;4619:36;;4690:60;4742:7;4731:8;4720:9;4716:24;4690:60;:::i;:::-;4093:717;;;;-1:-1:-1;4769:8:1;-1:-1:-1;;;;4093:717:1:o;5068:184::-;5120:77;5117:1;5110:88;5217:4;5214:1;5207:15;5241:4;5238:1;5231:15;5257:168;5330:9;;;5361;;5378:15;;;5372:22;;5358:37;5348:71;;5399:18;;:::i;5430:274::-;5470:1;5496;5486:189;;5531:77;5528:1;5521:88;5632:4;5629:1;5622:15;5660:4;5657:1;5650:15;5486:189;-1:-1:-1;5689:9:1;;5430:274::o;5709:250::-;5794:1;5804:113;5818:6;5815:1;5812:13;5804:113;;;5894:11;;;5888:18;5875:11;;;5868:39;5840:2;5833:10;5804:113;;;-1:-1:-1;;5951:1:1;5933:16;;5926:27;5709:250::o;5964:329::-;6005:3;6043:5;6037:12;6070:6;6065:3;6058:19;6086:76;6155:6;6148:4;6143:3;6139:14;6132:4;6125:5;6121:16;6086:76;:::i;:::-;6207:2;6195:15;6212:66;6191:88;6182:98;;;;6282:4;6178:109;;5964:329;-1:-1:-1;;5964:329:1:o;6298:288::-;6473:2;6462:9;6455:21;6436:4;6493:44;6533:2;6522:9;6518:18;6510:6;6493:44;:::i;:::-;6485:52;;6573:6;6568:2;6557:9;6553:18;6546:34;6298:288;;;;;:::o;6591:184::-;6643:77;6640:1;6633:88;6740:4;6737:1;6730:15;6764:4;6761:1;6754:15;6780:195;6819:3;6850:66;6843:5;6840:77;6837:103;;6920:18;;:::i;:::-;-1:-1:-1;6967:1:1;6956:13;;6780:195::o;6980:271::-;7163:6;7155;7150:3;7137:33;7119:3;7189:16;;7214:13;;;7189:16;6980:271;-1:-1:-1;6980:271:1:o;7256:128::-;7323:9;;;7344:11;;;7341:37;;;7358:18;;:::i;7864:125::-;7929:9;;;7950:10;;;7947:36;;;7963:18;;:::i;8318:184::-;8388:6;8441:2;8429:9;8420:7;8416:23;8412:32;8409:52;;;8457:1;8454;8447:12;8409:52;-1:-1:-1;8480:16:1;;8318:184;-1:-1:-1;8318:184:1:o;8507:757::-;8560:5;8613:3;8606:4;8598:6;8594:17;8590:27;8580:55;;8631:1;8628;8621:12;8580:55;8660:6;8654:13;8686:18;8723:2;8719;8716:10;8713:36;;;8729:18;;:::i;:::-;8863:2;8857:9;8925:4;8917:13;;8768:66;8913:22;;;8937:2;8909:31;8905:40;8893:53;;;8961:18;;;8981:22;;;8958:46;8955:72;;;9007:18;;:::i;:::-;9047:10;9043:2;9036:22;9082:2;9074:6;9067:18;9128:3;9121:4;9116:2;9108:6;9104:15;9100:26;9097:35;9094:55;;;9145:1;9142;9135:12;9094:55;9158:76;9231:2;9224:4;9216:6;9212:17;9205:4;9197:6;9193:17;9158:76;:::i;:::-;9252:6;8507:757;-1:-1:-1;;;;;;8507:757:1:o;9269:335::-;9348:6;9401:2;9389:9;9380:7;9376:23;9372:32;9369:52;;;9417:1;9414;9407:12;9369:52;9450:9;9444:16;9483:18;9475:6;9472:30;9469:50;;;9515:1;9512;9505:12;9469:50;9538:60;9590:7;9581:6;9570:9;9566:22;9538:60;:::i;:::-;9528:70;9269:335;-1:-1:-1;;;;9269:335:1:o;9609:288::-;9784:6;9773:9;9766:25;9827:2;9822;9811:9;9807:18;9800:30;9747:4;9847:44;9887:2;9876:9;9872:18;9864:6;9847:44;:::i;10119:381::-;9983:12;;9971:25;;10045:4;10034:16;;;10028:23;10012:14;;;10005:47;10101:4;10090:16;;;10084:23;10068:14;;;10061:47;10428:3;10423:2;10412:9;10408:18;10401:31;10321:4;10449:45;10489:3;10478:9;10474:19;10466:6;10449:45;:::i;10505:331::-;10610:9;10621;10663:8;10651:10;10648:24;10645:44;;;10685:1;10682;10675:12;10645:44;10714:6;10704:8;10701:20;10698:40;;;10734:1;10731;10724:12;10698:40;-1:-1:-1;;10760:23:1;;;10805:25;;;;;-1:-1:-1;10505:331:1:o;10841:184::-;10893:77;10890:1;10883:88;10990:4;10987:1;10980:15;11014:4;11011:1;11004:15;11030:217;11177:2;11166:9;11159:21;11140:4;11197:44;11237:2;11226:9;11222:18;11214:6;11197:44;:::i;11252:268::-;9983:12;;9971:25;;10045:4;10034:16;;;10028:23;10012:14;;;10005:47;10101:4;10090:16;;;10084:23;10068:14;;;10061:47;11450:2;11435:18;;11462:52;9902:212;11735:678;11855:6;11863;11907:9;11898:7;11894:23;11937:3;11933:2;11929:12;11926:32;;;11954:1;11951;11944:12;11926:32;11978:4;11974:2;11970:13;11967:33;;;11996:1;11993;11986:12;11967:33;;12022:17;;:::i;:::-;12068:9;12062:16;12055:5;12048:31;12132:2;12121:9;12117:18;12111:25;12106:2;12099:5;12095:14;12088:49;12190:2;12179:9;12175:18;12169:25;12164:2;12157:5;12153:14;12146:49;12214:5;12204:15;;;12263:4;12252:9;12248:20;12242:27;12292:18;12284:6;12281:30;12278:50;;;12324:1;12321;12314:12;12278:50;12347:60;12399:7;12390:6;12379:9;12375:22;12347:60;:::i;:::-;12337:70;;;11735:678;;;;;:::o;12821:184::-;12873:77;12870:1;12863:88;12970:4;12967:1;12960:15;12994:4;12991:1;12984:15","abiDefinition":[{"inputs":[{"internalType":"address","name":"interchainDB","type":"address"},{"internalType":"address","name":"owner_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"AddressInsufficientBalance","type":"error"},{"inputs":[],"name":"FailedInnerCall","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__IncorrectSourceChainId","type":"error"},{"inputs":[{"internalType":"uint256","name":"actual","type":"uint256"},{"internalType":"uint256","name":"required","type":"uint256"}],"name":"InterchainModule__InsufficientFee","type":"error"},{"inputs":[{"internalType":"address","name":"caller","type":"address"}],"name":"InterchainModule__NotInterchainDB","type":"error"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"InterchainModule__SameChainId","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"uint256","name":"claimFeeFraction","type":"uint256"}],"name":"SynapseModule__ClaimFeeFractionExceedsMax","type":"error"},{"inputs":[],"name":"SynapseModule__FeeCollectorNotSet","type":"error"},{"inputs":[{"internalType":"address","name":"gasOracle","type":"address"}],"name":"SynapseModule__GasOracleNotContract","type":"error"},{"inputs":[],"name":"SynapseModule__GasOracleNotSet","type":"error"},{"inputs":[],"name":"SynapseModule__NoFeesToClaim","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"ThresholdECDSA__AlreadySigner","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ThresholdECDSA__IncorrectSignaturesLength","type":"error"},{"inputs":[{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"ThresholdECDSA__InvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"provided","type":"uint256"},{"internalType":"uint256","name":"threshold","type":"uint256"}],"name":"ThresholdECDSA__NotEnoughSignatures","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"ThresholdECDSA__NotSigner","type":"error"},{"inputs":[],"name":"ThresholdECDSA__RecoveredSignersNotSorted","type":"error"},{"inputs":[],"name":"ThresholdECDSA__ZeroAddress","type":"error"},{"inputs":[],"name":"ThresholdECDSA__ZeroThreshold","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"batch","type":"bytes"},{"indexed":false,"internalType":"bytes32","name":"ethSignedBatchHash","type":"bytes32"}],"name":"BatchVerificationRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"batch","type":"bytes"},{"indexed":false,"internalType":"bytes32","name":"ethSignedBatchHash","type":"bytes32"}],"name":"BatchVerified","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"claimFeeFraction","type":"uint256"}],"name":"ClaimFeeFractionChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"feeCollector","type":"address"}],"name":"FeeCollectorChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"feeCollector","type":"address"},{"indexed":false,"internalType":"uint256","name":"collectedFees","type":"uint256"},{"indexed":false,"internalType":"address","name":"claimer","type":"address"},{"indexed":false,"internalType":"uint256","name":"claimerFee","type":"uint256"}],"name":"FeesClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"data","type":"bytes"}],"name":"GasDataReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"data","type":"bytes"}],"name":"GasDataSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"gasOracle","type":"address"}],"name":"GasOracleChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"threshold","type":"uint256"}],"name":"ThresholdChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"verifier","type":"address"}],"name":"VerifierAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"verifier","type":"address"}],"name":"VerifierRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"gasLimit","type":"uint256"}],"name":"VerifyGasLimitChanged","type":"event"},{"inputs":[],"name":"DEFAULT_VERIFY_GAS_LIMIT","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"INTERCHAIN_DB","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"verifier","type":"address"}],"name":"addVerifier","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"verifiers","type":"address[]"}],"name":"addVerifiers","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"claimFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"feeCollector","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"gasOracle","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getClaimFeeAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getClaimFeeFraction","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"}],"name":"getModuleFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getThreshold","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getVerifiers","outputs":[{"internalType":"address[]","name":"","type":"address[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"}],"name":"getVerifyGasLimit","outputs":[{"internalType":"uint256","name":"gasLimit","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"isVerifier","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"verifier","type":"address"}],"name":"removeVerifier","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address[]","name":"verifiers","type":"address[]"}],"name":"removeVerifiers","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"dstChainId","type":"uint256"},{"components":[{"internalType":"uint256","name":"srcChainId","type":"uint256"},{"internalType":"uint256","name":"dbNonce","type":"uint256"},{"internalType":"bytes32","name":"batchRoot","type":"bytes32"}],"internalType":"struct InterchainBatch","name":"batch","type":"tuple"}],"name":"requestBatchVerification","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"uint256","name":"claimFeeFraction","type":"uint256"}],"name":"setClaimFeeFraction","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"feeCollector_","type":"address"}],"name":"setFeeCollector","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"gasOracle_","type":"address"}],"name":"setGasOracle","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"threshold","type":"uint256"}],"name":"setThreshold","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"uint256","name":"gasLimit","type":"uint256"}],"name":"setVerifyGasLimit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedBatch","type":"bytes"},{"internalType":"bytes","name":"signatures","type":"bytes"}],"name":"verifyRemoteBatch","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"addVerifier(address)":{"notice":"Adds a new verifier to the module."},"addVerifiers(address[])":{"notice":"Adds a list of new verifiers to the module."},"claimFees()":{"notice":"Transfers the accumulated fees to the fee collector. Message caller receives a percentage of the fees, this ensures that the module is self-sustainable. The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees will be transferred to the fee collector."},"feeCollector()":{"notice":"Returns the address of the fee collector for the module."},"gasOracle()":{"notice":"Returns the address of the gas oracle used for estimating the verification fees."},"getClaimFeeAmount()":{"notice":"Returns the current claim fee to be paid to the caller of `claimFees`."},"getClaimFeeFraction()":{"notice":"Returns the fraction of the fees to be paid to the caller of `claimFees`. The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees."},"getModuleFee(uint256,uint256)":{"notice":"Get the Module fee for verifying a batch on the specified destination chain."},"getThreshold()":{"notice":"Gets the threshold of the module. This is the minimum number of signatures required for verification."},"getVerifiers()":{"notice":"Returns the list of verifiers for the module."},"getVerifyGasLimit(uint256)":{"notice":"Returns the estimated gas limit for verifying a batch on the given chain. Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set."},"isVerifier(address)":{"notice":"Checks if the given account is a verifier for the module."},"removeVerifier(address)":{"notice":"Removes a verifier from the module."},"removeVerifiers(address[])":{"notice":"Removes a list of verifiers from the module."},"requestBatchVerification(uint256,(uint256,uint256,bytes32))":{"notice":"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering."},"setClaimFeeFraction(uint256)":{"notice":"Sets the fraction of the accumulated fees to be paid to caller of `claimFees`. This encourages rational actors to call the function as soon as claim fee is higher than the gas cost."},"setFeeCollector(address)":{"notice":"Sets the address of the fee collector, which will have the verification fees forwarded to it."},"setGasOracle(address)":{"notice":"Sets the address of the gas oracle to be used for estimating the verification fees."},"setThreshold(uint256)":{"notice":"Sets the threshold of the module."},"setVerifyGasLimit(uint256,uint256)":{"notice":"Sets the estimated gas limit for verifying a batch on the given chain."},"verifyRemoteBatch(bytes,bytes)":{"notice":"Verifies a batch from the remote chain using a set of verifier signatures. If the threshold is met, the batch will be marked as verified in the Interchain DataBase."}},"version":1},"developerDoc":{"errors":{"AddressInsufficientBalance(address)":[{"details":"The ETH balance of the account is not enough to perform the operation."}],"FailedInnerCall()":[{"details":"A call to an address target failed. The target may have reverted."}],"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"addVerifier(address)":{"details":"Could be only called by the owner. Will revert if the verifier is already added.","params":{"verifier":"The address of the verifier to add"}},"addVerifiers(address[])":{"details":"Could be only called by the owner. Will revert if any of the verifiers is already added.","params":{"verifiers":"The list of addresses of the verifiers to add"}},"claimFees()":{"details":"Will revert if the fee collector is not set."},"getModuleFee(uint256,uint256)":{"params":{"dbNonce":"The database nonce of the batch on the source chain","dstChainId":"The chain id of the destination chain"}},"owner()":{"details":"Returns the address of the current owner."},"removeVerifier(address)":{"details":"Could be only called by the owner. Will revert if the verifier is not added.","params":{"verifier":"The address of the verifier to remove"}},"removeVerifiers(address[])":{"details":"Could be only called by the owner. Will revert if any of the verifiers is not added.","params":{"verifiers":"The list of addresses of the verifiers to remove"}},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"requestBatchVerification(uint256,(uint256,uint256,bytes32))":{"details":"Could be only called by the Interchain DataBase contract.","params":{"batch":"The batch to verify","dstChainId":"The chain id of the destination chain"}},"setClaimFeeFraction(uint256)":{"details":"Could be only called by the owner. Could not exceed 1%.","params":{"claimFeeFraction":"The fraction of the fees to be paid to the claimer (100% = 1e18)"}},"setFeeCollector(address)":{"details":"Could be only called by the owner.","params":{"feeCollector_":"The address of the fee collector"}},"setGasOracle(address)":{"details":"Could be only called by the owner. Will revert if the gas oracle is not a contract.","params":{"gasOracle_":"The address of the gas oracle contract"}},"setThreshold(uint256)":{"details":"Could be only called by the owner. Will revert if the threshold is zero.","params":{"threshold":"The new threshold value"}},"setVerifyGasLimit(uint256,uint256)":{"details":"Could be only called by the owner.","params":{"chainId":"The chain ID for which to set the gas limit","gasLimit":"The new gas limit"}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"verifyRemoteBatch(bytes,bytes)":{"details":"List of recovered signers from the signatures must be sorted in the ascending order.","params":{"encodedBatch":"The encoded batch to verify","signatures":"Signatures used to verify the batch, concatenated"}}},"stateVariables":{"_claimFeeFraction":{"details":"Claim fee fraction, 100% = 1e18"},"_lastGasDataHash":{"details":"Hash of the last gas data sent to the remote chain."},"_lastGasDataNonce":{"details":"Nonce of the last gas data received from the remote chain."},"_verifiers":{"details":"Struct to hold the verifiers and the threshold for the module."},"_verifyGasLimit":{"details":"Gas limit for the verifyBatch function on the remote chain."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"interchainDB\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"owner_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AddressInsufficientBalance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"FailedInnerCall\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__IncorrectSourceChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"actual\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__InsufficientFee\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"}],\"name\":\"InterchainModule__NotInterchainDB\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"InterchainModule__SameChainId\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimFeeFraction\",\"type\":\"uint256\"}],\"name\":\"SynapseModule__ClaimFeeFractionExceedsMax\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SynapseModule__FeeCollectorNotSet\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gasOracle\",\"type\":\"address\"}],\"name\":\"SynapseModule__GasOracleNotContract\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SynapseModule__GasOracleNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"SynapseModule__NoFeesToClaim\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ThresholdECDSA__AlreadySigner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ThresholdECDSA__IncorrectSignaturesLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"ThresholdECDSA__InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"ThresholdECDSA__NotEnoughSignatures\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ThresholdECDSA__NotSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ThresholdECDSA__RecoveredSignersNotSorted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ThresholdECDSA__ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ThresholdECDSA__ZeroThreshold\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"batch\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ethSignedBatchHash\",\"type\":\"bytes32\"}],\"name\":\"BatchVerificationRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"batch\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"ethSignedBatchHash\",\"type\":\"bytes32\"}],\"name\":\"BatchVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimFeeFraction\",\"type\":\"uint256\"}],\"name\":\"ClaimFeeFractionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"FeeCollectorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectedFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimerFee\",\"type\":\"uint256\"}],\"name\":\"FeesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"GasDataReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"GasDataSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gasOracle\",\"type\":\"address\"}],\"name\":\"GasOracleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"ThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"VerifierAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"VerifierRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"VerifyGasLimitChanged\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_VERIFY_GAS_LIMIT\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"INTERCHAIN_DB\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"addVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"verifiers\",\"type\":\"address[]\"}],\"name\":\"addVerifiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claimFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"feeCollector\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gasOracle\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getClaimFeeFraction\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"}],\"name\":\"getModuleFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getThreshold\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getVerifiers\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"}],\"name\":\"getVerifyGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isVerifier\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"removeVerifier\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"verifiers\",\"type\":\"address[]\"}],\"name\":\"removeVerifiers\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"dbNonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"batchRoot\",\"type\":\"bytes32\"}],\"internalType\":\"struct InterchainBatch\",\"name\":\"batch\",\"type\":\"tuple\"}],\"name\":\"requestBatchVerification\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimFeeFraction\",\"type\":\"uint256\"}],\"name\":\"setClaimFeeFraction\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeCollector_\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"gasOracle_\",\"type\":\"address\"}],\"name\":\"setGasOracle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"setThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"setVerifyGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedBatch\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"verifyRemoteBatch\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AddressInsufficientBalance(address)\":[{\"details\":\"The ETH balance of the account is not enough to perform the operation.\"}],\"FailedInnerCall()\":[{\"details\":\"A call to an address target failed. The target may have reverted.\"}],\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"addVerifier(address)\":{\"details\":\"Could be only called by the owner. Will revert if the verifier is already added.\",\"params\":{\"verifier\":\"The address of the verifier to add\"}},\"addVerifiers(address[])\":{\"details\":\"Could be only called by the owner. Will revert if any of the verifiers is already added.\",\"params\":{\"verifiers\":\"The list of addresses of the verifiers to add\"}},\"claimFees()\":{\"details\":\"Will revert if the fee collector is not set.\"},\"getModuleFee(uint256,uint256)\":{\"params\":{\"dbNonce\":\"The database nonce of the batch on the source chain\",\"dstChainId\":\"The chain id of the destination chain\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"removeVerifier(address)\":{\"details\":\"Could be only called by the owner. Will revert if the verifier is not added.\",\"params\":{\"verifier\":\"The address of the verifier to remove\"}},\"removeVerifiers(address[])\":{\"details\":\"Could be only called by the owner. Will revert if any of the verifiers is not added.\",\"params\":{\"verifiers\":\"The list of addresses of the verifiers to remove\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"requestBatchVerification(uint256,(uint256,uint256,bytes32))\":{\"details\":\"Could be only called by the Interchain DataBase contract.\",\"params\":{\"batch\":\"The batch to verify\",\"dstChainId\":\"The chain id of the destination chain\"}},\"setClaimFeeFraction(uint256)\":{\"details\":\"Could be only called by the owner. Could not exceed 1%.\",\"params\":{\"claimFeeFraction\":\"The fraction of the fees to be paid to the claimer (100% = 1e18)\"}},\"setFeeCollector(address)\":{\"details\":\"Could be only called by the owner.\",\"params\":{\"feeCollector_\":\"The address of the fee collector\"}},\"setGasOracle(address)\":{\"details\":\"Could be only called by the owner. Will revert if the gas oracle is not a contract.\",\"params\":{\"gasOracle_\":\"The address of the gas oracle contract\"}},\"setThreshold(uint256)\":{\"details\":\"Could be only called by the owner. Will revert if the threshold is zero.\",\"params\":{\"threshold\":\"The new threshold value\"}},\"setVerifyGasLimit(uint256,uint256)\":{\"details\":\"Could be only called by the owner.\",\"params\":{\"chainId\":\"The chain ID for which to set the gas limit\",\"gasLimit\":\"The new gas limit\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"},\"verifyRemoteBatch(bytes,bytes)\":{\"details\":\"List of recovered signers from the signatures must be sorted in the ascending order.\",\"params\":{\"encodedBatch\":\"The encoded batch to verify\",\"signatures\":\"Signatures used to verify the batch, concatenated\"}}},\"stateVariables\":{\"_claimFeeFraction\":{\"details\":\"Claim fee fraction, 100% = 1e18\"},\"_lastGasDataHash\":{\"details\":\"Hash of the last gas data sent to the remote chain.\"},\"_lastGasDataNonce\":{\"details\":\"Nonce of the last gas data received from the remote chain.\"},\"_verifiers\":{\"details\":\"Struct to hold the verifiers and the threshold for the module.\"},\"_verifyGasLimit\":{\"details\":\"Gas limit for the verifyBatch function on the remote chain.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"addVerifier(address)\":{\"notice\":\"Adds a new verifier to the module.\"},\"addVerifiers(address[])\":{\"notice\":\"Adds a list of new verifiers to the module.\"},\"claimFees()\":{\"notice\":\"Transfers the accumulated fees to the fee collector. Message caller receives a percentage of the fees, this ensures that the module is self-sustainable. The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees will be transferred to the fee collector.\"},\"feeCollector()\":{\"notice\":\"Returns the address of the fee collector for the module.\"},\"gasOracle()\":{\"notice\":\"Returns the address of the gas oracle used for estimating the verification fees.\"},\"getClaimFeeAmount()\":{\"notice\":\"Returns the current claim fee to be paid to the caller of `claimFees`.\"},\"getClaimFeeFraction()\":{\"notice\":\"Returns the fraction of the fees to be paid to the caller of `claimFees`. The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\"},\"getModuleFee(uint256,uint256)\":{\"notice\":\"Get the Module fee for verifying a batch on the specified destination chain.\"},\"getThreshold()\":{\"notice\":\"Gets the threshold of the module. This is the minimum number of signatures required for verification.\"},\"getVerifiers()\":{\"notice\":\"Returns the list of verifiers for the module.\"},\"getVerifyGasLimit(uint256)\":{\"notice\":\"Returns the estimated gas limit for verifying a batch on the given chain. Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\"},\"isVerifier(address)\":{\"notice\":\"Checks if the given account is a verifier for the module.\"},\"removeVerifier(address)\":{\"notice\":\"Removes a verifier from the module.\"},\"removeVerifiers(address[])\":{\"notice\":\"Removes a list of verifiers from the module.\"},\"requestBatchVerification(uint256,(uint256,uint256,bytes32))\":{\"notice\":\"Request the verification of a batch from the Interchain DataBase by the module. If the batch is not yet finalized, the verification on destination chain will be delayed until the finalization is done and batch root is saved on the source chain. Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`. Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain, with no guarantee of ordering.\"},\"setClaimFeeFraction(uint256)\":{\"notice\":\"Sets the fraction of the accumulated fees to be paid to caller of `claimFees`. This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\"},\"setFeeCollector(address)\":{\"notice\":\"Sets the address of the fee collector, which will have the verification fees forwarded to it.\"},\"setGasOracle(address)\":{\"notice\":\"Sets the address of the gas oracle to be used for estimating the verification fees.\"},\"setThreshold(uint256)\":{\"notice\":\"Sets the threshold of the module.\"},\"setVerifyGasLimit(uint256,uint256)\":{\"notice\":\"Sets the estimated gas limit for verifying a batch on the given chain.\"},\"verifyRemoteBatch(bytes,bytes)\":{\"notice\":\"Verifies a batch from the remote chain using a set of verifier signatures. If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"SynapseModule\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{"DEFAULT_VERIFY_GAS_LIMIT()":"e232d191","INTERCHAIN_DB()":"e4c61247","addVerifier(address)":"9000b3d6","addVerifiers(address[])":"b5344257","claimFees()":"d294f093","feeCollector()":"c415b95c","gasOracle()":"5d62a8dd","getClaimFeeAmount()":"20c8eed2","getClaimFeeFraction()":"6adb16b5","getModuleFee(uint256,uint256)":"4a114f72","getThreshold()":"e75235b8","getVerifiers()":"a935e766","getVerifyGasLimit(uint256)":"66d02393","isVerifier(address)":"33105218","owner()":"8da5cb5b","removeVerifier(address)":"ca2dfd0a","removeVerifiers(address[])":"86ae47f0","renounceOwnership()":"715018a6","requestBatchVerification(uint256,(uint256,uint256,bytes32))":"3fdcec74","setClaimFeeFraction(uint256)":"9a96f35b","setFeeCollector(address)":"a42dce80","setGasOracle(address)":"a87b8152","setThreshold(uint256)":"960bfe04","setVerifyGasLimit(uint256,uint256)":"178977c9","transferOwnership(address)":"f2fde38b","verifyRemoteBatch(bytes,bytes)":"b80cb14b"}},"solidity/SynapseModule.sol:SynapseModuleEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"claimFeeFraction","type":"uint256"}],"name":"ClaimFeeFractionChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"feeCollector","type":"address"}],"name":"FeeCollectorChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"feeCollector","type":"address"},{"indexed":false,"internalType":"uint256","name":"collectedFees","type":"uint256"},{"indexed":false,"internalType":"address","name":"claimer","type":"address"},{"indexed":false,"internalType":"uint256","name":"claimerFee","type":"uint256"}],"name":"FeesClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"data","type":"bytes"}],"name":"GasDataReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"dstChainId","type":"uint256"},{"indexed":false,"internalType":"bytes","name":"data","type":"bytes"}],"name":"GasDataSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"gasOracle","type":"address"}],"name":"GasOracleChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"threshold","type":"uint256"}],"name":"ThresholdChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"verifier","type":"address"}],"name":"VerifierAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"verifier","type":"address"}],"name":"VerifierRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"gasLimit","type":"uint256"}],"name":"VerifyGasLimitChanged","type":"event"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimFeeFraction\",\"type\":\"uint256\"}],\"name\":\"ClaimFeeFractionChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"FeeCollectorChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collectedFees\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"claimerFee\",\"type\":\"uint256\"}],\"name\":\"FeesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"GasDataReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"dstChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"GasDataSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"gasOracle\",\"type\":\"address\"}],\"name\":\"GasOracleChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"ThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"VerifierAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"verifier\",\"type\":\"address\"}],\"name\":\"VerifierRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"gasLimit\",\"type\":\"uint256\"}],\"name\":\"VerifyGasLimitChanged\",\"type\":\"event\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"SynapseModuleEvents\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:ThresholdECDSALib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206beccf04fe7546484cdf14aab895ad5d26e5249521de074930dc7d3739b7263864736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212206beccf04fe7546484cdf14aab895ad5d26e5249521de074930dc7d3739b7263864736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"56298:4506:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;56298:4506:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"56298:4506:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"ThresholdECDSA__AlreadySigner","type":"error"},{"inputs":[{"internalType":"uint256","name":"length","type":"uint256"}],"name":"ThresholdECDSA__IncorrectSignaturesLength","type":"error"},{"inputs":[{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"ThresholdECDSA__InvalidSignature","type":"error"},{"inputs":[{"internalType":"uint256","name":"provided","type":"uint256"},{"internalType":"uint256","name":"threshold","type":"uint256"}],"name":"ThresholdECDSA__NotEnoughSignatures","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"ThresholdECDSA__NotSigner","type":"error"},{"inputs":[],"name":"ThresholdECDSA__RecoveredSignersNotSorted","type":"error"},{"inputs":[],"name":"ThresholdECDSA__ZeroAddress","type":"error"},{"inputs":[],"name":"ThresholdECDSA__ZeroThreshold","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ThresholdECDSA__AlreadySigner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"ThresholdECDSA__IncorrectSignaturesLength\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"ThresholdECDSA__InvalidSignature\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"provided\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"threshold\",\"type\":\"uint256\"}],\"name\":\"ThresholdECDSA__NotEnoughSignatures\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ThresholdECDSA__NotSigner\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ThresholdECDSA__RecoveredSignersNotSorted\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ThresholdECDSA__ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ThresholdECDSA__ZeroThreshold\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"ThresholdECDSALib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseModule.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f0216f873f7cd9146a27f15f767abcac4a4259020a687f16408c732ff2d0a15864736f6c63430008140033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f0216f873f7cd9146a27f15f767abcac4a4259020a687f16408c732ff2d0a15864736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.20 ^0.8.0 ^0.8.13 ^0.8.20;\n\n// contracts/events/InterchainModuleEvents.sol\n\nabstract contract InterchainModuleEvents {\n    event BatchVerificationRequested(uint256 indexed dstChainId, bytes batch, bytes32 ethSignedBatchHash);\n\n    event BatchVerified(uint256 indexed srcChainId, bytes batch, bytes32 ethSignedBatchHash);\n}\n\n// contracts/events/SynapseModuleEvents.sol\n\nabstract contract SynapseModuleEvents {\n    event VerifierAdded(address verifier);\n    event VerifierRemoved(address verifier);\n    event ThresholdChanged(uint256 threshold);\n\n    event FeeCollectorChanged(address feeCollector);\n    event GasOracleChanged(address gasOracle);\n    event VerifyGasLimitChanged(uint256 chainId, uint256 gasLimit);\n\n    event ClaimFeeFractionChanged(uint256 claimFeeFraction);\n    event FeesClaimed(address feeCollector, uint256 collectedFees, address claimer, uint256 claimerFee);\n\n    event GasDataSent(uint256 dstChainId, bytes data);\n    event GasDataReceived(uint256 srcChainId, bytes data);\n}\n\n// contracts/interfaces/IGasOracle.sol\n\ninterface IGasOracle {\n    /// @notice Convert a value from the native token of a remote chain to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param value                The value to convert.\n    function convertRemoteValueToLocalUnits(uint256 remoteChainId, uint256 value) external view returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and convert it to the local native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInLocalUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n\n    /// @notice Estimate the cost of execution a transaction on a remote chain,\n    /// and return it as is in the remote chain's native token.\n    /// @dev Will revert if no price is available for the remote chain.\n    /// @param remoteChainId        The chain id of the remote chain.\n    /// @param gasLimit             The gas limit of the transaction.\n    /// @param calldataSize         The size of the transaction calldata.\n    function estimateTxCostInRemoteUnits(\n        uint256 remoteChainId,\n        uint256 gasLimit,\n        uint256 calldataSize\n    )\n        external\n        view\n        returns (uint256);\n}\n\n// contracts/libs/InterchainBatch.sol\n\n/// @notice Struct representing a batch of entries in the Interchain DataBase.\n/// Batched entries are put together in a Merkle tree, which root is saved.\n/// Batch has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce\n/// - value: batchRoot\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch\n/// @param batchRoot    The root of the Merkle tree containing the batched entries\nstruct InterchainBatch {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    bytes32 batchRoot;\n}\n\nlibrary InterchainBatchLib {\n    /// @notice Constructs an InterchainBatch struct to be saved on the local chain.\n    /// @param dbNonce      The database nonce of the batch\n    /// @param batchRoot    The root of the Merkle tree containing the batched entries\n    /// @return batch       The constructed InterchainBatch struct\n    function constructLocalBatch(\n        uint256 dbNonce,\n        bytes32 batchRoot\n    )\n        internal\n        view\n        returns (InterchainBatch memory batch)\n    {\n        return InterchainBatch({srcChainId: block.chainid, dbNonce: dbNonce, batchRoot: batchRoot});\n    }\n\n    /// @notice Returns the globally unique identifier of the batch\n    function batchKey(InterchainBatch memory batch) internal pure returns (bytes32) {\n        return keccak256(abi.encode(batch.srcChainId, batch.dbNonce));\n    }\n}\n\n// contracts/libs/TypeCasts.sol\n\nlibrary TypeCasts {\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    function bytes32ToAddress(bytes32 b) internal pure returns (address) {\n        return address(uint160(uint256(b)));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Address.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance \u003c amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance \u003c value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 \u0026\u0026 target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length \u003e 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Context.sol\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/ECDSA.sol)\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS\n    }\n\n    /**\n     * @dev The signature derives the `address(0)`.\n     */\n    error ECDSAInvalidSignature();\n\n    /**\n     * @dev The signature has an invalid length.\n     */\n    error ECDSAInvalidSignatureLength(uint256 length);\n\n    /**\n     * @dev The signature has an S value that is in the upper half order.\n     */\n    error ECDSAInvalidSignatureS(bytes32 s);\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with `signature` or an error. This will not\n     * return address(0) without also returning an error description. Errors are documented using an enum (error type)\n     * and a bytes32 providing additional information about the error.\n     *\n     * If no error is returned, then the address can be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM precompile allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {MessageHashUtils-toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {\n        unchecked {\n            bytes32 s = vs \u0026 bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n            // We do not check for an overflow here since the shift operation results in 0 or 1.\n            uint8 v = uint8((uint256(vs) \u003e\u003e 255) + 27);\n            return tryRecover(hash, v, r, s);\n        }\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError, bytes32) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS, s);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature, bytes32(0));\n        }\n\n        return (signer, RecoverError.NoError, bytes32(0));\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);\n        _throwError(error, errorArg);\n        return recovered;\n    }\n\n    /**\n     * @dev Optionally reverts with the corresponding custom error according to the `error` argument provided.\n     */\n    function _throwError(RecoverError error, bytes32 errorArg) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert ECDSAInvalidSignature();\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert ECDSAInvalidSignatureLength(uint256(errorArg));\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert ECDSAInvalidSignatureS(errorArg);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/Math.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c \u003c a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b \u003e a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a \u0026 b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator \u003c= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always \u003e= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator \u0026 (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) \u0026\u0026 mulmod(x, y, denominator) \u003e 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) \u003c= a \u003c 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) \u003c= a \u003c 2**(log2(a) + 1)`\n        // → `sqrt(2**k) \u003c= sqrt(a) \u003c sqrt(2**(k+1))`\n        // → `2**(k/2) \u003c= sqrt(a) \u003c 2**((k+1)/2) \u003c= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 \u003c\u003c (log2(a) \u003e\u003e 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            result = (result + a / result) \u003e\u003e 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 result * result \u003c a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 128;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 64;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 32;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 16;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                value \u003e\u003e= 8;\n                result += 8;\n            }\n            if (value \u003e\u003e 4 \u003e 0) {\n                value \u003e\u003e= 4;\n                result += 4;\n            }\n            if (value \u003e\u003e 2 \u003e 0) {\n                value \u003e\u003e= 2;\n                result += 2;\n            }\n            if (value \u003e\u003e 1 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value \u003e= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value \u003e= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value \u003e= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value \u003e= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value \u003e= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value \u003e= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 10 ** result \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value \u003e\u003e 128 \u003e 0) {\n                value \u003e\u003e= 128;\n                result += 16;\n            }\n            if (value \u003e\u003e 64 \u003e 0) {\n                value \u003e\u003e= 64;\n                result += 8;\n            }\n            if (value \u003e\u003e 32 \u003e 0) {\n                value \u003e\u003e= 32;\n                result += 4;\n            }\n            if (value \u003e\u003e 16 \u003e 0) {\n                value \u003e\u003e= 16;\n                result += 2;\n            }\n            if (value \u003e\u003e 8 \u003e 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) \u0026\u0026 1 \u003c\u003c (result \u003c\u003c 3) \u003c value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003e b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a \u003c b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a \u0026 b) + ((a ^ b) \u003e\u003e 1);\n        return x + (int256(uint256(x) \u003e\u003e 255) \u0026 (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n \u003e= 0 ? n : -n);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/structs/EnumerableSet.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value =\u003e uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\n// contracts/interfaces/ISynapseGasOracle.sol\n\ninterface ISynapseGasOracle is IGasOracle {\n    /// @notice Allows Synapse Module to pass the gas data from a remote chain to the Gas Oracle.\n    /// @dev Could only be called by Synapse Module.\n    /// @param srcChainId        The chain id of the remote chain.\n    /// @param data              The gas data from the remote chain.\n    function receiveRemoteGasData(uint256 srcChainId, bytes calldata data) external;\n\n    /// @notice Gets the gas data for the local chain.\n    function getLocalGasData() external view returns (bytes memory);\n}\n\n// contracts/libs/InterchainEntry.sol\n\n/// @notice Struct representing an entry in the Interchain DataBase.\n/// Entry has a globally unique identifier (key) and a value.\n/// - key: srcChainId + dbNonce + entryIndex\n/// - value: srcWriter + dataHash\n/// @param srcChainId   The chain id of the source chain\n/// @param dbNonce      The database nonce of the batch containing the entry\n/// @param entryIndex   The index of the entry in the batch\n/// @param srcWriter    The address of the writer on the source chain\n/// @param dataHash     The hash of the data written on the source chain\nstruct InterchainEntry {\n    // TODO: can we use uint64 for chain id?\n    uint256 srcChainId;\n    uint256 dbNonce;\n    uint64 entryIndex;\n    bytes32 srcWriter;\n    bytes32 dataHash;\n}\n\nusing InterchainEntryLib for InterchainEntry global;\n\nlibrary InterchainEntryLib {\n    /// @notice Constructs an InterchainEntry struct to be written on the local chain\n    /// @param dbNonce      The database nonce of the entry on the source chain\n    /// @param writer       The address of the writer on the local chain\n    /// @param dataHash     The hash of the data written on the local chain\n    /// @return entry       The constructed InterchainEntry struct\n    function constructLocalEntry(\n        uint256 dbNonce,\n        uint64 entryIndex,\n        address writer,\n        bytes32 dataHash\n    )\n        internal\n        view\n        returns (InterchainEntry memory entry)\n    {\n        return InterchainEntry({\n            srcChainId: block.chainid,\n            dbNonce: dbNonce,\n            entryIndex: entryIndex,\n            srcWriter: TypeCasts.addressToBytes32(writer),\n            dataHash: dataHash\n        });\n    }\n\n    /// @notice Returns the globally unique identifier of the entry\n    function entryKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce, entry.entryIndex));\n    }\n\n    /// @notice Returns the value of the entry: writer + dataHash hashed together\n    function entryValue(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcWriter, entry.dataHash));\n    }\n\n    /// @notice Returns the globally unique identifier of the batch containing the entry\n    function batchKey(InterchainEntry memory entry) internal pure returns (bytes32) {\n        return keccak256(abi.encode(entry.srcChainId, entry.dbNonce));\n    }\n}\n\n// contracts/libs/ModuleBatch.sol\n\nlibrary ModuleBatchLib {\n    /// @notice Encodes the InterchainBatch and the auxiliary module data into a single bytes array\n    /// @param batch       The InterchainBatch to encode\n    /// @param moduleData  The auxiliary module data to encode\n    function encodeModuleBatch(\n        InterchainBatch memory batch,\n        bytes memory moduleData\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encode(batch, moduleData);\n    }\n\n    /// @notice Decodes the bytes array into the InterchainBatch and the auxiliary module data\n    /// @param encodedModuleBatch  The bytes array to decode\n    /// @return batch              The decoded InterchainBatch\n    /// @return moduleData         The decoded auxiliary module data\n    function decodeModuleBatch(bytes memory encodedModuleBatch)\n        internal\n        pure\n        returns (InterchainBatch memory batch, bytes memory moduleData)\n    {\n        return abi.decode(encodedModuleBatch, (InterchainBatch, bytes));\n    }\n}\n\n// node_modules/@openzeppelin/contracts/access/Ownable.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// contracts/libs/ThresholdECDSA.sol\n\nstruct ThresholdECDSA {\n    uint256 _threshold;\n    EnumerableSet.AddressSet _signers;\n}\n\nusing ThresholdECDSALib for ThresholdECDSA global;\n\n// solhint-disable code-complexity\nlibrary ThresholdECDSALib {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    uint256 private constant SIGNATURE_LENGTH = 65;\n\n    error ThresholdECDSA__AlreadySigner(address account);\n    error ThresholdECDSA__IncorrectSignaturesLength(uint256 length);\n    error ThresholdECDSA__InvalidSignature(bytes signature);\n    error ThresholdECDSA__NotEnoughSignatures(uint256 provided, uint256 threshold);\n    error ThresholdECDSA__NotSigner(address account);\n    error ThresholdECDSA__RecoveredSignersNotSorted();\n    error ThresholdECDSA__ZeroAddress();\n    error ThresholdECDSA__ZeroThreshold();\n\n    /// @notice Adds a new signer to the list of signers.\n    /// @dev Will revert if the account is already a signer.\n    function addSigner(ThresholdECDSA storage self, address account) internal {\n        if (account == address(0)) revert ThresholdECDSA__ZeroAddress();\n        bool added = self._signers.add(account);\n        if (!added) {\n            revert ThresholdECDSA__AlreadySigner(account);\n        }\n    }\n\n    /// @notice Removes a signer from the list of signers.\n    /// @dev Will revert if the account is not a signer.\n    function removeSigner(ThresholdECDSA storage self, address account) internal {\n        bool removed = self._signers.remove(account);\n        if (!removed) {\n            revert ThresholdECDSA__NotSigner(account);\n        }\n    }\n\n    /// @notice Modifies the threshold of signatures required.\n    function modifyThreshold(ThresholdECDSA storage self, uint256 threshold) internal {\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        self._threshold = threshold;\n    }\n\n    /// @notice Checks if the account is a signer.\n    function isSigner(ThresholdECDSA storage self, address account) internal view returns (bool) {\n        return self._signers.contains(account);\n    }\n\n    /// @notice Gets the full list of signers.\n    function getSigners(ThresholdECDSA storage self) internal view returns (address[] memory) {\n        return self._signers.values();\n    }\n\n    /// @notice Gets the threshold of signatures required.\n    function getThreshold(ThresholdECDSA storage self) internal view returns (uint256) {\n        return self._threshold;\n    }\n\n    /// @notice Verifies that the number of signatures is greater than or equal to the threshold.\n    /// Note: the list of signers recovered from the signatures is required to be sorted in ascending order.\n    /// @dev Will revert if either of the conditions is met:\n    /// - Threshold is not configured.\n    /// - Any of the payloads is not a valid signature payload.\n    /// - The number of signatures is less than the threshold.\n    /// - The recovered list of signers is not sorted in the ascending order.\n    function verifySignedHash(ThresholdECDSA storage self, bytes32 hash, bytes calldata signatures) internal view {\n        // Figure out the signaturesAmount of signatures provided\n        uint256 signaturesAmount = signatures.length / SIGNATURE_LENGTH;\n        if (signaturesAmount * SIGNATURE_LENGTH != signatures.length) {\n            revert ThresholdECDSA__IncorrectSignaturesLength(signatures.length);\n        }\n        // First, check that threshold is configured and enough signatures are provided\n        uint256 threshold = self._threshold;\n        if (threshold == 0) {\n            revert ThresholdECDSA__ZeroThreshold();\n        }\n        uint256 offset = 0;\n        uint256 validSignatures = 0;\n        address lastSigner = address(0);\n        for (uint256 i = 0; i \u003c signaturesAmount; ++i) {\n            bytes memory signature = signatures[offset:offset + SIGNATURE_LENGTH];\n            (address recovered, ECDSA.RecoverError error,) = ECDSA.tryRecover(hash, signature);\n            if (error != ECDSA.RecoverError.NoError) {\n                revert ThresholdECDSA__InvalidSignature(signature);\n            }\n            // Check that the recovered addresses list is strictly increasing\n            if (recovered \u003c= lastSigner) {\n                revert ThresholdECDSA__RecoveredSignersNotSorted();\n            }\n            lastSigner = recovered;\n            // Since the signers list is sorted, every time we find a valid signer it's not a duplicate\n            if (isSigner(self, recovered)) {\n                validSignatures += 1;\n            }\n            offset += SIGNATURE_LENGTH;\n        }\n        if (validSignatures \u003c threshold) {\n            revert ThresholdECDSA__NotEnoughSignatures(validSignatures, threshold);\n        }\n    }\n}\n\n// node_modules/@openzeppelin/contracts/utils/Strings.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value \u003c 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i \u003e 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue \u0026 0xf];\n            localValue \u003e\u003e= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length \u0026\u0026 keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n\n// contracts/interfaces/IInterchainDB.sol\n\ninterface IInterchainDB {\n    /// @notice Struct representing a batch of entries from the remote Interchain DataBase,\n    /// verified by the Interchain Module.\n    /// @param verifiedAt   The block timestamp at which the entry was verified by the module\n    /// @param batchRoot    The Merkle root of the batch\n    struct RemoteBatch {\n        uint256 verifiedAt;\n        bytes32 batchRoot;\n    }\n\n    error InterchainDB__BatchDoesNotExist(uint256 dbNonce);\n    error InterchainDB__BatchNotFinalized(uint256 dbNonce);\n    error InterchainDB__ConflictingBatches(address module, bytes32 existingBatchRoot, InterchainBatch newBatch);\n    error InterchainDB__EntryIndexOutOfRange(uint256 dbNonce, uint64 entryIndex, uint64 batchSize);\n    error InterchainDB__IncorrectFeeAmount(uint256 actualFee, uint256 expectedFee);\n    error InterchainDB__InvalidEntryRange(uint256 dbNonce, uint64 start, uint64 end);\n    error InterchainDB__NoModulesSpecified();\n    error InterchainDB__SameChainId(uint256 chainId);\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Note: there are no guarantees that this entry will be available for reading on any of the remote chains.\n    /// Use `requestBatchVerification` to ensure that the entry is available for reading on the destination chain.\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntry(bytes32 dataHash) external returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Request the given Interchain Modules to verify an existing batch.\n    /// If the batch is not finalized, the module will verify it after finalization.\n    /// For the finalized batch the batch root is already available, and the module can verify it immediately.\n    /// Note: every module has a separate fee paid in the native gas token of the source chain,\n    /// and `msg.value` must be equal to the sum of all fees.\n    /// Note: this method is permissionless, and anyone can request verification for any batch.\n    /// @dev Will revert if the batch with the given nonce does not exist.\n    /// @param dstChainId    The chain id of the destination chain\n    /// @param dbNonce       The database nonce of the existing batch\n    /// @param srcModules    The source chain addresses of the Interchain Modules to use for verification\n    function requestBatchVerification(\n        uint256 dstChainId,\n        uint256 dbNonce,\n        address[] memory srcModules\n    )\n        external\n        payable;\n\n    /// @notice Write data to the Interchain DataBase as a new entry in the current batch.\n    /// Then request the Interchain Modules to verify the batch containing the written entry on the destination chain.\n    /// See `writeEntry` and `requestBatchVerification` for more details.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dataHash     The hash of the data to be written to the Interchain DataBase as a new entry\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    /// @return dbNonce     The database nonce of the batch containing the written entry\n    /// @return entryIndex  The index of the written entry within the batch\n    function writeEntryWithVerification(\n        uint256 dstChainId,\n        bytes32 dataHash,\n        address[] memory srcModules\n    )\n        external\n        payable\n        returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Allows the Interchain Module to verify the batch coming from the remote chain.\n    /// @param batch        The Interchain Batch to confirm\n    function verifyRemoteBatch(InterchainBatch memory batch) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the fee for writing data to the Interchain DataBase, and verifying it on the destination chain\n    /// using the provided Interchain Modules.\n    /// @dev Will revert if the empty array of modules is provided.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param srcModules   The source chain addresses of the Interchain Modules to use for verification\n    function getInterchainFee(uint256 dstChainId, address[] memory srcModules) external view returns (uint256);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce.\n    /// Note: the leafs are ordered by the index of the written entry in the current batch,\n    /// and the leafs value match the value of the written entry (srcWriter + dataHash hashed together).\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchLeafs(uint256 dbNonce) external view returns (bytes32[] memory);\n\n    /// @notice Returns the list of leafs of the finalized batch with the given nonce,\n    /// paginated by the given start and end indexes. The end index is exclusive.\n    /// Note: this is useful when the batch contains a large number of leafs, and calling `getBatchLeafs`\n    /// would result in a gas limit exceeded error.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the provided range is invalid.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param start        The start index of the paginated leafs, inclusive\n    /// @param end          The end index of the paginated leafs, exclusive\n    function getBatchLeafsPaginated(\n        uint256 dbNonce,\n        uint64 start,\n        uint64 end\n    )\n        external\n        view\n        returns (bytes32[] memory);\n\n    /// @notice Returns the size of the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatchSize(uint256 dbNonce) external view returns (uint64);\n\n    /// @notice Get the finalized Interchain Batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// @param dbNonce      The database nonce of the finalized batch\n    function getBatch(uint256 dbNonce) external view returns (InterchainBatch memory);\n\n    /// @notice Get the Interchain Entry's value written on the local chain with the given batch nonce and entry index.\n    /// Entry value is calculated as the hash of the writer address and the written data hash.\n    /// Note: the batch does not have to be finalized to fetch the entry value.\n    /// @dev Will revert if the batch with the given nonce does not exist,\n    /// or the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the existing batch\n    /// @param entryIndex   The index of the written entry within the batch\n    function getEntryValue(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32);\n\n    /// @notice Get the Merkle proof of inclusion for the entry with the given index\n    /// in the finalized batch with the given nonce.\n    /// @dev Will revert if the batch with the given nonce does not exist, or is not finalized.\n    /// Will revert if the entry with the given index does not exist within the batch.\n    /// @param dbNonce      The database nonce of the finalized batch\n    /// @param entryIndex   The index of the written entry within the batch\n    /// @return proof       The Merkle proof of inclusion for the entry\n    function getEntryProof(uint256 dbNonce, uint64 entryIndex) external view returns (bytes32[] memory proof);\n\n    /// @notice Get the nonce of the database, which is incremented every time a new batch is finalized.\n    /// This is the nonce of the current non-finalized batch.\n    function getDBNonce() external view returns (uint256);\n\n    /// @notice Get the index of the next entry to be written to the database.\n    /// @return dbNonce      The database nonce of the batch including the next entry\n    /// @return entryIndex   The index of the next entry within that batch\n    function getNextEntryIndex() external view returns (uint256 dbNonce, uint64 entryIndex);\n\n    /// @notice Read the data written on specific source chain by a specific writer,\n    /// and verify it on the destination chain using the provided Interchain Module.\n    /// Note: returned zero value indicates that the module has not verified the entry.\n    /// @param entry        The Interchain Entry to read\n    /// @param dstModule    The destination chain addresses of the Interchain Modules to use for verification\n    /// @return moduleVerifiedAt   The block timestamp at which the entry was verified by the module,\n    ///                             or ZERO if the module has not verified the entry.\n    function checkVerification(\n        address dstModule,\n        InterchainEntry memory entry,\n        bytes32[] memory proof\n    )\n        external\n        view\n        returns (uint256 moduleVerifiedAt);\n}\n\n// node_modules/@openzeppelin/contracts/utils/cryptography/MessageHashUtils.sol\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MessageHashUtils.sol)\n\n/**\n * @dev Signature message hash utilities for producing digests to be consumed by {ECDSA} recovery or signing.\n *\n * The library provides methods for generating a hash of a message that conforms to the\n * https://eips.ethereum.org/EIPS/eip-191[EIP 191] and https://eips.ethereum.org/EIPS/eip-712[EIP 712]\n * specifications.\n */\nlibrary MessageHashUtils {\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing a bytes32 `messageHash` with\n     * `\"\\x19Ethereum Signed Message:\\n32\"` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * NOTE: The `messageHash` parameter is intended to be the result of hashing a raw message with\n     * keccak256, although any bytes32 value can be safely used because the final digest will\n     * be re-hashed.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes32 messageHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\") // 32 is the bytes-length of messageHash\n            mstore(0x1c, messageHash) // 0x1c (28) is the length of the prefix\n            digest := keccak256(0x00, 0x3c) // 0x3c is the length of the prefix (0x1c) + messageHash (0x20)\n        }\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x45` (`personal_sign` messages).\n     *\n     * The digest is calculated by prefixing an arbitrary `message` with\n     * `\"\\x19Ethereum Signed Message:\\n\" + len(message)` and hashing the result. It corresponds with the\n     * hash signed when using the https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`] JSON-RPC method.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toEthSignedMessageHash(bytes memory message) internal pure returns (bytes32) {\n        return\n            keccak256(bytes.concat(\"\\x19Ethereum Signed Message:\\n\", bytes(Strings.toString(message.length)), message));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-191 signed data with version\n     * `0x00` (data with intended validator).\n     *\n     * The digest is calculated by prefixing an arbitrary `data` with `\"\\x19\\x00\"` and the intended\n     * `validator` address. Then hashing the result.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(hex\"19_00\", validator, data));\n    }\n\n    /**\n     * @dev Returns the keccak256 digest of an EIP-712 typed data (EIP-191 version `0x01`).\n     *\n     * The digest is calculated from a `domainSeparator` and a `structHash`, by prefixing them with\n     * `\\x19\\x01` and hashing the result. It corresponds to the hash signed by the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`] JSON-RPC method as part of EIP-712.\n     *\n     * See {ECDSA-recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 digest) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, hex\"19_01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            digest := keccak256(ptr, 0x42)\n        }\n    }\n}\n\n// contracts/interfaces/IInterchainModule.sol\n\n/// @notice Every Module may opt a different method to confirm the verified entries on destination chain,\n/// therefore this is not a part of a common interface.\ninterface IInterchainModule {\n    error InterchainModule__NotInterchainDB(address caller);\n    error InterchainModule__IncorrectSourceChainId(uint256 chainId);\n    error InterchainModule__InsufficientFee(uint256 actual, uint256 required);\n    error InterchainModule__SameChainId(uint256 chainId);\n\n    /// @notice Request the verification of a batch from the Interchain DataBase by the module.\n    /// If the batch is not yet finalized, the verification on destination chain will be delayed until\n    /// the finalization is done and batch root is saved on the source chain.\n    /// Note: a fee is paid to the module for verification, and could be retrieved by using `getModuleFee`.\n    /// Note: this will eventually trigger `InterchainDB.verifyRemoteBatch(batch)` function on destination chain,\n    /// with no guarantee of ordering.\n    /// @dev Could be only called by the Interchain DataBase contract.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param batch        The batch to verify\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable;\n\n    /// @notice Get the Module fee for verifying a batch on the specified destination chain.\n    /// @param dstChainId   The chain id of the destination chain\n    /// @param dbNonce      The database nonce of the batch on the source chain\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256);\n}\n\n// contracts/interfaces/ISynapseModule.sol\n\ninterface ISynapseModule is IInterchainModule {\n    error SynapseModule__ClaimFeeFractionExceedsMax(uint256 claimFeeFraction);\n    error SynapseModule__FeeCollectorNotSet();\n    error SynapseModule__GasOracleNotContract(address gasOracle);\n    error SynapseModule__GasOracleNotSet();\n    error SynapseModule__NoFeesToClaim();\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @notice Adds a new verifier to the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is already added.\n    /// @param verifier     The address of the verifier to add\n    function addVerifier(address verifier) external;\n\n    /// @notice Adds a list of new verifiers to the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is already added.\n    /// @param verifiers    The list of addresses of the verifiers to add\n    function addVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Removes a verifier from the module.\n    /// @dev Could be only called by the owner. Will revert if the verifier is not added.\n    /// @param verifier     The address of the verifier to remove\n    function removeVerifier(address verifier) external;\n\n    /// @notice Removes a list of verifiers from the module.\n    /// @dev Could be only called by the owner. Will revert if any of the verifiers is not added.\n    /// @param verifiers    The list of addresses of the verifiers to remove\n    function removeVerifiers(address[] calldata verifiers) external;\n\n    /// @notice Sets the threshold of the module.\n    /// @dev Could be only called by the owner. Will revert if the threshold is zero.\n    /// @param threshold    The new threshold value\n    function setThreshold(uint256 threshold) external;\n\n    /// @notice Sets the address of the fee collector, which will have the verification fees forwarded to it.\n    /// @dev Could be only called by the owner.\n    /// @param feeCollector_   The address of the fee collector\n    function setFeeCollector(address feeCollector_) external;\n\n    /// @notice Sets the fraction of the accumulated fees to be paid to caller of `claimFees`.\n    /// This encourages rational actors to call the function as soon as claim fee is higher than the gas cost.\n    /// @dev Could be only called by the owner. Could not exceed 1%.\n    /// @param claimFeeFraction The fraction of the fees to be paid to the claimer (100% = 1e18)\n    function setClaimFeeFraction(uint256 claimFeeFraction) external;\n\n    /// @notice Sets the address of the gas oracle to be used for estimating the verification fees.\n    /// @dev Could be only called by the owner. Will revert if the gas oracle is not a contract.\n    /// @param gasOracle_   The address of the gas oracle contract\n    function setGasOracle(address gasOracle_) external;\n\n    /// @notice Sets the estimated gas limit for verifying a batch on the given chain.\n    /// @dev Could be only called by the owner.\n    /// @param chainId      The chain ID for which to set the gas limit\n    /// @param gasLimit     The new gas limit\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external;\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @notice Transfers the accumulated fees to the fee collector.\n    /// Message caller receives a percentage of the fees, this ensures that the module is self-sustainable.\n    /// The claim fee amount could be retrieved using `getClaimFeeAmount`. The rest of the fees\n    /// will be transferred to the fee collector.\n    /// @dev Will revert if the fee collector is not set.\n    function claimFees() external;\n\n    /// @notice Verifies a batch from the remote chain using a set of verifier signatures.\n    /// If the threshold is met, the batch will be marked as verified in the Interchain DataBase.\n    /// @dev List of recovered signers from the signatures must be sorted in the ascending order.\n    /// @param encodedBatch The encoded batch to verify\n    /// @param signatures   Signatures used to verify the batch, concatenated\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external;\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Returns the address of the fee collector for the module.\n    function feeCollector() external view returns (address);\n\n    /// @notice Returns the current claim fee to be paid to the caller of `claimFees`.\n    function getClaimFeeAmount() external view returns (uint256);\n\n    /// @notice Returns the fraction of the fees to be paid to the caller of `claimFees`.\n    /// The returned value is in the range [0, 1e18], where 1e18 corresponds to 100% of the fees.\n    function getClaimFeeFraction() external view returns (uint256);\n\n    /// @notice Returns the address of the gas oracle used for estimating the verification fees.\n    function gasOracle() external view returns (address);\n\n    /// @notice Returns the list of verifiers for the module.\n    function getVerifiers() external view returns (address[] memory);\n\n    /// @notice Gets the threshold of the module.\n    /// This is the minimum number of signatures required for verification.\n    function getThreshold() external view returns (uint256);\n\n    /// @notice Checks if the given account is a verifier for the module.\n    function isVerifier(address account) external view returns (bool);\n\n    /// @notice Returns the estimated gas limit for verifying a batch on the given chain.\n    /// Note: this defaults to DEFAULT_VERIFY_GAS_LIMIT if not set.\n    function getVerifyGasLimit(uint256 chainId) external view returns (uint256);\n}\n\n// contracts/modules/InterchainModule.sol\n\n/// @notice Common logic for all Interchain Modules.\nabstract contract InterchainModule is InterchainModuleEvents, IInterchainModule {\n    address public immutable INTERCHAIN_DB;\n\n    constructor(address interchainDB) {\n        INTERCHAIN_DB = interchainDB;\n    }\n\n    /// @inheritdoc IInterchainModule\n    function requestBatchVerification(uint256 dstChainId, InterchainBatch memory batch) external payable {\n        if (msg.sender != INTERCHAIN_DB) {\n            revert InterchainModule__NotInterchainDB(msg.sender);\n        }\n        if (dstChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        if (batch.srcChainId != block.chainid) {\n            revert InterchainModule__IncorrectSourceChainId({chainId: batch.srcChainId});\n        }\n        uint256 requiredFee = _getModuleFee(dstChainId, batch.dbNonce);\n        if (msg.value \u003c requiredFee) {\n            revert InterchainModule__InsufficientFee({actual: msg.value, required: requiredFee});\n        }\n        bytes memory moduleData = _fillModuleData(dstChainId, batch.dbNonce);\n        bytes memory encodedBatch = ModuleBatchLib.encodeModuleBatch(batch, moduleData);\n        bytes32 ethSignedBatchHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _requestVerification(dstChainId, encodedBatch);\n        emit BatchVerificationRequested(dstChainId, encodedBatch, ethSignedBatchHash);\n    }\n\n    /// @inheritdoc IInterchainModule\n    function getModuleFee(uint256 dstChainId, uint256 dbNonce) external view returns (uint256) {\n        return _getModuleFee(dstChainId, dbNonce);\n    }\n\n    /// @dev Should be called once the Module has verified the batch and needs to signal this\n    /// to the InterchainDB.\n    function _verifyBatch(bytes memory encodedBatch) internal {\n        (InterchainBatch memory batch, bytes memory moduleData) = ModuleBatchLib.decodeModuleBatch(encodedBatch);\n        if (batch.srcChainId == block.chainid) {\n            revert InterchainModule__SameChainId(block.chainid);\n        }\n        IInterchainDB(INTERCHAIN_DB).verifyRemoteBatch(batch);\n        _receiveModuleData(batch.srcChainId, batch.dbNonce, moduleData);\n        emit BatchVerified(\n            batch.srcChainId, encodedBatch, MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch))\n        );\n    }\n\n    // solhint-disable no-empty-blocks\n    /// @dev Internal logic to request the verification of an batch on the destination chain.\n    function _requestVerification(uint256 dstChainId, bytes memory encodedBatch) internal virtual {}\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(uint256 dstChainId, uint256 dbNonce) internal virtual returns (bytes memory) {}\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal virtual {}\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(uint256 dstChainId, uint256 dbNonce) internal view virtual returns (uint256);\n}\n\n// contracts/modules/SynapseModule.sol\n\ncontract SynapseModule is InterchainModule, Ownable, SynapseModuleEvents, ISynapseModule {\n    // TODO: make sure this is a good enough default value\n    uint256 public constant DEFAULT_VERIFY_GAS_LIMIT = 100_000;\n\n    uint256 internal constant MAX_CLAIM_FEE_FRACTION = 0.01e18; // 1%\n    uint256 internal constant FEE_PRECISION = 1e18;\n\n    /// @dev Struct to hold the verifiers and the threshold for the module.\n    ThresholdECDSA internal _verifiers;\n    /// @dev Claim fee fraction, 100% = 1e18\n    uint256 internal _claimFeeFraction;\n    /// @dev Gas limit for the verifyBatch function on the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasLimit) internal _verifyGasLimit;\n    /// @dev Hash of the last gas data sent to the remote chain.\n    mapping(uint256 chainId =\u003e bytes32 gasDataHash) internal _lastGasDataHash;\n    /// @dev Nonce of the last gas data received from the remote chain.\n    mapping(uint256 chainId =\u003e uint256 gasDataNonce) internal _lastGasDataNonce;\n\n    /// @inheritdoc ISynapseModule\n    address public feeCollector;\n    /// @inheritdoc ISynapseModule\n    address public gasOracle;\n\n    constructor(address interchainDB, address owner_) InterchainModule(interchainDB) Ownable(owner_) {\n        // ThresholdECDSA throws an explicit error if threshold is not set, so default value is not needed\n    }\n\n    // ═══════════════════════════════════════════════ PERMISSIONED ════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function addVerifier(address verifier) external onlyOwner {\n        _addVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function addVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _addVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifier(address verifier) external onlyOwner {\n        _removeVerifier(verifier);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function removeVerifiers(address[] calldata verifiers) external onlyOwner {\n        uint256 length = verifiers.length;\n        for (uint256 i = 0; i \u003c length; ++i) {\n            _removeVerifier(verifiers[i]);\n        }\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setThreshold(uint256 threshold) external onlyOwner {\n        _verifiers.modifyThreshold(threshold);\n        emit ThresholdChanged(threshold);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setFeeCollector(address feeCollector_) external onlyOwner {\n        feeCollector = feeCollector_;\n        emit FeeCollectorChanged(feeCollector_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setClaimFeeFraction(uint256 claimFeeFraction) external onlyOwner {\n        if (claimFeeFraction \u003e MAX_CLAIM_FEE_FRACTION) {\n            revert SynapseModule__ClaimFeeFractionExceedsMax(claimFeeFraction);\n        }\n        _claimFeeFraction = claimFeeFraction;\n        emit ClaimFeeFractionChanged(claimFeeFraction);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setGasOracle(address gasOracle_) external onlyOwner {\n        if (gasOracle_.code.length == 0) {\n            revert SynapseModule__GasOracleNotContract(gasOracle_);\n        }\n        gasOracle = gasOracle_;\n        emit GasOracleChanged(gasOracle_);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function setVerifyGasLimit(uint256 chainId, uint256 gasLimit) external onlyOwner {\n        _verifyGasLimit[chainId] = gasLimit;\n        emit VerifyGasLimitChanged(chainId, gasLimit);\n    }\n\n    // ══════════════════════════════════════════════ PERMISSIONLESS ═══════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function claimFees() external {\n        if (feeCollector == address(0)) {\n            revert SynapseModule__FeeCollectorNotSet();\n        }\n        if (address(this).balance == 0) {\n            revert SynapseModule__NoFeesToClaim();\n        }\n        uint256 claimFee = getClaimFeeAmount();\n        uint256 collectedFee = address(this).balance - claimFee;\n        Address.sendValue(payable(feeCollector), collectedFee);\n        Address.sendValue(payable(msg.sender), claimFee);\n        emit FeesClaimed(feeCollector, collectedFee, msg.sender, claimFee);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function verifyRemoteBatch(bytes calldata encodedBatch, bytes calldata signatures) external {\n        bytes32 ethSignedHash = MessageHashUtils.toEthSignedMessageHash(keccak256(encodedBatch));\n        _verifiers.verifySignedHash(ethSignedHash, signatures);\n        _verifyBatch(encodedBatch);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeFraction() external view returns (uint256) {\n        return _claimFeeFraction;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifiers() external view returns (address[] memory) {\n        return _verifiers.getSigners();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function isVerifier(address account) external view returns (bool) {\n        return _verifiers.isSigner(account);\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getClaimFeeAmount() public view returns (uint256) {\n        return address(this).balance * _claimFeeFraction / FEE_PRECISION;\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getThreshold() public view returns (uint256) {\n        return _verifiers.getThreshold();\n    }\n\n    /// @inheritdoc ISynapseModule\n    function getVerifyGasLimit(uint256 chainId) public view override returns (uint256 gasLimit) {\n        gasLimit = _verifyGasLimit[chainId];\n        if (gasLimit == 0) {\n            gasLimit = DEFAULT_VERIFY_GAS_LIMIT;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Adds a verifier to the module. Permissions should be checked in the calling function.\n    function _addVerifier(address verifier) internal {\n        _verifiers.addSigner(verifier);\n        emit VerifierAdded(verifier);\n    }\n\n    /// @dev Removes a verifier from the module. Permissions should be checked in the calling function.\n    function _removeVerifier(address verifier) internal {\n        _verifiers.removeSigner(verifier);\n        emit VerifierRemoved(verifier);\n    }\n\n    /// @dev Internal logic to fill the module data for the specified destination chain.\n    function _fillModuleData(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        override\n        returns (bytes memory moduleData)\n    {\n        moduleData = _getSynapseGasOracle().getLocalGasData();\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return moduleData;\n        }\n        bytes32 dataHash = keccak256(moduleData);\n        // Don't send the same data twice\n        if (dataHash == _lastGasDataHash[dstChainId]) {\n            moduleData = \"\";\n        } else {\n            _lastGasDataHash[dstChainId] = dataHash;\n            emit GasDataSent(dstChainId, moduleData);\n        }\n    }\n\n    /// @dev Internal logic to handle the auxiliary module data relayed from the remote chain.\n    function _receiveModuleData(uint256 srcChainId, uint256 dbNonce, bytes memory moduleData) internal override {\n        // Exit early if data is empty\n        if (moduleData.length == 0) {\n            return;\n        }\n        // Don't process outdated data\n        uint256 lastNonce = _lastGasDataNonce[srcChainId];\n        if (lastNonce == 0 || lastNonce \u003c dbNonce) {\n            _lastGasDataNonce[srcChainId] = dbNonce;\n            _getSynapseGasOracle().receiveRemoteGasData(srcChainId, moduleData);\n            emit GasDataReceived(srcChainId, moduleData);\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Internal logic to get the module fee for verifying an batch on the specified destination chain.\n    function _getModuleFee(\n        uint256 dstChainId,\n        uint256 // dbNonce\n    )\n        internal\n        view\n        override\n        returns (uint256)\n    {\n        // On the remote chain the verifyRemoteBatch(batch, signatures) function will be called.\n        // We need to figure out the calldata size for the remote call.\n        // selector (4 bytes) + batch + signatures\n        // batch is 32 (length) + 32*3 (fields) = 128\n        // signatures: 32 (length) + 65*threshold (padded up to be a multiple of 32 bytes)\n        // Total formula is: 4 + 32 (batch offset) + 32 (signatures offset) + 128 + 32\n        return _getSynapseGasOracle().estimateTxCostInLocalUnits({\n            remoteChainId: dstChainId,\n            gasLimit: getVerifyGasLimit(dstChainId),\n            calldataSize: 260 + 64 * getThreshold()\n        });\n    }\n\n    /// @dev Internal logic to get the Synapse Gas Oracle. Reverts if the gas oracle is not set.\n    function _getSynapseGasOracle() internal view returns (ISynapseGasOracle synapseGasOracle) {\n        synapseGasOracle = ISynapseGasOracle(gasOracle);\n        if (address(synapseGasOracle) == address(0)) {\n            revert SynapseModule__GasOracleNotSet();\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"4285:280:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;4285:280:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"4285:280:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseModule.sol\":\"TypeCasts\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseModule.sol\":{\"keccak256\":\"0xa22dfa075dfef8a85bbab87330c14bf4901102b94c47c3efa49934b451eb58fe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://cd63d37efb6d2f8aa253a6164e64b69fcc443b8543d2e37bf14a7a04ce0cdf1d\",\"dweb:/ipfs/QmbNrUoLxcx88GMhA13gZ7ZoX84XdvjXEcYkFiYPPXiRtz\"]}},\"version\":1}"},"hashes":{}}}