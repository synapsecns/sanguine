{"solidity/BridgeTransactionV2Harness.sol:BridgeTransactionV2Harness":{"code":"0x608060405234801561001057600080fd5b50610e65806100206000396000f3fe608060405234801561001057600080fd5b50600436106101365760003560e01c80637d67c5a7116100b25780639c53880211610081578063e79f178211610066578063e79f1782146102d7578063e938730e146102ea578063faef535a146102fd57600080fd5b80639c538802146102b1578063dcafa970146102c457600080fd5b80637d67c5a714610252578063938328991461027857806393bb0d801461028b5780639bdb46fe1461029e57600080fd5b806337518e50116101095780635c3fa4c0116100ee5780635c3fa4c0146102045780636907efd71461022c5780637241b9cb1461023f57600080fd5b806337518e50146101b95780634e765004146101f157600080fd5b80630af3f4031461013b57806312d0c51214610165578063230602c1146101865780632465702414610199575b600080fd5b61014e610149366004610868565b61031d565b60405161015c9291906108da565b60405180910390f35b610178610173366004610868565b610335565b60405190815260200161015c565b610178610194366004610868565b610344565b6101ac6101a7366004610868565b610351565b60405161015c9190610995565b6101cc6101c7366004610868565b61044e565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161015c565b6101786101ff366004610868565b61045d565b610217610212366004610868565b610469565b60405163ffffffff909116815260200161015c565b61017861023a366004610868565b610478565b61017861024d366004610868565b610485565b610265610260366004610868565b610491565b60405161ffff909116815260200161015c565b6101cc610286366004610868565b61049d565b610217610299366004610868565b6104ac565b6101cc6102ac366004610868565b6104bb565b6101cc6102bf366004610868565b6104ca565b6101cc6102d2366004610868565b6104d9565b6101786102e5366004610868565b6104e8565b6101786102f8366004610868565b6104f4565b61031061030b366004610c34565b610500565b60405161015c9190610d69565b36600061032a8484610511565b915091509250929050565b6000607a8301355b9392505050565b600061012e83013561033d565b610444604051806101e00160405280600063ffffffff168152602001600063ffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001600081526020016000815260200160008152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001606081525090565b61033d8383610522565b6000604683013560601c61033d565b600060da83013561033d565b6000600683013560e01c61033d565b600061010e83013561033d565b6000605a83013561033d565b6000823560f01c61033d565b6000603283013560601c61033d565b6000600283013560e01c61033d565b6000600a83013560601c61033d565b6000601e83013560601c61033d565b600060fa83013560601c61033d565b600060ba83013561033d565b6000609a83013561033d565b606061050b82610705565b92915050565b36600061032a8361014e8187610d7c565b610615604051806101e00160405280600063ffffffff168152602001600063ffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001600081526020016000815260200160008152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001606081525090565b600283013560e090811c82526006840135811c6020830152600a840135606090811c6040840152601e850135811c818401526032850135811c60808401526046850135811c60a0840152605a85013560c0840152607a85013591830191909152609a84013561010083015260ba84013561012083015260da84013561014083015260fa840135901c61016082015261010e83013561018082015261012e8301356101a08201526106c58383610511565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050506101c082015292915050565b8051602080830151604080850151606086810151608088015160a089015160c08a015195517e02000000000000000000000000000000000000000000000000000000000000988101989098527fffffffff0000000000000000000000000000000000000000000000000000000060e0998a1b811660228a01529690981b90951660268701527fffffffffffffffffffffffffffffffffffffffff00000000000000000000000092821b8316602a870152811b8216603e86015292831b8116605285015293821b9093166066830152607a820192909252600090609a01604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905260e08501516101008601516101208701516101408801516101608901516101808a01516101a08b01516101c08c0151979950610851988a9890602001610da6565b604051602081830303815290604052915050919050565b6000806020838503121561087b57600080fd5b823567ffffffffffffffff8082111561089357600080fd5b818501915085601f8301126108a757600080fd5b8135818111156108b657600080fd5b8660208285010111156108c857600080fd5b60209290920196919550909350505050565b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b60005b8381101561094257818101518382015260200161092a565b50506000910152565b60008151808452610963816020860160208601610927565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526109ac60208201835163ffffffff169052565b600060208301516109c5604084018263ffffffff169052565b50604083015173ffffffffffffffffffffffffffffffffffffffff8116606084015250606083015173ffffffffffffffffffffffffffffffffffffffff8116608084015250608083015173ffffffffffffffffffffffffffffffffffffffff811660a08401525060a083015173ffffffffffffffffffffffffffffffffffffffff811660c08401525060c083015160e08381019190915283015161010080840191909152830151610120808401919091528301516101408084019190915283015161016080840191909152830151610180610ab78185018373ffffffffffffffffffffffffffffffffffffffff169052565b8401516101a0848101919091528401516101c0808501919091528401516101e0808501529050610aeb61020084018261094b565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516101e0810167ffffffffffffffff81118282101715610b4657610b46610af3565b60405290565b803563ffffffff81168114610b6057600080fd5b919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610b6057600080fd5b600082601f830112610b9a57600080fd5b813567ffffffffffffffff80821115610bb557610bb5610af3565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610bfb57610bfb610af3565b81604052838152866020858801011115610c1457600080fd5b836020870160208301376000602085830101528094505050505092915050565b600060208284031215610c4657600080fd5b813567ffffffffffffffff80821115610c5e57600080fd5b908301906101e08286031215610c7357600080fd5b610c7b610b22565b610c8483610b4c565b8152610c9260208401610b4c565b6020820152610ca360408401610b65565b6040820152610cb460608401610b65565b6060820152610cc560808401610b65565b6080820152610cd660a08401610b65565b60a082015260c0838101359082015260e08084013590820152610100808401359082015261012080840135908201526101408084013590820152610160610d1e818501610b65565b9082015261018083810135908201526101a080840135908201526101c08084013583811115610d4c57600080fd5b610d5888828701610b89565b918301919091525095945050505050565b60208152600061033d602083018461094b565b60008085851115610d8c57600080fd5b83861115610d9957600080fd5b5050820193919092039150565b60008a51610db8818460208f01610927565b80830190508a81528960208201528860408201528760608201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008760601b1660808201528560948201528460b48201528351610e1c8160d4840160208801610927565b0160d4019b9a505050505050505050505056fea2646970667358221220ec634eada85ddd9f3a51bdae8c8de0703366a52e644989f6d717509c24795d6864736f6c63430008180033","runtime-code":"0x608060405234801561001057600080fd5b50600436106101365760003560e01c80637d67c5a7116100b25780639c53880211610081578063e79f178211610066578063e79f1782146102d7578063e938730e146102ea578063faef535a146102fd57600080fd5b80639c538802146102b1578063dcafa970146102c457600080fd5b80637d67c5a714610252578063938328991461027857806393bb0d801461028b5780639bdb46fe1461029e57600080fd5b806337518e50116101095780635c3fa4c0116100ee5780635c3fa4c0146102045780636907efd71461022c5780637241b9cb1461023f57600080fd5b806337518e50146101b95780634e765004146101f157600080fd5b80630af3f4031461013b57806312d0c51214610165578063230602c1146101865780632465702414610199575b600080fd5b61014e610149366004610868565b61031d565b60405161015c9291906108da565b60405180910390f35b610178610173366004610868565b610335565b60405190815260200161015c565b610178610194366004610868565b610344565b6101ac6101a7366004610868565b610351565b60405161015c9190610995565b6101cc6101c7366004610868565b61044e565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161015c565b6101786101ff366004610868565b61045d565b610217610212366004610868565b610469565b60405163ffffffff909116815260200161015c565b61017861023a366004610868565b610478565b61017861024d366004610868565b610485565b610265610260366004610868565b610491565b60405161ffff909116815260200161015c565b6101cc610286366004610868565b61049d565b610217610299366004610868565b6104ac565b6101cc6102ac366004610868565b6104bb565b6101cc6102bf366004610868565b6104ca565b6101cc6102d2366004610868565b6104d9565b6101786102e5366004610868565b6104e8565b6101786102f8366004610868565b6104f4565b61031061030b366004610c34565b610500565b60405161015c9190610d69565b36600061032a8484610511565b915091509250929050565b6000607a8301355b9392505050565b600061012e83013561033d565b610444604051806101e00160405280600063ffffffff168152602001600063ffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001600081526020016000815260200160008152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001606081525090565b61033d8383610522565b6000604683013560601c61033d565b600060da83013561033d565b6000600683013560e01c61033d565b600061010e83013561033d565b6000605a83013561033d565b6000823560f01c61033d565b6000603283013560601c61033d565b6000600283013560e01c61033d565b6000600a83013560601c61033d565b6000601e83013560601c61033d565b600060fa83013560601c61033d565b600060ba83013561033d565b6000609a83013561033d565b606061050b82610705565b92915050565b36600061032a8361014e8187610d7c565b610615604051806101e00160405280600063ffffffff168152602001600063ffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001600081526020016000815260200160008152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160008152602001606081525090565b600283013560e090811c82526006840135811c6020830152600a840135606090811c6040840152601e850135811c818401526032850135811c60808401526046850135811c60a0840152605a85013560c0840152607a85013591830191909152609a84013561010083015260ba84013561012083015260da84013561014083015260fa840135901c61016082015261010e83013561018082015261012e8301356101a08201526106c58383610511565b8080601f0160208091040260200160405190810160405280939291908181526020018383808284376000920191909152505050506101c082015292915050565b8051602080830151604080850151606086810151608088015160a089015160c08a015195517e02000000000000000000000000000000000000000000000000000000000000988101989098527fffffffff0000000000000000000000000000000000000000000000000000000060e0998a1b811660228a01529690981b90951660268701527fffffffffffffffffffffffffffffffffffffffff00000000000000000000000092821b8316602a870152811b8216603e86015292831b8116605285015293821b9093166066830152607a820192909252600090609a01604080517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08184030181529082905260e08501516101008601516101208701516101408801516101608901516101808a01516101a08b01516101c08c0151979950610851988a9890602001610da6565b604051602081830303815290604052915050919050565b6000806020838503121561087b57600080fd5b823567ffffffffffffffff8082111561089357600080fd5b818501915085601f8301126108a757600080fd5b8135818111156108b657600080fd5b8660208285010111156108c857600080fd5b60209290920196919550909350505050565b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b60005b8381101561094257818101518382015260200161092a565b50506000910152565b60008151808452610963816020860160208601610927565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b602081526109ac60208201835163ffffffff169052565b600060208301516109c5604084018263ffffffff169052565b50604083015173ffffffffffffffffffffffffffffffffffffffff8116606084015250606083015173ffffffffffffffffffffffffffffffffffffffff8116608084015250608083015173ffffffffffffffffffffffffffffffffffffffff811660a08401525060a083015173ffffffffffffffffffffffffffffffffffffffff811660c08401525060c083015160e08381019190915283015161010080840191909152830151610120808401919091528301516101408084019190915283015161016080840191909152830151610180610ab78185018373ffffffffffffffffffffffffffffffffffffffff169052565b8401516101a0848101919091528401516101c0808501919091528401516101e0808501529050610aeb61020084018261094b565b949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040516101e0810167ffffffffffffffff81118282101715610b4657610b46610af3565b60405290565b803563ffffffff81168114610b6057600080fd5b919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610b6057600080fd5b600082601f830112610b9a57600080fd5b813567ffffffffffffffff80821115610bb557610bb5610af3565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610bfb57610bfb610af3565b81604052838152866020858801011115610c1457600080fd5b836020870160208301376000602085830101528094505050505092915050565b600060208284031215610c4657600080fd5b813567ffffffffffffffff80821115610c5e57600080fd5b908301906101e08286031215610c7357600080fd5b610c7b610b22565b610c8483610b4c565b8152610c9260208401610b4c565b6020820152610ca360408401610b65565b6040820152610cb460608401610b65565b6060820152610cc560808401610b65565b6080820152610cd660a08401610b65565b60a082015260c0838101359082015260e08084013590820152610100808401359082015261012080840135908201526101408084013590820152610160610d1e818501610b65565b9082015261018083810135908201526101a080840135908201526101c08084013583811115610d4c57600080fd5b610d5888828701610b89565b918301919091525095945050505050565b60208152600061033d602083018461094b565b60008085851115610d8c57600080fd5b83861115610d9957600080fd5b5050820193919092039150565b60008a51610db8818460208f01610927565b80830190508a81528960208201528860408201528760608201527fffffffffffffffffffffffffffffffffffffffff0000000000000000000000008760601b1660808201528560948201528460b48201528351610e1c8160d4840160208801610927565b0160d4019b9a505050505050505050505056fea2646970667358221220ec634eada85ddd9f3a51bdae8c8de0703366a52e644989f6d717509c24795d6864736f6c63430008180033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.24 ^0.8.4;\n\n// contracts/interfaces/IFastBridge.sol\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        bool sendChainGas;\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(\n        bytes32 indexed transactionId,\n        address indexed sender,\n        bytes request,\n        uint32 destChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        bool sendChainGas\n    );\n    event BridgeRelayed(\n        bytes32 indexed transactionId,\n        address indexed relayer,\n        address indexed to,\n        uint32 originChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        uint256 chainGasAmount\n    );\n    event BridgeProofProvided(bytes32 indexed transactionId, address indexed relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 indexed transactionId, address indexed relayer);\n    event BridgeDepositClaimed(\n        bytes32 indexed transactionId, address indexed relayer, address indexed to, address token, uint256 amount\n    );\n    event BridgeDepositRefunded(bytes32 indexed transactionId, address indexed to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address sender;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount; // should include protocol fee (if any)\n        uint256 destAmount; // should include relayer fee\n        bool sendChainGas;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    function refund(bytes memory request) external;\n\n    // ============ Views ============\n\n    /// @notice Decodes bridge request into a bridge transaction\n    /// @param request The bridge request to decode\n    function getBridgeTransaction(bytes memory request) external view returns (BridgeTransaction memory);\n\n    /// @notice Checks if the dispute period has passed so bridge deposit can be claimed\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to check\n    /// @param relayer The address of the relayer attempting to claim\n    function canClaim(bytes32 transactionId, address relayer) external view returns (bool);\n}\n\n// contracts/interfaces/IFastBridgeV2.sol\n\ninterface IFastBridgeV2 is IFastBridge {\n    enum BridgeStatus {\n        NULL, // doesn't exist yet\n        REQUESTED,\n        RELAYER_PROVED,\n        RELAYER_CLAIMED,\n        REFUNDED\n    }\n\n    struct BridgeTxDetails {\n        BridgeStatus status;\n        uint32 destChainId;\n        uint56 proofBlockTimestamp;\n        address proofRelayer;\n    }\n\n    struct BridgeRelay {\n        uint48 blockNumber;\n        uint48 blockTimestamp;\n        address relayer;\n    }\n\n    /// @notice New params introduced in the FastBridgeV2.\n    /// We are passing fields from the older BridgeParams struct outside of this struct\n    /// for backwards compatibility.\n    /// Note: quoteRelayer and quoteExclusivitySeconds are either both zero (indicating no exclusivity)\n    /// or both non-zero (indicating exclusivity for the given period).\n    /// Note: zapNative \u003e 0 can NOT be used with destToken = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE (native token)\n    /// @param quoteRelayer             Relayer that provided the quote for the transaction\n    /// @param quoteExclusivitySeconds  Period of time the quote relayer is guaranteed exclusivity after user's deposit\n    /// @param quoteId                  Unique quote identifier used for tracking the quote\n    /// @param zapNative                ETH value to send to the recipient (if any)\n    /// @param zapData                  Parameters for the Zap to the destination recipient (if any)\n    struct BridgeParamsV2 {\n        address quoteRelayer;\n        int256 quoteExclusivitySeconds;\n        bytes quoteId;\n        uint256 zapNative;\n        bytes zapData;\n    }\n\n    /// @notice Updated bridge transaction struct to include parameters introduced in FastBridgeV2.\n    /// Note: only `exclusivityRelayer` can fill such a transaction until `exclusivityEndTime`.\n    struct BridgeTransactionV2 {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        // Note: sendChainGas flag from V1 is deprecated\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n        address exclusivityRelayer;\n        uint256 exclusivityEndTime;\n        uint256 zapNative; // ETH value to send to the recipient (if any)\n        bytes zapData; // data to pass for the Zap action (if any)\n    }\n\n    event BridgeQuoteDetails(bytes32 indexed transactionId, bytes quoteId);\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability\n    /// to provide temporary exclusivity fill rights for the quote relayer.\n    /// @param params   The parameters required to bridge\n    /// @param paramsV2 The parameters for exclusivity fill rights (optional, can be left empty)\n    function bridge(BridgeParams memory params, BridgeParamsV2 memory paramsV2) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function relay(bytes memory request, address relayer) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to prove\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function prove(bytes32 transactionId, bytes32 destTxHash, address relayer) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital.\n    /// @notice Can only send funds to the relayer address on the proof.\n    /// @param request The encoded bridge transaction to claim on origin chain\n    function claim(bytes memory request) external;\n    /// @notice Checks if a transaction has been relayed\n    /// @param transactionId The ID of the transaction to check\n    /// @return True if the transaction has been relayed, false otherwise\n    function bridgeRelays(bytes32 transactionId) external view returns (bool);\n\n    /// @notice Returns the status of a bridge transaction\n    /// @param transactionId The ID of the bridge transaction\n    /// @return BridgeStatus Status of the bridge transaction\n    function bridgeStatuses(bytes32 transactionId) external view returns (BridgeStatus);\n\n    /// @notice Returns the timestamp and relayer of a bridge proof\n    /// @param transactionId The ID of the bridge transaction\n    /// @return timestamp The timestamp of the bridge proof\n    /// @return relayer The relayer address of the bridge proof\n    function bridgeProofs(bytes32 transactionId) external view returns (uint96 timestamp, address relayer);\n\n    /// @notice Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2\n    /// @param request The bridge request to decode\n    function getBridgeTransactionV2(bytes memory request) external view returns (BridgeTransactionV2 memory);\n}\n\n// contracts/libs/BridgeTransactionV2.sol\n\n// solhint-disable no-inline-assembly\nlibrary BridgeTransactionV2Lib {\n    uint16 internal constant VERSION = 2;\n\n    // Offsets of the fields in the packed BridgeTransactionV2 struct\n    // uint16   version                 [000 .. 002)\n    // uint32   originChainId           [002 .. 006)\n    // uint32   destChainId             [006 .. 010)\n    // address  originSender            [010 .. 030)\n    // address  destRecipient           [030 .. 050)\n    // address  originToken             [050 .. 070)\n    // address  destToken               [070 .. 090)\n    // uint256  originAmount            [090 .. 122)\n    // uint256  destAmount              [122 .. 154)\n    // uint256  originFeeAmount         [154 .. 186)\n    // uint256  deadline                [186 .. 218)\n    // uint256  nonce                   [218 .. 250)\n    // address  exclusivityRelayer      [250 .. 270)\n    // uint256  exclusivityEndTime      [270 .. 302)\n    // uint256  zapNative               [302 .. 334)\n    // bytes    zapData                 [334 .. ***)\n\n    // forgefmt: disable-start\n    uint256 private constant OFFSET_ORIGIN_CHAIN_ID      = 2;\n    uint256 private constant OFFSET_DEST_CHAIN_ID        = 6;\n    uint256 private constant OFFSET_ORIGIN_SENDER        = 10;\n    uint256 private constant OFFSET_DEST_RECIPIENT       = 30;\n    uint256 private constant OFFSET_ORIGIN_TOKEN         = 50;\n    uint256 private constant OFFSET_DEST_TOKEN           = 70;\n    uint256 private constant OFFSET_ORIGIN_AMOUNT        = 90;\n    uint256 private constant OFFSET_DEST_AMOUNT          = 122;\n    uint256 private constant OFFSET_ORIGIN_FEE_AMOUNT    = 154;\n    uint256 private constant OFFSET_DEADLINE             = 186;\n    uint256 private constant OFFSET_NONCE                = 218;\n    uint256 private constant OFFSET_EXCLUSIVITY_RELAYER  = 250;\n    uint256 private constant OFFSET_EXCLUSIVITY_END_TIME = 270;\n    uint256 private constant OFFSET_ZAP_NATIVE           = 302;\n    uint256 private constant OFFSET_ZAP_DATA             = 334;\n    // forgefmt: disable-end\n\n    error BridgeTransactionV2__InvalidEncodedTx();\n    error BridgeTransactionV2__UnsupportedVersion(uint16 version);\n\n    /// @notice Validates the encoded transaction to be a tightly packed encoded payload for BridgeTransactionV2.\n    /// @dev Checks the minimum length and the version, use this function before decoding any of the fields.\n    function validateV2(bytes calldata encodedTx) internal pure {\n        // Check the minimum length: must at least include all static fields.\n        if (encodedTx.length \u003c OFFSET_ZAP_DATA) revert BridgeTransactionV2__InvalidEncodedTx();\n        // Once we validated the length, we can be sure that the version field is present.\n        uint16 version_ = version(encodedTx);\n        if (version_ != VERSION) revert BridgeTransactionV2__UnsupportedVersion(version_);\n    }\n\n    /// @notice Encodes the BridgeTransactionV2 struct by tightly packing the fields.\n    /// @dev `abi.decode` will not work as a result of the tightly packed fields. Use `decodeV2` to decode instead.\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) internal pure returns (bytes memory) {\n        // We split the encoding into two parts to avoid stack-too-deep error\n        bytes memory firstPart = abi.encodePacked(\n            VERSION,\n            bridgeTx.originChainId,\n            bridgeTx.destChainId,\n            bridgeTx.originSender,\n            bridgeTx.destRecipient,\n            bridgeTx.originToken,\n            bridgeTx.destToken,\n            bridgeTx.originAmount\n        );\n        return abi.encodePacked(\n            firstPart,\n            bridgeTx.destAmount,\n            bridgeTx.originFeeAmount,\n            // Note: we skip the deprecated `sendChainGas` flag, which was present in BridgeTransaction V1\n            bridgeTx.deadline,\n            bridgeTx.nonce,\n            // New V2 fields: exclusivity\n            bridgeTx.exclusivityRelayer,\n            bridgeTx.exclusivityEndTime,\n            // New V2 fields: Zap\n            bridgeTx.zapNative,\n            bridgeTx.zapData\n        );\n    }\n\n    /// @notice Decodes the BridgeTransactionV2 struct from the encoded transaction.\n    /// @dev Encoded BridgeTransactionV2 struct must be tightly packed.\n    /// Use `validateV2` before decoding to ensure the encoded transaction is valid.\n    function decodeV2(bytes calldata encodedTx)\n        internal\n        pure\n        returns (IFastBridgeV2.BridgeTransactionV2 memory bridgeTx)\n    {\n        bridgeTx.originChainId = originChainId(encodedTx);\n        bridgeTx.destChainId = destChainId(encodedTx);\n        bridgeTx.originSender = originSender(encodedTx);\n        bridgeTx.destRecipient = destRecipient(encodedTx);\n        bridgeTx.originToken = originToken(encodedTx);\n        bridgeTx.destToken = destToken(encodedTx);\n        bridgeTx.originAmount = originAmount(encodedTx);\n        bridgeTx.destAmount = destAmount(encodedTx);\n        bridgeTx.originFeeAmount = originFeeAmount(encodedTx);\n        bridgeTx.deadline = deadline(encodedTx);\n        bridgeTx.nonce = nonce(encodedTx);\n        bridgeTx.exclusivityRelayer = exclusivityRelayer(encodedTx);\n        bridgeTx.exclusivityEndTime = exclusivityEndTime(encodedTx);\n        bridgeTx.zapNative = zapNative(encodedTx);\n        bridgeTx.zapData = zapData(encodedTx);\n    }\n\n    /// @notice Extracts the version from the encoded transaction.\n    function version(bytes calldata encodedTx) internal pure returns (uint16 version_) {\n        // Load 32 bytes from the start and shift it 240 bits to the right to get the highest 16 bits.\n        assembly {\n            version_ := shr(240, calldataload(encodedTx.offset))\n        }\n    }\n\n    /// @notice Extracts the origin chain ID from the encoded transaction.\n    function originChainId(bytes calldata encodedTx) internal pure returns (uint32 originChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            originChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the destination chain ID from the encoded transaction.\n    function destChainId(bytes calldata encodedTx) internal pure returns (uint32 destChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            destChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_DEST_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the origin sender from the encoded transaction.\n    function originSender(bytes calldata encodedTx) internal pure returns (address originSender_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originSender_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_SENDER)))\n        }\n    }\n\n    /// @notice Extracts the destination recipient from the encoded transaction.\n    function destRecipient(bytes calldata encodedTx) internal pure returns (address destRecipient_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destRecipient_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_RECIPIENT)))\n        }\n    }\n\n    /// @notice Extracts the origin token from the encoded transaction.\n    function originToken(bytes calldata encodedTx) internal pure returns (address originToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the destination token from the encoded transaction.\n    function destToken(bytes calldata encodedTx) internal pure returns (address destToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the origin amount from the encoded transaction.\n    function originAmount(bytes calldata encodedTx) internal pure returns (uint256 originAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the destination amount from the encoded transaction.\n    function destAmount(bytes calldata encodedTx) internal pure returns (uint256 destAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            destAmount_ := calldataload(add(encodedTx.offset, OFFSET_DEST_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the origin fee amount from the encoded transaction.\n    function originFeeAmount(bytes calldata encodedTx) internal pure returns (uint256 originFeeAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originFeeAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_FEE_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the deadline from the encoded transaction.\n    function deadline(bytes calldata encodedTx) internal pure returns (uint256 deadline_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            deadline_ := calldataload(add(encodedTx.offset, OFFSET_DEADLINE))\n        }\n    }\n\n    /// @notice Extracts the nonce from the encoded transaction.\n    function nonce(bytes calldata encodedTx) internal pure returns (uint256 nonce_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            nonce_ := calldataload(add(encodedTx.offset, OFFSET_NONCE))\n        }\n    }\n\n    /// @notice Extracts the exclusivity relayer from the encoded transaction.\n    function exclusivityRelayer(bytes calldata encodedTx) internal pure returns (address exclusivityRelayer_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            exclusivityRelayer_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_RELAYER)))\n        }\n    }\n\n    /// @notice Extracts the exclusivity end time from the encoded transaction.\n    function exclusivityEndTime(bytes calldata encodedTx) internal pure returns (uint256 exclusivityEndTime_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            exclusivityEndTime_ := calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_END_TIME))\n        }\n    }\n\n    /// @notice Extracts the Zap's native value from the encoded transaction.\n    function zapNative(bytes calldata encodedTx) internal pure returns (uint256 zapNative_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            zapNative_ := calldataload(add(encodedTx.offset, OFFSET_ZAP_NATIVE))\n        }\n    }\n\n    /// @notice Extracts the Zap's data from the encoded transaction.\n    function zapData(bytes calldata encodedTx) internal pure returns (bytes calldata zapData_) {\n        zapData_ = encodedTx[OFFSET_ZAP_DATA:];\n    }\n}\n\n// test/harnesses/BridgeTransactionV2Harness.sol\n\ncontract BridgeTransactionV2Harness {\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) public pure returns (bytes memory) {\n        return BridgeTransactionV2Lib.encodeV2(bridgeTx);\n    }\n\n    function decodeV2(bytes calldata encodedTx) public pure returns (IFastBridgeV2.BridgeTransactionV2 memory) {\n        return BridgeTransactionV2Lib.decodeV2(encodedTx);\n    }\n\n    function version(bytes calldata encodedTx) public pure returns (uint16) {\n        return BridgeTransactionV2Lib.version(encodedTx);\n    }\n\n    function originChainId(bytes calldata encodedTx) public pure returns (uint32) {\n        return BridgeTransactionV2Lib.originChainId(encodedTx);\n    }\n\n    function destChainId(bytes calldata encodedTx) public pure returns (uint32) {\n        return BridgeTransactionV2Lib.destChainId(encodedTx);\n    }\n\n    function originSender(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.originSender(encodedTx);\n    }\n\n    function destRecipient(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.destRecipient(encodedTx);\n    }\n\n    function originToken(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.originToken(encodedTx);\n    }\n\n    function destToken(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.destToken(encodedTx);\n    }\n\n    function originAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.originAmount(encodedTx);\n    }\n\n    function destAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.destAmount(encodedTx);\n    }\n\n    function originFeeAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.originFeeAmount(encodedTx);\n    }\n\n    function zapNative(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.zapNative(encodedTx);\n    }\n\n    function deadline(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.deadline(encodedTx);\n    }\n\n    function nonce(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.nonce(encodedTx);\n    }\n\n    function exclusivityRelayer(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.exclusivityRelayer(encodedTx);\n    }\n\n    function exclusivityEndTime(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.exclusivityEndTime(encodedTx);\n    }\n\n    function zapData(bytes calldata encodedTx) public pure returns (bytes calldata) {\n        return BridgeTransactionV2Lib.zapData(encodedTx);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.24","compilerVersion":"0.8.24","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"21499:2832:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"21499:2832:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;24184:145;;;;;;:::i;:::-;;:::i;:::-;;;;;;;;:::i;:::-;;;;;;;;23108:144;;;;;;:::i;:::-;;:::i;:::-;;;1208:25:1;;;1196:2;1181:18;23108:144:0;1062:177:1;23418:142:0;;;;;;:::i;:::-;;:::i;21716:173::-;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;22806:142::-;;;;;;:::i;:::-;;:::i;:::-;;;4108:42:1;4096:55;;;4078:74;;4066:2;4051:18;22806:142:0;3932:226:1;23712:134:0;;;;;;:::i;:::-;;:::i;22193:145::-;;;;;;:::i;:::-;;:::i;:::-;;;4337:10:1;4325:23;;;4307:42;;4295:2;4280:18;22193:145:0;4163:192:1;24018:160:0;;;;;;:::i;:::-;;:::i;22954:148::-;;;;;;:::i;:::-;;:::i;21895:137::-;;;;;;:::i;:::-;;:::i;:::-;;;4534:6:1;4522:19;;;4504:38;;4492:2;4477:18;21895:137:0;4360:188:1;22654:146:0;;;;;;:::i;:::-;;:::i;22038:149::-;;;;;;:::i;:::-;;:::i;22344:148::-;;;;;;:::i;:::-;;:::i;22498:150::-;;;;;;:::i;:::-;;:::i;23852:160::-;;;;;;:::i;:::-;;:::i;23566:140::-;;;;;;:::i;:::-;;:::i;23258:154::-;;;;;;:::i;:::-;;:::i;21541:169::-;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;24184:145::-;24248:14;;24281:41;24312:9;;24281:30;:41::i;:::-;24274:48;;;;24184:145;;;;;:::o;23108:144::-;23175:7;18820:18;18798:41;;18785:55;23201:44;23194:51;23108:144;-1:-1:-1;;;23108:144:0:o;23418:142::-;23484:7;21188:17;21166:40;;21153:54;23510:43;20925:298;21716:173;21781:40;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;21781:40:0;21840:42;21872:9;;21840:31;:42::i;22806:142::-;22872:7;18045:17;18023:40;;18010:54;18006:2;18002:63;22898:43;17763:318;23712:134;23774:7;19951:12;19929:35;;19916:49;23800:39;19700:281;22193:145;22261:6;16407:20;16385:43;;16372:57;16367:3;16363:67;22286:45;16119:327;24018:160;24093:7;20796:27;20774:50;;20761:64;24119:52;20506:335;22954:148;23023:7;18432:20;18410:43;;18397:57;23049:46;18160:310;21895:137;21959:6;15570:30;;15565:3;15561:40;21984:41;15330:287;22654:146;22722:7;17642:19;17620:42;;17607:56;17603:2;17599:65;22748:45;17354:326;22038:149;22108:6;15992:22;15970:45;;15957:59;15952:3;15948:69;22133:47;15698:335;22344:148;22413:7;16816:20;16794:43;;16781:57;16777:2;16773:66;22439:46;16525:330;22498:150;22568:7;17236:21;17214:44;;17201:58;17197:2;17193:67;22594:47;16942:334;23852:160;23927:7;20375:26;20353:49;;20340:63;20336:2;20332:72;23953:52;20066:354;23566:140;23631:7;19596:15;19574:38;;19561:52;23657:42;19336:293;23258:154;23330:7;19220:24;19198:47;;19185:61;23356:49;18939:323;21541:169;21631:12;21662:41;21694:8;21662:31;:41::i;:::-;21655:48;21541:169;-1:-1:-1;;21541:169:0:o;21299:146::-;21365:23;;21411:27;:9;11923:3;21411:9;;:27;:::i;14267:990::-;14358:49;-1:-1:-1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;14358:49:0;15992:22;15970:45;;15957:59;15952:3;15948:69;;;14423:49;;16407:20;16385:43;;16372:57;16363:67;;14482:20;;;:45;16816:20;16794:43;;16781:57;16777:2;16773:66;;;14537:21;;;:47;17236:21;17214:44;;17201:58;17193:67;;14594:22;;;:49;17642:19;17620:42;;17607:56;17599:65;;14653:20;;;:45;18045:17;18023:40;;18010:54;18002:63;;14708:18;;;:41;18432:20;18410:43;;18397:57;14759:21;;;:47;18820:18;18798:41;;18785:55;14816:19;;;:43;;;;19220:24;19198:47;;19185:61;14869:24;;;:53;19596:15;19574:38;;19561:52;14932:17;;;:39;19951:12;19929:35;;19916:49;14981:14;;;:33;20375:26;20353:49;;20340:63;20332:72;;15024:27;;;:59;20796:27;20774:50;;20761:64;15093:27;;;:59;21188:17;21166:40;;21153:54;15162:18;;;:41;15232:18;15970:45;15240:9;15232:7;:18::i;:::-;15213:37;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;15213:16:0;;;:37;:8;14267:990;-1:-1:-1;;14267:990:0:o;12981:1038::-;13251:22;;13287:20;;;;;13321:21;;;;;13073:12;13356:22;;;;13392:20;;;;13426:18;;;;13458:21;;;;13200:289;;8676:16:1;13200:289:0;;;8660:102:1;;;;8781:66;8884:3;8880:16;;;8876:25;;8863:11;;;8856:46;8935:16;;;;8931:25;;;8918:11;;;8911:46;8976:66;9076:15;;;9072:24;;9058:12;;;9051:46;9131:15;;9127:24;;9113:12;;;9106:46;9186:15;;;9182:24;;9168:12;;;9161:46;9241:15;;;9237:24;;;9223:12;;;9216:46;9278:12;;;9271:28;;;;13175:22:0;;9315:13:1;;13200:289:0;;;;;;;;;;;;;;13559:19;;;;13592:24;;;;13737:17;;;;13768:14;;;;13838:27;;;;13879;;;;13954:18;;;;13986:16;;;;13200:289;;-1:-1:-1;13506:506:0;;13200:289;;13986:16;13200:289;13506:506;;:::i;:::-;;;;;;;;;;;;;13499:513;;;12981:1038;;;:::o;14:591:1:-;84:6;92;145:2;133:9;124:7;120:23;116:32;113:52;;;161:1;158;151:12;113:52;201:9;188:23;230:18;271:2;263:6;260:14;257:34;;;287:1;284;277:12;257:34;325:6;314:9;310:22;300:32;;370:7;363:4;359:2;355:13;351:27;341:55;;392:1;389;382:12;341:55;432:2;419:16;458:2;450:6;447:14;444:34;;;474:1;471;464:12;444:34;519:7;514:2;505:6;501:2;497:15;493:24;490:37;487:57;;;540:1;537;530:12;487:57;571:2;563:11;;;;;593:6;;-1:-1:-1;14:591:1;;-1:-1:-1;;;;14:591:1:o;610:447::-;767:2;756:9;749:21;806:6;801:2;790:9;786:18;779:34;863:6;855;850:2;839:9;835:18;822:48;919:1;890:22;;;914:2;886:31;;;879:42;;;;973:2;961:15;;;978:66;957:88;942:104;938:113;;610:447;-1:-1:-1;610:447:1:o;1475:250::-;1560:1;1570:113;1584:6;1581:1;1578:13;1570:113;;;1660:11;;;1654:18;1641:11;;;1634:39;1606:2;1599:10;1570:113;;;-1:-1:-1;;1717:1:1;1699:16;;1692:27;1475:250::o;1730:329::-;1771:3;1809:5;1803:12;1836:6;1831:3;1824:19;1852:76;1921:6;1914:4;1909:3;1905:14;1898:4;1891:5;1887:16;1852:76;:::i;:::-;1973:2;1961:15;1978:66;1957:88;1948:98;;;;2048:4;1944:109;;1730:329;-1:-1:-1;;1730:329:1:o;2064:1863::-;2265:2;2254:9;2247:21;2277:52;2325:2;2314:9;2310:18;2301:6;2295:13;1320:10;1309:22;1297:35;;1244:94;2277:52;2228:4;2376:2;2368:6;2364:15;2358:22;2389:51;2436:2;2425:9;2421:18;2407:12;1320:10;1309:22;1297:35;;1244:94;2389:51;-1:-1:-1;2489:2:1;2477:15;;2471:22;1420:42;1409:54;;2552:2;2537:18;;1397:67;-1:-1:-1;2605:2:1;2593:15;;2587:22;1420:42;1409:54;;2668:3;2653:19;;1397:67;-1:-1:-1;2722:3:1;2710:16;;2704:23;1420:42;1409:54;;2786:3;2771:19;;1397:67;-1:-1:-1;2840:3:1;2828:16;;2822:23;1420:42;1409:54;;2904:3;2889:19;;1397:67;-1:-1:-1;2964:3:1;2952:16;;2946:23;2940:3;2925:19;;;2918:52;;;;2995:16;;2989:23;3031:3;3050:18;;;3043:30;;;;3098:15;;3092:22;3133:3;3152:18;;;3145:30;;;;3200:15;;3194:22;3235:3;3254:18;;;3247:30;;;;3302:15;;3296:22;3337:3;3356:18;;;3349:30;;;;3416:15;;3410:22;3451:3;3463:54;3498:18;;;3410:22;1420:42;1409:54;1397:67;;1343:127;3463:54;3543:15;;3537:22;3579:3;3598:19;;;3591:32;;;;3649:16;;3643:23;3686:3;3705:19;;;3698:32;;;;3767:16;;3761:23;3804:6;3826:19;;;3819:32;3761:23;-1:-1:-1;3868:53:1;3916:3;3901:19;;3761:23;3868:53;:::i;:::-;3860:61;2064:1863;-1:-1:-1;;;;2064:1863:1:o;4553:184::-;4605:77;4602:1;4595:88;4702:4;4699:1;4692:15;4726:4;4723:1;4716:15;4742:250;4809:2;4803:9;4851:6;4839:19;;4888:18;4873:34;;4909:22;;;4870:62;4867:88;;;4935:18;;:::i;:::-;4971:2;4964:22;4742:250;:::o;4997:163::-;5064:20;;5124:10;5113:22;;5103:33;;5093:61;;5150:1;5147;5140:12;5093:61;4997:163;;;:::o;5165:196::-;5233:20;;5293:42;5282:54;;5272:65;;5262:93;;5351:1;5348;5341:12;5366:777;5408:5;5461:3;5454:4;5446:6;5442:17;5438:27;5428:55;;5479:1;5476;5469:12;5428:55;5515:6;5502:20;5541:18;5578:2;5574;5571:10;5568:36;;;5584:18;;:::i;:::-;5718:2;5712:9;5780:4;5772:13;;5623:66;5768:22;;;5792:2;5764:31;5760:40;5748:53;;;5816:18;;;5836:22;;;5813:46;5810:72;;;5862:18;;:::i;:::-;5902:10;5898:2;5891:22;5937:2;5929:6;5922:18;5983:3;5976:4;5971:2;5963:6;5959:15;5955:26;5952:35;5949:55;;;6000:1;5997;5990:12;5949:55;6064:2;6057:4;6049:6;6045:17;6038:4;6030:6;6026:17;6013:54;6111:1;6104:4;6099:2;6091:6;6087:15;6083:26;6076:37;6131:6;6122:15;;;;;;5366:777;;;;:::o;6148:1630::-;6243:6;6296:2;6284:9;6275:7;6271:23;6267:32;6264:52;;;6312:1;6309;6302:12;6264:52;6352:9;6339:23;6381:18;6422:2;6414:6;6411:14;6408:34;;;6438:1;6435;6428:12;6408:34;6461:22;;;;6517:6;6499:16;;;6495:29;6492:49;;;6537:1;6534;6527:12;6492:49;6563:17;;:::i;:::-;6603:21;6621:2;6603:21;:::i;:::-;6596:5;6589:36;6657:30;6683:2;6679;6675:11;6657:30;:::i;:::-;6652:2;6645:5;6641:14;6634:54;6720:31;6747:2;6743;6739:11;6720:31;:::i;:::-;6715:2;6708:5;6704:14;6697:55;6784:31;6811:2;6807;6803:11;6784:31;:::i;:::-;6779:2;6772:5;6768:14;6761:55;6849:32;6876:3;6872:2;6868:12;6849:32;:::i;:::-;6843:3;6836:5;6832:15;6825:57;6915:32;6942:3;6938:2;6934:12;6915:32;:::i;:::-;6909:3;6898:15;;6891:57;7002:3;6994:12;;;6981:26;6964:15;;;6957:51;7062:3;7054:12;;;7041:26;7024:15;;;7017:51;7087:3;7135:11;;;7122:25;7106:14;;;7099:49;7167:3;7215:11;;;7202:25;7186:14;;;7179:49;7247:3;7295:11;;;7282:25;7266:14;;;7259:49;7327:3;7362:31;7381:11;;;7362:31;:::i;:::-;7346:14;;;7339:55;7413:3;7461:11;;;7448:25;7432:14;;;7425:49;7493:3;7541:11;;;7528:25;7512:14;;;7505:49;7573:3;7614:11;;;7601:25;7638:16;;;7635:36;;;7667:1;7664;7657:12;7635:36;7703:44;7739:7;7728:8;7724:2;7720:17;7703:44;:::i;:::-;7687:14;;;7680:68;;;;-1:-1:-1;7691:5:1;6148:1630;-1:-1:-1;;;;;6148:1630:1:o;7783:217::-;7930:2;7919:9;7912:21;7893:4;7950:44;7990:2;7979:9;7975:18;7967:6;7950:44;:::i;8005:331::-;8110:9;8121;8163:8;8151:10;8148:24;8145:44;;;8185:1;8182;8175:12;8145:44;8214:6;8204:8;8201:20;8198:40;;;8234:1;8231;8224:12;8198:40;-1:-1:-1;;8260:23:1;;;8305:25;;;;;-1:-1:-1;8005:331:1:o;9339:1059::-;9710:3;9748:6;9742:13;9764:66;9823:6;9818:3;9811:4;9803:6;9799:17;9764:66;:::i;:::-;9861:6;9856:3;9852:16;9839:29;;9891:6;9884:5;9877:21;9932:6;9925:4;9918:5;9914:16;9907:32;9971:6;9966:2;9959:5;9955:14;9948:30;10010:6;10005:2;9998:5;9994:14;9987:30;10071:66;10062:6;10058:2;10054:15;10050:88;10044:3;10037:5;10033:15;10026:113;10172:6;10166:3;10159:5;10155:15;10148:31;10212:6;10206:3;10199:5;10195:15;10188:31;10250:6;10244:13;10266:80;10337:8;10331:3;10324:5;10320:15;10313:4;10305:6;10301:17;10266:80;:::i;:::-;10366:20;10388:3;10362:30;;9339:1059;-1:-1:-1;;;;;;;;;;;9339:1059:1:o","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"deadline","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"decodeV2","outputs":[{"components":[{"internalType":"uint32","name":"originChainId","type":"uint32"},{"internalType":"uint32","name":"destChainId","type":"uint32"},{"internalType":"address","name":"originSender","type":"address"},{"internalType":"address","name":"destRecipient","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"originFeeAmount","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"address","name":"exclusivityRelayer","type":"address"},{"internalType":"uint256","name":"exclusivityEndTime","type":"uint256"},{"internalType":"uint256","name":"zapNative","type":"uint256"},{"internalType":"bytes","name":"zapData","type":"bytes"}],"internalType":"struct IFastBridgeV2.BridgeTransactionV2","name":"","type":"tuple"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"destAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"destChainId","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"destRecipient","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"destToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"components":[{"internalType":"uint32","name":"originChainId","type":"uint32"},{"internalType":"uint32","name":"destChainId","type":"uint32"},{"internalType":"address","name":"originSender","type":"address"},{"internalType":"address","name":"destRecipient","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"originFeeAmount","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"address","name":"exclusivityRelayer","type":"address"},{"internalType":"uint256","name":"exclusivityEndTime","type":"uint256"},{"internalType":"uint256","name":"zapNative","type":"uint256"},{"internalType":"bytes","name":"zapData","type":"bytes"}],"internalType":"struct IFastBridgeV2.BridgeTransactionV2","name":"bridgeTx","type":"tuple"}],"name":"encodeV2","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"exclusivityEndTime","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"exclusivityRelayer","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"nonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"originAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"originChainId","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"originFeeAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"originSender","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"originToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"version","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"zapData","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"encodedTx","type":"bytes"}],"name":"zapNative","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"deadline\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"decodeV2\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"originSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusivityRelayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exclusivityEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zapNative\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"zapData\",\"type\":\"bytes\"}],\"internalType\":\"struct IFastBridgeV2.BridgeTransactionV2\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"destAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"destChainId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"destRecipient\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"destToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"originSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusivityRelayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exclusivityEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zapNative\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"zapData\",\"type\":\"bytes\"}],\"internalType\":\"struct IFastBridgeV2.BridgeTransactionV2\",\"name\":\"bridgeTx\",\"type\":\"tuple\"}],\"name\":\"encodeV2\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"exclusivityEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"exclusivityRelayer\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"originAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"originChainId\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"originFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"originSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"originToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"version\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"zapData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"encodedTx\",\"type\":\"bytes\"}],\"name\":\"zapNative\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/BridgeTransactionV2Harness.sol\":\"BridgeTransactionV2Harness\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/BridgeTransactionV2Harness.sol\":{\"keccak256\":\"0x163fc97efd1365765820c3f01e2d17aa275f32bfbdcd651602808861111a7c00\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3fbd6475c98b3c1c7e4492e7a59c79a87cc991b403cefd1ac3a980afe441419e\",\"dweb:/ipfs/QmTCQazGcsUMZXtHLFXHwg3Nmc3xFxxFWZ4KY6qXTWpmPx\"]}},\"version\":1}"},"hashes":{"deadline(bytes)":"e79f1782","decodeV2(bytes)":"24657024","destAmount(bytes)":"12d0c512","destChainId(bytes)":"5c3fa4c0","destRecipient(bytes)":"9c538802","destToken(bytes)":"37518e50","encodeV2((uint32,uint32,address,address,address,address,uint256,uint256,uint256,uint256,uint256,address,uint256,uint256,bytes))":"faef535a","exclusivityEndTime(bytes)":"6907efd7","exclusivityRelayer(bytes)":"dcafa970","nonce(bytes)":"4e765004","originAmount(bytes)":"7241b9cb","originChainId(bytes)":"93bb0d80","originFeeAmount(bytes)":"e938730e","originSender(bytes)":"9bdb46fe","originToken(bytes)":"93832899","version(bytes)":"7d67c5a7","zapData(bytes)":"0af3f403","zapNative(bytes)":"230602c1"}},"solidity/BridgeTransactionV2Harness.sol:BridgeTransactionV2Lib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220da262e011b1740fc866d94ce46470fa9e1d5daf267ae4e8119df1dcd7edab25964736f6c63430008180033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220da262e011b1740fc866d94ce46470fa9e1d5daf267ae4e8119df1dcd7edab25964736f6c63430008180033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.24 ^0.8.4;\n\n// contracts/interfaces/IFastBridge.sol\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        bool sendChainGas;\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(\n        bytes32 indexed transactionId,\n        address indexed sender,\n        bytes request,\n        uint32 destChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        bool sendChainGas\n    );\n    event BridgeRelayed(\n        bytes32 indexed transactionId,\n        address indexed relayer,\n        address indexed to,\n        uint32 originChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        uint256 chainGasAmount\n    );\n    event BridgeProofProvided(bytes32 indexed transactionId, address indexed relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 indexed transactionId, address indexed relayer);\n    event BridgeDepositClaimed(\n        bytes32 indexed transactionId, address indexed relayer, address indexed to, address token, uint256 amount\n    );\n    event BridgeDepositRefunded(bytes32 indexed transactionId, address indexed to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address sender;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount; // should include protocol fee (if any)\n        uint256 destAmount; // should include relayer fee\n        bool sendChainGas;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    function refund(bytes memory request) external;\n\n    // ============ Views ============\n\n    /// @notice Decodes bridge request into a bridge transaction\n    /// @param request The bridge request to decode\n    function getBridgeTransaction(bytes memory request) external view returns (BridgeTransaction memory);\n\n    /// @notice Checks if the dispute period has passed so bridge deposit can be claimed\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to check\n    /// @param relayer The address of the relayer attempting to claim\n    function canClaim(bytes32 transactionId, address relayer) external view returns (bool);\n}\n\n// contracts/interfaces/IFastBridgeV2.sol\n\ninterface IFastBridgeV2 is IFastBridge {\n    enum BridgeStatus {\n        NULL, // doesn't exist yet\n        REQUESTED,\n        RELAYER_PROVED,\n        RELAYER_CLAIMED,\n        REFUNDED\n    }\n\n    struct BridgeTxDetails {\n        BridgeStatus status;\n        uint32 destChainId;\n        uint56 proofBlockTimestamp;\n        address proofRelayer;\n    }\n\n    struct BridgeRelay {\n        uint48 blockNumber;\n        uint48 blockTimestamp;\n        address relayer;\n    }\n\n    /// @notice New params introduced in the FastBridgeV2.\n    /// We are passing fields from the older BridgeParams struct outside of this struct\n    /// for backwards compatibility.\n    /// Note: quoteRelayer and quoteExclusivitySeconds are either both zero (indicating no exclusivity)\n    /// or both non-zero (indicating exclusivity for the given period).\n    /// Note: zapNative \u003e 0 can NOT be used with destToken = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE (native token)\n    /// @param quoteRelayer             Relayer that provided the quote for the transaction\n    /// @param quoteExclusivitySeconds  Period of time the quote relayer is guaranteed exclusivity after user's deposit\n    /// @param quoteId                  Unique quote identifier used for tracking the quote\n    /// @param zapNative                ETH value to send to the recipient (if any)\n    /// @param zapData                  Parameters for the Zap to the destination recipient (if any)\n    struct BridgeParamsV2 {\n        address quoteRelayer;\n        int256 quoteExclusivitySeconds;\n        bytes quoteId;\n        uint256 zapNative;\n        bytes zapData;\n    }\n\n    /// @notice Updated bridge transaction struct to include parameters introduced in FastBridgeV2.\n    /// Note: only `exclusivityRelayer` can fill such a transaction until `exclusivityEndTime`.\n    struct BridgeTransactionV2 {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        // Note: sendChainGas flag from V1 is deprecated\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n        address exclusivityRelayer;\n        uint256 exclusivityEndTime;\n        uint256 zapNative; // ETH value to send to the recipient (if any)\n        bytes zapData; // data to pass for the Zap action (if any)\n    }\n\n    event BridgeQuoteDetails(bytes32 indexed transactionId, bytes quoteId);\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability\n    /// to provide temporary exclusivity fill rights for the quote relayer.\n    /// @param params   The parameters required to bridge\n    /// @param paramsV2 The parameters for exclusivity fill rights (optional, can be left empty)\n    function bridge(BridgeParams memory params, BridgeParamsV2 memory paramsV2) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function relay(bytes memory request, address relayer) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to prove\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function prove(bytes32 transactionId, bytes32 destTxHash, address relayer) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital.\n    /// @notice Can only send funds to the relayer address on the proof.\n    /// @param request The encoded bridge transaction to claim on origin chain\n    function claim(bytes memory request) external;\n    /// @notice Checks if a transaction has been relayed\n    /// @param transactionId The ID of the transaction to check\n    /// @return True if the transaction has been relayed, false otherwise\n    function bridgeRelays(bytes32 transactionId) external view returns (bool);\n\n    /// @notice Returns the status of a bridge transaction\n    /// @param transactionId The ID of the bridge transaction\n    /// @return BridgeStatus Status of the bridge transaction\n    function bridgeStatuses(bytes32 transactionId) external view returns (BridgeStatus);\n\n    /// @notice Returns the timestamp and relayer of a bridge proof\n    /// @param transactionId The ID of the bridge transaction\n    /// @return timestamp The timestamp of the bridge proof\n    /// @return relayer The relayer address of the bridge proof\n    function bridgeProofs(bytes32 transactionId) external view returns (uint96 timestamp, address relayer);\n\n    /// @notice Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2\n    /// @param request The bridge request to decode\n    function getBridgeTransactionV2(bytes memory request) external view returns (BridgeTransactionV2 memory);\n}\n\n// contracts/libs/BridgeTransactionV2.sol\n\n// solhint-disable no-inline-assembly\nlibrary BridgeTransactionV2Lib {\n    uint16 internal constant VERSION = 2;\n\n    // Offsets of the fields in the packed BridgeTransactionV2 struct\n    // uint16   version                 [000 .. 002)\n    // uint32   originChainId           [002 .. 006)\n    // uint32   destChainId             [006 .. 010)\n    // address  originSender            [010 .. 030)\n    // address  destRecipient           [030 .. 050)\n    // address  originToken             [050 .. 070)\n    // address  destToken               [070 .. 090)\n    // uint256  originAmount            [090 .. 122)\n    // uint256  destAmount              [122 .. 154)\n    // uint256  originFeeAmount         [154 .. 186)\n    // uint256  deadline                [186 .. 218)\n    // uint256  nonce                   [218 .. 250)\n    // address  exclusivityRelayer      [250 .. 270)\n    // uint256  exclusivityEndTime      [270 .. 302)\n    // uint256  zapNative               [302 .. 334)\n    // bytes    zapData                 [334 .. ***)\n\n    // forgefmt: disable-start\n    uint256 private constant OFFSET_ORIGIN_CHAIN_ID      = 2;\n    uint256 private constant OFFSET_DEST_CHAIN_ID        = 6;\n    uint256 private constant OFFSET_ORIGIN_SENDER        = 10;\n    uint256 private constant OFFSET_DEST_RECIPIENT       = 30;\n    uint256 private constant OFFSET_ORIGIN_TOKEN         = 50;\n    uint256 private constant OFFSET_DEST_TOKEN           = 70;\n    uint256 private constant OFFSET_ORIGIN_AMOUNT        = 90;\n    uint256 private constant OFFSET_DEST_AMOUNT          = 122;\n    uint256 private constant OFFSET_ORIGIN_FEE_AMOUNT    = 154;\n    uint256 private constant OFFSET_DEADLINE             = 186;\n    uint256 private constant OFFSET_NONCE                = 218;\n    uint256 private constant OFFSET_EXCLUSIVITY_RELAYER  = 250;\n    uint256 private constant OFFSET_EXCLUSIVITY_END_TIME = 270;\n    uint256 private constant OFFSET_ZAP_NATIVE           = 302;\n    uint256 private constant OFFSET_ZAP_DATA             = 334;\n    // forgefmt: disable-end\n\n    error BridgeTransactionV2__InvalidEncodedTx();\n    error BridgeTransactionV2__UnsupportedVersion(uint16 version);\n\n    /// @notice Validates the encoded transaction to be a tightly packed encoded payload for BridgeTransactionV2.\n    /// @dev Checks the minimum length and the version, use this function before decoding any of the fields.\n    function validateV2(bytes calldata encodedTx) internal pure {\n        // Check the minimum length: must at least include all static fields.\n        if (encodedTx.length \u003c OFFSET_ZAP_DATA) revert BridgeTransactionV2__InvalidEncodedTx();\n        // Once we validated the length, we can be sure that the version field is present.\n        uint16 version_ = version(encodedTx);\n        if (version_ != VERSION) revert BridgeTransactionV2__UnsupportedVersion(version_);\n    }\n\n    /// @notice Encodes the BridgeTransactionV2 struct by tightly packing the fields.\n    /// @dev `abi.decode` will not work as a result of the tightly packed fields. Use `decodeV2` to decode instead.\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) internal pure returns (bytes memory) {\n        // We split the encoding into two parts to avoid stack-too-deep error\n        bytes memory firstPart = abi.encodePacked(\n            VERSION,\n            bridgeTx.originChainId,\n            bridgeTx.destChainId,\n            bridgeTx.originSender,\n            bridgeTx.destRecipient,\n            bridgeTx.originToken,\n            bridgeTx.destToken,\n            bridgeTx.originAmount\n        );\n        return abi.encodePacked(\n            firstPart,\n            bridgeTx.destAmount,\n            bridgeTx.originFeeAmount,\n            // Note: we skip the deprecated `sendChainGas` flag, which was present in BridgeTransaction V1\n            bridgeTx.deadline,\n            bridgeTx.nonce,\n            // New V2 fields: exclusivity\n            bridgeTx.exclusivityRelayer,\n            bridgeTx.exclusivityEndTime,\n            // New V2 fields: Zap\n            bridgeTx.zapNative,\n            bridgeTx.zapData\n        );\n    }\n\n    /// @notice Decodes the BridgeTransactionV2 struct from the encoded transaction.\n    /// @dev Encoded BridgeTransactionV2 struct must be tightly packed.\n    /// Use `validateV2` before decoding to ensure the encoded transaction is valid.\n    function decodeV2(bytes calldata encodedTx)\n        internal\n        pure\n        returns (IFastBridgeV2.BridgeTransactionV2 memory bridgeTx)\n    {\n        bridgeTx.originChainId = originChainId(encodedTx);\n        bridgeTx.destChainId = destChainId(encodedTx);\n        bridgeTx.originSender = originSender(encodedTx);\n        bridgeTx.destRecipient = destRecipient(encodedTx);\n        bridgeTx.originToken = originToken(encodedTx);\n        bridgeTx.destToken = destToken(encodedTx);\n        bridgeTx.originAmount = originAmount(encodedTx);\n        bridgeTx.destAmount = destAmount(encodedTx);\n        bridgeTx.originFeeAmount = originFeeAmount(encodedTx);\n        bridgeTx.deadline = deadline(encodedTx);\n        bridgeTx.nonce = nonce(encodedTx);\n        bridgeTx.exclusivityRelayer = exclusivityRelayer(encodedTx);\n        bridgeTx.exclusivityEndTime = exclusivityEndTime(encodedTx);\n        bridgeTx.zapNative = zapNative(encodedTx);\n        bridgeTx.zapData = zapData(encodedTx);\n    }\n\n    /// @notice Extracts the version from the encoded transaction.\n    function version(bytes calldata encodedTx) internal pure returns (uint16 version_) {\n        // Load 32 bytes from the start and shift it 240 bits to the right to get the highest 16 bits.\n        assembly {\n            version_ := shr(240, calldataload(encodedTx.offset))\n        }\n    }\n\n    /// @notice Extracts the origin chain ID from the encoded transaction.\n    function originChainId(bytes calldata encodedTx) internal pure returns (uint32 originChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            originChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the destination chain ID from the encoded transaction.\n    function destChainId(bytes calldata encodedTx) internal pure returns (uint32 destChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            destChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_DEST_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the origin sender from the encoded transaction.\n    function originSender(bytes calldata encodedTx) internal pure returns (address originSender_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originSender_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_SENDER)))\n        }\n    }\n\n    /// @notice Extracts the destination recipient from the encoded transaction.\n    function destRecipient(bytes calldata encodedTx) internal pure returns (address destRecipient_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destRecipient_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_RECIPIENT)))\n        }\n    }\n\n    /// @notice Extracts the origin token from the encoded transaction.\n    function originToken(bytes calldata encodedTx) internal pure returns (address originToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the destination token from the encoded transaction.\n    function destToken(bytes calldata encodedTx) internal pure returns (address destToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the origin amount from the encoded transaction.\n    function originAmount(bytes calldata encodedTx) internal pure returns (uint256 originAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the destination amount from the encoded transaction.\n    function destAmount(bytes calldata encodedTx) internal pure returns (uint256 destAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            destAmount_ := calldataload(add(encodedTx.offset, OFFSET_DEST_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the origin fee amount from the encoded transaction.\n    function originFeeAmount(bytes calldata encodedTx) internal pure returns (uint256 originFeeAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originFeeAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_FEE_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the deadline from the encoded transaction.\n    function deadline(bytes calldata encodedTx) internal pure returns (uint256 deadline_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            deadline_ := calldataload(add(encodedTx.offset, OFFSET_DEADLINE))\n        }\n    }\n\n    /// @notice Extracts the nonce from the encoded transaction.\n    function nonce(bytes calldata encodedTx) internal pure returns (uint256 nonce_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            nonce_ := calldataload(add(encodedTx.offset, OFFSET_NONCE))\n        }\n    }\n\n    /// @notice Extracts the exclusivity relayer from the encoded transaction.\n    function exclusivityRelayer(bytes calldata encodedTx) internal pure returns (address exclusivityRelayer_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            exclusivityRelayer_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_RELAYER)))\n        }\n    }\n\n    /// @notice Extracts the exclusivity end time from the encoded transaction.\n    function exclusivityEndTime(bytes calldata encodedTx) internal pure returns (uint256 exclusivityEndTime_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            exclusivityEndTime_ := calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_END_TIME))\n        }\n    }\n\n    /// @notice Extracts the Zap's native value from the encoded transaction.\n    function zapNative(bytes calldata encodedTx) internal pure returns (uint256 zapNative_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            zapNative_ := calldataload(add(encodedTx.offset, OFFSET_ZAP_NATIVE))\n        }\n    }\n\n    /// @notice Extracts the Zap's data from the encoded transaction.\n    function zapData(bytes calldata encodedTx) internal pure returns (bytes calldata zapData_) {\n        zapData_ = encodedTx[OFFSET_ZAP_DATA:];\n    }\n}\n\n// test/harnesses/BridgeTransactionV2Harness.sol\n\ncontract BridgeTransactionV2Harness {\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) public pure returns (bytes memory) {\n        return BridgeTransactionV2Lib.encodeV2(bridgeTx);\n    }\n\n    function decodeV2(bytes calldata encodedTx) public pure returns (IFastBridgeV2.BridgeTransactionV2 memory) {\n        return BridgeTransactionV2Lib.decodeV2(encodedTx);\n    }\n\n    function version(bytes calldata encodedTx) public pure returns (uint16) {\n        return BridgeTransactionV2Lib.version(encodedTx);\n    }\n\n    function originChainId(bytes calldata encodedTx) public pure returns (uint32) {\n        return BridgeTransactionV2Lib.originChainId(encodedTx);\n    }\n\n    function destChainId(bytes calldata encodedTx) public pure returns (uint32) {\n        return BridgeTransactionV2Lib.destChainId(encodedTx);\n    }\n\n    function originSender(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.originSender(encodedTx);\n    }\n\n    function destRecipient(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.destRecipient(encodedTx);\n    }\n\n    function originToken(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.originToken(encodedTx);\n    }\n\n    function destToken(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.destToken(encodedTx);\n    }\n\n    function originAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.originAmount(encodedTx);\n    }\n\n    function destAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.destAmount(encodedTx);\n    }\n\n    function originFeeAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.originFeeAmount(encodedTx);\n    }\n\n    function zapNative(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.zapNative(encodedTx);\n    }\n\n    function deadline(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.deadline(encodedTx);\n    }\n\n    function nonce(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.nonce(encodedTx);\n    }\n\n    function exclusivityRelayer(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.exclusivityRelayer(encodedTx);\n    }\n\n    function exclusivityEndTime(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.exclusivityEndTime(encodedTx);\n    }\n\n    function zapData(bytes calldata encodedTx) public pure returns (bytes calldata) {\n        return BridgeTransactionV2Lib.zapData(encodedTx);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.24","compilerVersion":"0.8.24","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"9951:11496:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;9951:11496:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"9951:11496:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"BridgeTransactionV2__InvalidEncodedTx","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"BridgeTransactionV2__UnsupportedVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BridgeTransactionV2__InvalidEncodedTx\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"BridgeTransactionV2__UnsupportedVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/BridgeTransactionV2Harness.sol\":\"BridgeTransactionV2Lib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/BridgeTransactionV2Harness.sol\":{\"keccak256\":\"0x163fc97efd1365765820c3f01e2d17aa275f32bfbdcd651602808861111a7c00\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3fbd6475c98b3c1c7e4492e7a59c79a87cc991b403cefd1ac3a980afe441419e\",\"dweb:/ipfs/QmTCQazGcsUMZXtHLFXHwg3Nmc3xFxxFWZ4KY6qXTWpmPx\"]}},\"version\":1}"},"hashes":{}},"solidity/BridgeTransactionV2Harness.sol:IFastBridge":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.24 ^0.8.4;\n\n// contracts/interfaces/IFastBridge.sol\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        bool sendChainGas;\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(\n        bytes32 indexed transactionId,\n        address indexed sender,\n        bytes request,\n        uint32 destChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        bool sendChainGas\n    );\n    event BridgeRelayed(\n        bytes32 indexed transactionId,\n        address indexed relayer,\n        address indexed to,\n        uint32 originChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        uint256 chainGasAmount\n    );\n    event BridgeProofProvided(bytes32 indexed transactionId, address indexed relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 indexed transactionId, address indexed relayer);\n    event BridgeDepositClaimed(\n        bytes32 indexed transactionId, address indexed relayer, address indexed to, address token, uint256 amount\n    );\n    event BridgeDepositRefunded(bytes32 indexed transactionId, address indexed to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address sender;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount; // should include protocol fee (if any)\n        uint256 destAmount; // should include relayer fee\n        bool sendChainGas;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    function refund(bytes memory request) external;\n\n    // ============ Views ============\n\n    /// @notice Decodes bridge request into a bridge transaction\n    /// @param request The bridge request to decode\n    function getBridgeTransaction(bytes memory request) external view returns (BridgeTransaction memory);\n\n    /// @notice Checks if the dispute period has passed so bridge deposit can be claimed\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to check\n    /// @param relayer The address of the relayer attempting to claim\n    function canClaim(bytes32 transactionId, address relayer) external view returns (bool);\n}\n\n// contracts/interfaces/IFastBridgeV2.sol\n\ninterface IFastBridgeV2 is IFastBridge {\n    enum BridgeStatus {\n        NULL, // doesn't exist yet\n        REQUESTED,\n        RELAYER_PROVED,\n        RELAYER_CLAIMED,\n        REFUNDED\n    }\n\n    struct BridgeTxDetails {\n        BridgeStatus status;\n        uint32 destChainId;\n        uint56 proofBlockTimestamp;\n        address proofRelayer;\n    }\n\n    struct BridgeRelay {\n        uint48 blockNumber;\n        uint48 blockTimestamp;\n        address relayer;\n    }\n\n    /// @notice New params introduced in the FastBridgeV2.\n    /// We are passing fields from the older BridgeParams struct outside of this struct\n    /// for backwards compatibility.\n    /// Note: quoteRelayer and quoteExclusivitySeconds are either both zero (indicating no exclusivity)\n    /// or both non-zero (indicating exclusivity for the given period).\n    /// Note: zapNative \u003e 0 can NOT be used with destToken = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE (native token)\n    /// @param quoteRelayer             Relayer that provided the quote for the transaction\n    /// @param quoteExclusivitySeconds  Period of time the quote relayer is guaranteed exclusivity after user's deposit\n    /// @param quoteId                  Unique quote identifier used for tracking the quote\n    /// @param zapNative                ETH value to send to the recipient (if any)\n    /// @param zapData                  Parameters for the Zap to the destination recipient (if any)\n    struct BridgeParamsV2 {\n        address quoteRelayer;\n        int256 quoteExclusivitySeconds;\n        bytes quoteId;\n        uint256 zapNative;\n        bytes zapData;\n    }\n\n    /// @notice Updated bridge transaction struct to include parameters introduced in FastBridgeV2.\n    /// Note: only `exclusivityRelayer` can fill such a transaction until `exclusivityEndTime`.\n    struct BridgeTransactionV2 {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        // Note: sendChainGas flag from V1 is deprecated\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n        address exclusivityRelayer;\n        uint256 exclusivityEndTime;\n        uint256 zapNative; // ETH value to send to the recipient (if any)\n        bytes zapData; // data to pass for the Zap action (if any)\n    }\n\n    event BridgeQuoteDetails(bytes32 indexed transactionId, bytes quoteId);\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability\n    /// to provide temporary exclusivity fill rights for the quote relayer.\n    /// @param params   The parameters required to bridge\n    /// @param paramsV2 The parameters for exclusivity fill rights (optional, can be left empty)\n    function bridge(BridgeParams memory params, BridgeParamsV2 memory paramsV2) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function relay(bytes memory request, address relayer) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to prove\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function prove(bytes32 transactionId, bytes32 destTxHash, address relayer) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital.\n    /// @notice Can only send funds to the relayer address on the proof.\n    /// @param request The encoded bridge transaction to claim on origin chain\n    function claim(bytes memory request) external;\n    /// @notice Checks if a transaction has been relayed\n    /// @param transactionId The ID of the transaction to check\n    /// @return True if the transaction has been relayed, false otherwise\n    function bridgeRelays(bytes32 transactionId) external view returns (bool);\n\n    /// @notice Returns the status of a bridge transaction\n    /// @param transactionId The ID of the bridge transaction\n    /// @return BridgeStatus Status of the bridge transaction\n    function bridgeStatuses(bytes32 transactionId) external view returns (BridgeStatus);\n\n    /// @notice Returns the timestamp and relayer of a bridge proof\n    /// @param transactionId The ID of the bridge transaction\n    /// @return timestamp The timestamp of the bridge proof\n    /// @return relayer The relayer address of the bridge proof\n    function bridgeProofs(bytes32 transactionId) external view returns (uint96 timestamp, address relayer);\n\n    /// @notice Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2\n    /// @param request The bridge request to decode\n    function getBridgeTransactionV2(bytes memory request) external view returns (BridgeTransactionV2 memory);\n}\n\n// contracts/libs/BridgeTransactionV2.sol\n\n// solhint-disable no-inline-assembly\nlibrary BridgeTransactionV2Lib {\n    uint16 internal constant VERSION = 2;\n\n    // Offsets of the fields in the packed BridgeTransactionV2 struct\n    // uint16   version                 [000 .. 002)\n    // uint32   originChainId           [002 .. 006)\n    // uint32   destChainId             [006 .. 010)\n    // address  originSender            [010 .. 030)\n    // address  destRecipient           [030 .. 050)\n    // address  originToken             [050 .. 070)\n    // address  destToken               [070 .. 090)\n    // uint256  originAmount            [090 .. 122)\n    // uint256  destAmount              [122 .. 154)\n    // uint256  originFeeAmount         [154 .. 186)\n    // uint256  deadline                [186 .. 218)\n    // uint256  nonce                   [218 .. 250)\n    // address  exclusivityRelayer      [250 .. 270)\n    // uint256  exclusivityEndTime      [270 .. 302)\n    // uint256  zapNative               [302 .. 334)\n    // bytes    zapData                 [334 .. ***)\n\n    // forgefmt: disable-start\n    uint256 private constant OFFSET_ORIGIN_CHAIN_ID      = 2;\n    uint256 private constant OFFSET_DEST_CHAIN_ID        = 6;\n    uint256 private constant OFFSET_ORIGIN_SENDER        = 10;\n    uint256 private constant OFFSET_DEST_RECIPIENT       = 30;\n    uint256 private constant OFFSET_ORIGIN_TOKEN         = 50;\n    uint256 private constant OFFSET_DEST_TOKEN           = 70;\n    uint256 private constant OFFSET_ORIGIN_AMOUNT        = 90;\n    uint256 private constant OFFSET_DEST_AMOUNT          = 122;\n    uint256 private constant OFFSET_ORIGIN_FEE_AMOUNT    = 154;\n    uint256 private constant OFFSET_DEADLINE             = 186;\n    uint256 private constant OFFSET_NONCE                = 218;\n    uint256 private constant OFFSET_EXCLUSIVITY_RELAYER  = 250;\n    uint256 private constant OFFSET_EXCLUSIVITY_END_TIME = 270;\n    uint256 private constant OFFSET_ZAP_NATIVE           = 302;\n    uint256 private constant OFFSET_ZAP_DATA             = 334;\n    // forgefmt: disable-end\n\n    error BridgeTransactionV2__InvalidEncodedTx();\n    error BridgeTransactionV2__UnsupportedVersion(uint16 version);\n\n    /// @notice Validates the encoded transaction to be a tightly packed encoded payload for BridgeTransactionV2.\n    /// @dev Checks the minimum length and the version, use this function before decoding any of the fields.\n    function validateV2(bytes calldata encodedTx) internal pure {\n        // Check the minimum length: must at least include all static fields.\n        if (encodedTx.length \u003c OFFSET_ZAP_DATA) revert BridgeTransactionV2__InvalidEncodedTx();\n        // Once we validated the length, we can be sure that the version field is present.\n        uint16 version_ = version(encodedTx);\n        if (version_ != VERSION) revert BridgeTransactionV2__UnsupportedVersion(version_);\n    }\n\n    /// @notice Encodes the BridgeTransactionV2 struct by tightly packing the fields.\n    /// @dev `abi.decode` will not work as a result of the tightly packed fields. Use `decodeV2` to decode instead.\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) internal pure returns (bytes memory) {\n        // We split the encoding into two parts to avoid stack-too-deep error\n        bytes memory firstPart = abi.encodePacked(\n            VERSION,\n            bridgeTx.originChainId,\n            bridgeTx.destChainId,\n            bridgeTx.originSender,\n            bridgeTx.destRecipient,\n            bridgeTx.originToken,\n            bridgeTx.destToken,\n            bridgeTx.originAmount\n        );\n        return abi.encodePacked(\n            firstPart,\n            bridgeTx.destAmount,\n            bridgeTx.originFeeAmount,\n            // Note: we skip the deprecated `sendChainGas` flag, which was present in BridgeTransaction V1\n            bridgeTx.deadline,\n            bridgeTx.nonce,\n            // New V2 fields: exclusivity\n            bridgeTx.exclusivityRelayer,\n            bridgeTx.exclusivityEndTime,\n            // New V2 fields: Zap\n            bridgeTx.zapNative,\n            bridgeTx.zapData\n        );\n    }\n\n    /// @notice Decodes the BridgeTransactionV2 struct from the encoded transaction.\n    /// @dev Encoded BridgeTransactionV2 struct must be tightly packed.\n    /// Use `validateV2` before decoding to ensure the encoded transaction is valid.\n    function decodeV2(bytes calldata encodedTx)\n        internal\n        pure\n        returns (IFastBridgeV2.BridgeTransactionV2 memory bridgeTx)\n    {\n        bridgeTx.originChainId = originChainId(encodedTx);\n        bridgeTx.destChainId = destChainId(encodedTx);\n        bridgeTx.originSender = originSender(encodedTx);\n        bridgeTx.destRecipient = destRecipient(encodedTx);\n        bridgeTx.originToken = originToken(encodedTx);\n        bridgeTx.destToken = destToken(encodedTx);\n        bridgeTx.originAmount = originAmount(encodedTx);\n        bridgeTx.destAmount = destAmount(encodedTx);\n        bridgeTx.originFeeAmount = originFeeAmount(encodedTx);\n        bridgeTx.deadline = deadline(encodedTx);\n        bridgeTx.nonce = nonce(encodedTx);\n        bridgeTx.exclusivityRelayer = exclusivityRelayer(encodedTx);\n        bridgeTx.exclusivityEndTime = exclusivityEndTime(encodedTx);\n        bridgeTx.zapNative = zapNative(encodedTx);\n        bridgeTx.zapData = zapData(encodedTx);\n    }\n\n    /// @notice Extracts the version from the encoded transaction.\n    function version(bytes calldata encodedTx) internal pure returns (uint16 version_) {\n        // Load 32 bytes from the start and shift it 240 bits to the right to get the highest 16 bits.\n        assembly {\n            version_ := shr(240, calldataload(encodedTx.offset))\n        }\n    }\n\n    /// @notice Extracts the origin chain ID from the encoded transaction.\n    function originChainId(bytes calldata encodedTx) internal pure returns (uint32 originChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            originChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the destination chain ID from the encoded transaction.\n    function destChainId(bytes calldata encodedTx) internal pure returns (uint32 destChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            destChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_DEST_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the origin sender from the encoded transaction.\n    function originSender(bytes calldata encodedTx) internal pure returns (address originSender_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originSender_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_SENDER)))\n        }\n    }\n\n    /// @notice Extracts the destination recipient from the encoded transaction.\n    function destRecipient(bytes calldata encodedTx) internal pure returns (address destRecipient_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destRecipient_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_RECIPIENT)))\n        }\n    }\n\n    /// @notice Extracts the origin token from the encoded transaction.\n    function originToken(bytes calldata encodedTx) internal pure returns (address originToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the destination token from the encoded transaction.\n    function destToken(bytes calldata encodedTx) internal pure returns (address destToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the origin amount from the encoded transaction.\n    function originAmount(bytes calldata encodedTx) internal pure returns (uint256 originAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the destination amount from the encoded transaction.\n    function destAmount(bytes calldata encodedTx) internal pure returns (uint256 destAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            destAmount_ := calldataload(add(encodedTx.offset, OFFSET_DEST_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the origin fee amount from the encoded transaction.\n    function originFeeAmount(bytes calldata encodedTx) internal pure returns (uint256 originFeeAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originFeeAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_FEE_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the deadline from the encoded transaction.\n    function deadline(bytes calldata encodedTx) internal pure returns (uint256 deadline_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            deadline_ := calldataload(add(encodedTx.offset, OFFSET_DEADLINE))\n        }\n    }\n\n    /// @notice Extracts the nonce from the encoded transaction.\n    function nonce(bytes calldata encodedTx) internal pure returns (uint256 nonce_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            nonce_ := calldataload(add(encodedTx.offset, OFFSET_NONCE))\n        }\n    }\n\n    /// @notice Extracts the exclusivity relayer from the encoded transaction.\n    function exclusivityRelayer(bytes calldata encodedTx) internal pure returns (address exclusivityRelayer_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            exclusivityRelayer_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_RELAYER)))\n        }\n    }\n\n    /// @notice Extracts the exclusivity end time from the encoded transaction.\n    function exclusivityEndTime(bytes calldata encodedTx) internal pure returns (uint256 exclusivityEndTime_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            exclusivityEndTime_ := calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_END_TIME))\n        }\n    }\n\n    /// @notice Extracts the Zap's native value from the encoded transaction.\n    function zapNative(bytes calldata encodedTx) internal pure returns (uint256 zapNative_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            zapNative_ := calldataload(add(encodedTx.offset, OFFSET_ZAP_NATIVE))\n        }\n    }\n\n    /// @notice Extracts the Zap's data from the encoded transaction.\n    function zapData(bytes calldata encodedTx) internal pure returns (bytes calldata zapData_) {\n        zapData_ = encodedTx[OFFSET_ZAP_DATA:];\n    }\n}\n\n// test/harnesses/BridgeTransactionV2Harness.sol\n\ncontract BridgeTransactionV2Harness {\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) public pure returns (bytes memory) {\n        return BridgeTransactionV2Lib.encodeV2(bridgeTx);\n    }\n\n    function decodeV2(bytes calldata encodedTx) public pure returns (IFastBridgeV2.BridgeTransactionV2 memory) {\n        return BridgeTransactionV2Lib.decodeV2(encodedTx);\n    }\n\n    function version(bytes calldata encodedTx) public pure returns (uint16) {\n        return BridgeTransactionV2Lib.version(encodedTx);\n    }\n\n    function originChainId(bytes calldata encodedTx) public pure returns (uint32) {\n        return BridgeTransactionV2Lib.originChainId(encodedTx);\n    }\n\n    function destChainId(bytes calldata encodedTx) public pure returns (uint32) {\n        return BridgeTransactionV2Lib.destChainId(encodedTx);\n    }\n\n    function originSender(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.originSender(encodedTx);\n    }\n\n    function destRecipient(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.destRecipient(encodedTx);\n    }\n\n    function originToken(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.originToken(encodedTx);\n    }\n\n    function destToken(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.destToken(encodedTx);\n    }\n\n    function originAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.originAmount(encodedTx);\n    }\n\n    function destAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.destAmount(encodedTx);\n    }\n\n    function originFeeAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.originFeeAmount(encodedTx);\n    }\n\n    function zapNative(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.zapNative(encodedTx);\n    }\n\n    function deadline(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.deadline(encodedTx);\n    }\n\n    function nonce(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.nonce(encodedTx);\n    }\n\n    function exclusivityRelayer(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.exclusivityRelayer(encodedTx);\n    }\n\n    function exclusivityEndTime(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.exclusivityEndTime(encodedTx);\n    }\n\n    function zapData(bytes calldata encodedTx) public pure returns (bytes calldata) {\n        return BridgeTransactionV2Lib.zapData(encodedTx);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.24","compilerVersion":"0.8.24","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositRefunded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"}],"name":"BridgeProofDisputed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"bytes32","name":"transactionHash","type":"bytes32"}],"name":"BridgeProofProvided","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint32","name":"originChainId","type":"uint32"},{"indexed":false,"internalType":"address","name":"originToken","type":"address"},{"indexed":false,"internalType":"address","name":"destToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"originAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"destAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"chainGasAmount","type":"uint256"}],"name":"BridgeRelayed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"request","type":"bytes"},{"indexed":false,"internalType":"uint32","name":"destChainId","type":"uint32"},{"indexed":false,"internalType":"address","name":"originToken","type":"address"},{"indexed":false,"internalType":"address","name":"destToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"originAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"destAmount","type":"uint256"},{"indexed":false,"internalType":"bool","name":"sendChainGas","type":"bool"}],"name":"BridgeRequested","type":"event"},{"inputs":[{"components":[{"internalType":"uint32","name":"dstChainId","type":"uint32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"bool","name":"sendChainGas","type":"bool"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct IFastBridge.BridgeParams","name":"params","type":"tuple"}],"name":"bridge","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"address","name":"relayer","type":"address"}],"name":"canClaim","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"address","name":"to","type":"address"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"dispute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"getBridgeTransaction","outputs":[{"components":[{"internalType":"uint32","name":"originChainId","type":"uint32"},{"internalType":"uint32","name":"destChainId","type":"uint32"},{"internalType":"address","name":"originSender","type":"address"},{"internalType":"address","name":"destRecipient","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"originFeeAmount","type":"uint256"},{"internalType":"bool","name":"sendChainGas","type":"bool"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"}],"internalType":"struct IFastBridge.BridgeTransaction","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"bytes32","name":"destTxHash","type":"bytes32"}],"name":"prove","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"refund","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"relay","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":{"notice":"Initiates bridge on origin chain to be relayed by off-chain relayer"},"canClaim(bytes32,address)":{"notice":"Checks if the dispute period has passed so bridge deposit can be claimed"},"claim(bytes,address)":{"notice":"Completes bridge transaction on origin chain by claiming originally deposited capital"},"dispute(bytes32)":{"notice":"Disputes an outstanding proof in case relayer provided dest chain tx is invalid"},"getBridgeTransaction(bytes)":{"notice":"Decodes bridge request into a bridge transaction"},"prove(bytes,bytes32)":{"notice":"Provides proof on origin side that relayer provided funds on destination side of bridge transaction"},"refund(bytes)":{"notice":"Refunds an outstanding bridge transaction in case optimistic bridging failed"},"relay(bytes)":{"notice":"Relays destination side of bridge transaction by off-chain relayer"}},"version":1},"developerDoc":{"kind":"dev","methods":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":{"params":{"params":"The parameters required to bridge"}},"canClaim(bytes32,address)":{"params":{"relayer":"The address of the relayer attempting to claim","transactionId":"The transaction id associated with the encoded bridge transaction to check"}},"claim(bytes,address)":{"params":{"request":"The encoded bridge transaction to claim on origin chain","to":"The recipient address of the funds"}},"dispute(bytes32)":{"params":{"transactionId":"The transaction id associated with the encoded bridge transaction to dispute"}},"getBridgeTransaction(bytes)":{"params":{"request":"The bridge request to decode"}},"prove(bytes,bytes32)":{"params":{"destTxHash":"The destination tx hash proving bridge transaction was relayed","request":"The encoded bridge transaction to prove on origin chain"}},"refund(bytes)":{"params":{"request":"The encoded bridge transaction to refund"}},"relay(bytes)":{"params":{"request":"The encoded bridge transaction to relay on destination chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"BridgeProofDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"BridgeProofProvided\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainGasAmount\",\"type\":\"uint256\"}],\"name\":\"BridgeRelayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"}],\"name\":\"BridgeRequested\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"canClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"dispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"getBridgeTransaction\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"originSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeTransaction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"destTxHash\",\"type\":\"bytes32\"}],\"name\":\"prove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))\":{\"params\":{\"params\":\"The parameters required to bridge\"}},\"canClaim(bytes32,address)\":{\"params\":{\"relayer\":\"The address of the relayer attempting to claim\",\"transactionId\":\"The transaction id associated with the encoded bridge transaction to check\"}},\"claim(bytes,address)\":{\"params\":{\"request\":\"The encoded bridge transaction to claim on origin chain\",\"to\":\"The recipient address of the funds\"}},\"dispute(bytes32)\":{\"params\":{\"transactionId\":\"The transaction id associated with the encoded bridge transaction to dispute\"}},\"getBridgeTransaction(bytes)\":{\"params\":{\"request\":\"The bridge request to decode\"}},\"prove(bytes,bytes32)\":{\"params\":{\"destTxHash\":\"The destination tx hash proving bridge transaction was relayed\",\"request\":\"The encoded bridge transaction to prove on origin chain\"}},\"refund(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to refund\"}},\"relay(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to relay on destination chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))\":{\"notice\":\"Initiates bridge on origin chain to be relayed by off-chain relayer\"},\"canClaim(bytes32,address)\":{\"notice\":\"Checks if the dispute period has passed so bridge deposit can be claimed\"},\"claim(bytes,address)\":{\"notice\":\"Completes bridge transaction on origin chain by claiming originally deposited capital\"},\"dispute(bytes32)\":{\"notice\":\"Disputes an outstanding proof in case relayer provided dest chain tx is invalid\"},\"getBridgeTransaction(bytes)\":{\"notice\":\"Decodes bridge request into a bridge transaction\"},\"prove(bytes,bytes32)\":{\"notice\":\"Provides proof on origin side that relayer provided funds on destination side of bridge transaction\"},\"refund(bytes)\":{\"notice\":\"Refunds an outstanding bridge transaction in case optimistic bridging failed\"},\"relay(bytes)\":{\"notice\":\"Relays destination side of bridge transaction by off-chain relayer\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/BridgeTransactionV2Harness.sol\":\"IFastBridge\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/BridgeTransactionV2Harness.sol\":{\"keccak256\":\"0x163fc97efd1365765820c3f01e2d17aa275f32bfbdcd651602808861111a7c00\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3fbd6475c98b3c1c7e4492e7a59c79a87cc991b403cefd1ac3a980afe441419e\",\"dweb:/ipfs/QmTCQazGcsUMZXtHLFXHwg3Nmc3xFxxFWZ4KY6qXTWpmPx\"]}},\"version\":1}"},"hashes":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":"45851694","canClaim(bytes32,address)":"aa9641ab","claim(bytes,address)":"41fcb612","dispute(bytes32)":"add98c70","getBridgeTransaction(bytes)":"ac11fb1a","prove(bytes,bytes32)":"886d36ff","refund(bytes)":"5eb7d946","relay(bytes)":"8f0d6f17"}},"solidity/BridgeTransactionV2Harness.sol:IFastBridgeV2":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity =0.8.24 ^0.8.4;\n\n// contracts/interfaces/IFastBridge.sol\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        bool sendChainGas;\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(\n        bytes32 indexed transactionId,\n        address indexed sender,\n        bytes request,\n        uint32 destChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        bool sendChainGas\n    );\n    event BridgeRelayed(\n        bytes32 indexed transactionId,\n        address indexed relayer,\n        address indexed to,\n        uint32 originChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        uint256 chainGasAmount\n    );\n    event BridgeProofProvided(bytes32 indexed transactionId, address indexed relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 indexed transactionId, address indexed relayer);\n    event BridgeDepositClaimed(\n        bytes32 indexed transactionId, address indexed relayer, address indexed to, address token, uint256 amount\n    );\n    event BridgeDepositRefunded(bytes32 indexed transactionId, address indexed to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address sender;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount; // should include protocol fee (if any)\n        uint256 destAmount; // should include relayer fee\n        bool sendChainGas;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    function refund(bytes memory request) external;\n\n    // ============ Views ============\n\n    /// @notice Decodes bridge request into a bridge transaction\n    /// @param request The bridge request to decode\n    function getBridgeTransaction(bytes memory request) external view returns (BridgeTransaction memory);\n\n    /// @notice Checks if the dispute period has passed so bridge deposit can be claimed\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to check\n    /// @param relayer The address of the relayer attempting to claim\n    function canClaim(bytes32 transactionId, address relayer) external view returns (bool);\n}\n\n// contracts/interfaces/IFastBridgeV2.sol\n\ninterface IFastBridgeV2 is IFastBridge {\n    enum BridgeStatus {\n        NULL, // doesn't exist yet\n        REQUESTED,\n        RELAYER_PROVED,\n        RELAYER_CLAIMED,\n        REFUNDED\n    }\n\n    struct BridgeTxDetails {\n        BridgeStatus status;\n        uint32 destChainId;\n        uint56 proofBlockTimestamp;\n        address proofRelayer;\n    }\n\n    struct BridgeRelay {\n        uint48 blockNumber;\n        uint48 blockTimestamp;\n        address relayer;\n    }\n\n    /// @notice New params introduced in the FastBridgeV2.\n    /// We are passing fields from the older BridgeParams struct outside of this struct\n    /// for backwards compatibility.\n    /// Note: quoteRelayer and quoteExclusivitySeconds are either both zero (indicating no exclusivity)\n    /// or both non-zero (indicating exclusivity for the given period).\n    /// Note: zapNative \u003e 0 can NOT be used with destToken = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE (native token)\n    /// @param quoteRelayer             Relayer that provided the quote for the transaction\n    /// @param quoteExclusivitySeconds  Period of time the quote relayer is guaranteed exclusivity after user's deposit\n    /// @param quoteId                  Unique quote identifier used for tracking the quote\n    /// @param zapNative                ETH value to send to the recipient (if any)\n    /// @param zapData                  Parameters for the Zap to the destination recipient (if any)\n    struct BridgeParamsV2 {\n        address quoteRelayer;\n        int256 quoteExclusivitySeconds;\n        bytes quoteId;\n        uint256 zapNative;\n        bytes zapData;\n    }\n\n    /// @notice Updated bridge transaction struct to include parameters introduced in FastBridgeV2.\n    /// Note: only `exclusivityRelayer` can fill such a transaction until `exclusivityEndTime`.\n    struct BridgeTransactionV2 {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        // Note: sendChainGas flag from V1 is deprecated\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n        address exclusivityRelayer;\n        uint256 exclusivityEndTime;\n        uint256 zapNative; // ETH value to send to the recipient (if any)\n        bytes zapData; // data to pass for the Zap action (if any)\n    }\n\n    event BridgeQuoteDetails(bytes32 indexed transactionId, bytes quoteId);\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability\n    /// to provide temporary exclusivity fill rights for the quote relayer.\n    /// @param params   The parameters required to bridge\n    /// @param paramsV2 The parameters for exclusivity fill rights (optional, can be left empty)\n    function bridge(BridgeParams memory params, BridgeParamsV2 memory paramsV2) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function relay(bytes memory request, address relayer) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to prove\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function prove(bytes32 transactionId, bytes32 destTxHash, address relayer) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital.\n    /// @notice Can only send funds to the relayer address on the proof.\n    /// @param request The encoded bridge transaction to claim on origin chain\n    function claim(bytes memory request) external;\n    /// @notice Checks if a transaction has been relayed\n    /// @param transactionId The ID of the transaction to check\n    /// @return True if the transaction has been relayed, false otherwise\n    function bridgeRelays(bytes32 transactionId) external view returns (bool);\n\n    /// @notice Returns the status of a bridge transaction\n    /// @param transactionId The ID of the bridge transaction\n    /// @return BridgeStatus Status of the bridge transaction\n    function bridgeStatuses(bytes32 transactionId) external view returns (BridgeStatus);\n\n    /// @notice Returns the timestamp and relayer of a bridge proof\n    /// @param transactionId The ID of the bridge transaction\n    /// @return timestamp The timestamp of the bridge proof\n    /// @return relayer The relayer address of the bridge proof\n    function bridgeProofs(bytes32 transactionId) external view returns (uint96 timestamp, address relayer);\n\n    /// @notice Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2\n    /// @param request The bridge request to decode\n    function getBridgeTransactionV2(bytes memory request) external view returns (BridgeTransactionV2 memory);\n}\n\n// contracts/libs/BridgeTransactionV2.sol\n\n// solhint-disable no-inline-assembly\nlibrary BridgeTransactionV2Lib {\n    uint16 internal constant VERSION = 2;\n\n    // Offsets of the fields in the packed BridgeTransactionV2 struct\n    // uint16   version                 [000 .. 002)\n    // uint32   originChainId           [002 .. 006)\n    // uint32   destChainId             [006 .. 010)\n    // address  originSender            [010 .. 030)\n    // address  destRecipient           [030 .. 050)\n    // address  originToken             [050 .. 070)\n    // address  destToken               [070 .. 090)\n    // uint256  originAmount            [090 .. 122)\n    // uint256  destAmount              [122 .. 154)\n    // uint256  originFeeAmount         [154 .. 186)\n    // uint256  deadline                [186 .. 218)\n    // uint256  nonce                   [218 .. 250)\n    // address  exclusivityRelayer      [250 .. 270)\n    // uint256  exclusivityEndTime      [270 .. 302)\n    // uint256  zapNative               [302 .. 334)\n    // bytes    zapData                 [334 .. ***)\n\n    // forgefmt: disable-start\n    uint256 private constant OFFSET_ORIGIN_CHAIN_ID      = 2;\n    uint256 private constant OFFSET_DEST_CHAIN_ID        = 6;\n    uint256 private constant OFFSET_ORIGIN_SENDER        = 10;\n    uint256 private constant OFFSET_DEST_RECIPIENT       = 30;\n    uint256 private constant OFFSET_ORIGIN_TOKEN         = 50;\n    uint256 private constant OFFSET_DEST_TOKEN           = 70;\n    uint256 private constant OFFSET_ORIGIN_AMOUNT        = 90;\n    uint256 private constant OFFSET_DEST_AMOUNT          = 122;\n    uint256 private constant OFFSET_ORIGIN_FEE_AMOUNT    = 154;\n    uint256 private constant OFFSET_DEADLINE             = 186;\n    uint256 private constant OFFSET_NONCE                = 218;\n    uint256 private constant OFFSET_EXCLUSIVITY_RELAYER  = 250;\n    uint256 private constant OFFSET_EXCLUSIVITY_END_TIME = 270;\n    uint256 private constant OFFSET_ZAP_NATIVE           = 302;\n    uint256 private constant OFFSET_ZAP_DATA             = 334;\n    // forgefmt: disable-end\n\n    error BridgeTransactionV2__InvalidEncodedTx();\n    error BridgeTransactionV2__UnsupportedVersion(uint16 version);\n\n    /// @notice Validates the encoded transaction to be a tightly packed encoded payload for BridgeTransactionV2.\n    /// @dev Checks the minimum length and the version, use this function before decoding any of the fields.\n    function validateV2(bytes calldata encodedTx) internal pure {\n        // Check the minimum length: must at least include all static fields.\n        if (encodedTx.length \u003c OFFSET_ZAP_DATA) revert BridgeTransactionV2__InvalidEncodedTx();\n        // Once we validated the length, we can be sure that the version field is present.\n        uint16 version_ = version(encodedTx);\n        if (version_ != VERSION) revert BridgeTransactionV2__UnsupportedVersion(version_);\n    }\n\n    /// @notice Encodes the BridgeTransactionV2 struct by tightly packing the fields.\n    /// @dev `abi.decode` will not work as a result of the tightly packed fields. Use `decodeV2` to decode instead.\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) internal pure returns (bytes memory) {\n        // We split the encoding into two parts to avoid stack-too-deep error\n        bytes memory firstPart = abi.encodePacked(\n            VERSION,\n            bridgeTx.originChainId,\n            bridgeTx.destChainId,\n            bridgeTx.originSender,\n            bridgeTx.destRecipient,\n            bridgeTx.originToken,\n            bridgeTx.destToken,\n            bridgeTx.originAmount\n        );\n        return abi.encodePacked(\n            firstPart,\n            bridgeTx.destAmount,\n            bridgeTx.originFeeAmount,\n            // Note: we skip the deprecated `sendChainGas` flag, which was present in BridgeTransaction V1\n            bridgeTx.deadline,\n            bridgeTx.nonce,\n            // New V2 fields: exclusivity\n            bridgeTx.exclusivityRelayer,\n            bridgeTx.exclusivityEndTime,\n            // New V2 fields: Zap\n            bridgeTx.zapNative,\n            bridgeTx.zapData\n        );\n    }\n\n    /// @notice Decodes the BridgeTransactionV2 struct from the encoded transaction.\n    /// @dev Encoded BridgeTransactionV2 struct must be tightly packed.\n    /// Use `validateV2` before decoding to ensure the encoded transaction is valid.\n    function decodeV2(bytes calldata encodedTx)\n        internal\n        pure\n        returns (IFastBridgeV2.BridgeTransactionV2 memory bridgeTx)\n    {\n        bridgeTx.originChainId = originChainId(encodedTx);\n        bridgeTx.destChainId = destChainId(encodedTx);\n        bridgeTx.originSender = originSender(encodedTx);\n        bridgeTx.destRecipient = destRecipient(encodedTx);\n        bridgeTx.originToken = originToken(encodedTx);\n        bridgeTx.destToken = destToken(encodedTx);\n        bridgeTx.originAmount = originAmount(encodedTx);\n        bridgeTx.destAmount = destAmount(encodedTx);\n        bridgeTx.originFeeAmount = originFeeAmount(encodedTx);\n        bridgeTx.deadline = deadline(encodedTx);\n        bridgeTx.nonce = nonce(encodedTx);\n        bridgeTx.exclusivityRelayer = exclusivityRelayer(encodedTx);\n        bridgeTx.exclusivityEndTime = exclusivityEndTime(encodedTx);\n        bridgeTx.zapNative = zapNative(encodedTx);\n        bridgeTx.zapData = zapData(encodedTx);\n    }\n\n    /// @notice Extracts the version from the encoded transaction.\n    function version(bytes calldata encodedTx) internal pure returns (uint16 version_) {\n        // Load 32 bytes from the start and shift it 240 bits to the right to get the highest 16 bits.\n        assembly {\n            version_ := shr(240, calldataload(encodedTx.offset))\n        }\n    }\n\n    /// @notice Extracts the origin chain ID from the encoded transaction.\n    function originChainId(bytes calldata encodedTx) internal pure returns (uint32 originChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            originChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the destination chain ID from the encoded transaction.\n    function destChainId(bytes calldata encodedTx) internal pure returns (uint32 destChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            destChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_DEST_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the origin sender from the encoded transaction.\n    function originSender(bytes calldata encodedTx) internal pure returns (address originSender_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originSender_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_SENDER)))\n        }\n    }\n\n    /// @notice Extracts the destination recipient from the encoded transaction.\n    function destRecipient(bytes calldata encodedTx) internal pure returns (address destRecipient_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destRecipient_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_RECIPIENT)))\n        }\n    }\n\n    /// @notice Extracts the origin token from the encoded transaction.\n    function originToken(bytes calldata encodedTx) internal pure returns (address originToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the destination token from the encoded transaction.\n    function destToken(bytes calldata encodedTx) internal pure returns (address destToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the origin amount from the encoded transaction.\n    function originAmount(bytes calldata encodedTx) internal pure returns (uint256 originAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the destination amount from the encoded transaction.\n    function destAmount(bytes calldata encodedTx) internal pure returns (uint256 destAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            destAmount_ := calldataload(add(encodedTx.offset, OFFSET_DEST_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the origin fee amount from the encoded transaction.\n    function originFeeAmount(bytes calldata encodedTx) internal pure returns (uint256 originFeeAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originFeeAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_FEE_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the deadline from the encoded transaction.\n    function deadline(bytes calldata encodedTx) internal pure returns (uint256 deadline_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            deadline_ := calldataload(add(encodedTx.offset, OFFSET_DEADLINE))\n        }\n    }\n\n    /// @notice Extracts the nonce from the encoded transaction.\n    function nonce(bytes calldata encodedTx) internal pure returns (uint256 nonce_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            nonce_ := calldataload(add(encodedTx.offset, OFFSET_NONCE))\n        }\n    }\n\n    /// @notice Extracts the exclusivity relayer from the encoded transaction.\n    function exclusivityRelayer(bytes calldata encodedTx) internal pure returns (address exclusivityRelayer_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            exclusivityRelayer_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_RELAYER)))\n        }\n    }\n\n    /// @notice Extracts the exclusivity end time from the encoded transaction.\n    function exclusivityEndTime(bytes calldata encodedTx) internal pure returns (uint256 exclusivityEndTime_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            exclusivityEndTime_ := calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_END_TIME))\n        }\n    }\n\n    /// @notice Extracts the Zap's native value from the encoded transaction.\n    function zapNative(bytes calldata encodedTx) internal pure returns (uint256 zapNative_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            zapNative_ := calldataload(add(encodedTx.offset, OFFSET_ZAP_NATIVE))\n        }\n    }\n\n    /// @notice Extracts the Zap's data from the encoded transaction.\n    function zapData(bytes calldata encodedTx) internal pure returns (bytes calldata zapData_) {\n        zapData_ = encodedTx[OFFSET_ZAP_DATA:];\n    }\n}\n\n// test/harnesses/BridgeTransactionV2Harness.sol\n\ncontract BridgeTransactionV2Harness {\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) public pure returns (bytes memory) {\n        return BridgeTransactionV2Lib.encodeV2(bridgeTx);\n    }\n\n    function decodeV2(bytes calldata encodedTx) public pure returns (IFastBridgeV2.BridgeTransactionV2 memory) {\n        return BridgeTransactionV2Lib.decodeV2(encodedTx);\n    }\n\n    function version(bytes calldata encodedTx) public pure returns (uint16) {\n        return BridgeTransactionV2Lib.version(encodedTx);\n    }\n\n    function originChainId(bytes calldata encodedTx) public pure returns (uint32) {\n        return BridgeTransactionV2Lib.originChainId(encodedTx);\n    }\n\n    function destChainId(bytes calldata encodedTx) public pure returns (uint32) {\n        return BridgeTransactionV2Lib.destChainId(encodedTx);\n    }\n\n    function originSender(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.originSender(encodedTx);\n    }\n\n    function destRecipient(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.destRecipient(encodedTx);\n    }\n\n    function originToken(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.originToken(encodedTx);\n    }\n\n    function destToken(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.destToken(encodedTx);\n    }\n\n    function originAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.originAmount(encodedTx);\n    }\n\n    function destAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.destAmount(encodedTx);\n    }\n\n    function originFeeAmount(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.originFeeAmount(encodedTx);\n    }\n\n    function zapNative(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.zapNative(encodedTx);\n    }\n\n    function deadline(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.deadline(encodedTx);\n    }\n\n    function nonce(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.nonce(encodedTx);\n    }\n\n    function exclusivityRelayer(bytes calldata encodedTx) public pure returns (address) {\n        return BridgeTransactionV2Lib.exclusivityRelayer(encodedTx);\n    }\n\n    function exclusivityEndTime(bytes calldata encodedTx) public pure returns (uint256) {\n        return BridgeTransactionV2Lib.exclusivityEndTime(encodedTx);\n    }\n\n    function zapData(bytes calldata encodedTx) public pure returns (bytes calldata) {\n        return BridgeTransactionV2Lib.zapData(encodedTx);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.24","compilerVersion":"0.8.24","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositRefunded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"}],"name":"BridgeProofDisputed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"bytes32","name":"transactionHash","type":"bytes32"}],"name":"BridgeProofProvided","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"quoteId","type":"bytes"}],"name":"BridgeQuoteDetails","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint32","name":"originChainId","type":"uint32"},{"indexed":false,"internalType":"address","name":"originToken","type":"address"},{"indexed":false,"internalType":"address","name":"destToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"originAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"destAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"chainGasAmount","type":"uint256"}],"name":"BridgeRelayed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"request","type":"bytes"},{"indexed":false,"internalType":"uint32","name":"destChainId","type":"uint32"},{"indexed":false,"internalType":"address","name":"originToken","type":"address"},{"indexed":false,"internalType":"address","name":"destToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"originAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"destAmount","type":"uint256"},{"indexed":false,"internalType":"bool","name":"sendChainGas","type":"bool"}],"name":"BridgeRequested","type":"event"},{"inputs":[{"components":[{"internalType":"uint32","name":"dstChainId","type":"uint32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"bool","name":"sendChainGas","type":"bool"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct IFastBridge.BridgeParams","name":"params","type":"tuple"}],"name":"bridge","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint32","name":"dstChainId","type":"uint32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"bool","name":"sendChainGas","type":"bool"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct IFastBridge.BridgeParams","name":"params","type":"tuple"},{"components":[{"internalType":"address","name":"quoteRelayer","type":"address"},{"internalType":"int256","name":"quoteExclusivitySeconds","type":"int256"},{"internalType":"bytes","name":"quoteId","type":"bytes"},{"internalType":"uint256","name":"zapNative","type":"uint256"},{"internalType":"bytes","name":"zapData","type":"bytes"}],"internalType":"struct IFastBridgeV2.BridgeParamsV2","name":"paramsV2","type":"tuple"}],"name":"bridge","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"bridgeProofs","outputs":[{"internalType":"uint96","name":"timestamp","type":"uint96"},{"internalType":"address","name":"relayer","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"bridgeRelays","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"bridgeStatuses","outputs":[{"internalType":"enum IFastBridgeV2.BridgeStatus","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"address","name":"relayer","type":"address"}],"name":"canClaim","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"address","name":"to","type":"address"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"dispute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"getBridgeTransaction","outputs":[{"components":[{"internalType":"uint32","name":"originChainId","type":"uint32"},{"internalType":"uint32","name":"destChainId","type":"uint32"},{"internalType":"address","name":"originSender","type":"address"},{"internalType":"address","name":"destRecipient","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"originFeeAmount","type":"uint256"},{"internalType":"bool","name":"sendChainGas","type":"bool"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"}],"internalType":"struct IFastBridge.BridgeTransaction","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"getBridgeTransactionV2","outputs":[{"components":[{"internalType":"uint32","name":"originChainId","type":"uint32"},{"internalType":"uint32","name":"destChainId","type":"uint32"},{"internalType":"address","name":"originSender","type":"address"},{"internalType":"address","name":"destRecipient","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"originFeeAmount","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"address","name":"exclusivityRelayer","type":"address"},{"internalType":"uint256","name":"exclusivityEndTime","type":"uint256"},{"internalType":"uint256","name":"zapNative","type":"uint256"},{"internalType":"bytes","name":"zapData","type":"bytes"}],"internalType":"struct IFastBridgeV2.BridgeTransactionV2","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"bytes32","name":"destTxHash","type":"bytes32"},{"internalType":"address","name":"relayer","type":"address"}],"name":"prove","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"bytes32","name":"destTxHash","type":"bytes32"}],"name":"prove","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"refund","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"relay","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"address","name":"relayer","type":"address"}],"name":"relay","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":{"notice":"Initiates bridge on origin chain to be relayed by off-chain relayer"},"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256),(address,int256,bytes,uint256,bytes))":{"notice":"Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability to provide temporary exclusivity fill rights for the quote relayer."},"bridgeProofs(bytes32)":{"notice":"Returns the timestamp and relayer of a bridge proof"},"bridgeRelays(bytes32)":{"notice":"Checks if a transaction has been relayed"},"bridgeStatuses(bytes32)":{"notice":"Returns the status of a bridge transaction"},"canClaim(bytes32,address)":{"notice":"Checks if the dispute period has passed so bridge deposit can be claimed"},"claim(bytes)":{"notice":"Completes bridge transaction on origin chain by claiming originally deposited capital.Can only send funds to the relayer address on the proof."},"claim(bytes,address)":{"notice":"Completes bridge transaction on origin chain by claiming originally deposited capital"},"dispute(bytes32)":{"notice":"Disputes an outstanding proof in case relayer provided dest chain tx is invalid"},"getBridgeTransaction(bytes)":{"notice":"Decodes bridge request into a bridge transaction"},"getBridgeTransactionV2(bytes)":{"notice":"Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2"},"prove(bytes,bytes32)":{"notice":"Provides proof on origin side that relayer provided funds on destination side of bridge transaction"},"prove(bytes32,bytes32,address)":{"notice":"Provides proof on origin side that relayer provided funds on destination side of bridge transaction"},"refund(bytes)":{"notice":"Refunds an outstanding bridge transaction in case optimistic bridging failed"},"relay(bytes)":{"notice":"Relays destination side of bridge transaction by off-chain relayer"},"relay(bytes,address)":{"notice":"Relays destination side of bridge transaction by off-chain relayer"}},"version":1},"developerDoc":{"kind":"dev","methods":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":{"params":{"params":"The parameters required to bridge"}},"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256),(address,int256,bytes,uint256,bytes))":{"params":{"params":"The parameters required to bridge","paramsV2":"The parameters for exclusivity fill rights (optional, can be left empty)"}},"bridgeProofs(bytes32)":{"params":{"transactionId":"The ID of the bridge transaction"},"returns":{"relayer":"The relayer address of the bridge proof","timestamp":"The timestamp of the bridge proof"}},"bridgeRelays(bytes32)":{"params":{"transactionId":"The ID of the transaction to check"},"returns":{"_0":"True if the transaction has been relayed, false otherwise"}},"bridgeStatuses(bytes32)":{"params":{"transactionId":"The ID of the bridge transaction"},"returns":{"_0":"BridgeStatus Status of the bridge transaction"}},"canClaim(bytes32,address)":{"params":{"relayer":"The address of the relayer attempting to claim","transactionId":"The transaction id associated with the encoded bridge transaction to check"}},"claim(bytes)":{"params":{"request":"The encoded bridge transaction to claim on origin chain"}},"claim(bytes,address)":{"params":{"request":"The encoded bridge transaction to claim on origin chain","to":"The recipient address of the funds"}},"dispute(bytes32)":{"params":{"transactionId":"The transaction id associated with the encoded bridge transaction to dispute"}},"getBridgeTransaction(bytes)":{"params":{"request":"The bridge request to decode"}},"getBridgeTransactionV2(bytes)":{"params":{"request":"The bridge request to decode"}},"prove(bytes,bytes32)":{"params":{"destTxHash":"The destination tx hash proving bridge transaction was relayed","request":"The encoded bridge transaction to prove on origin chain"}},"prove(bytes32,bytes32,address)":{"params":{"destTxHash":"The destination tx hash proving bridge transaction was relayed","relayer":"The address of the relaying entity which should have control of the origin funds when claimed","transactionId":"The transaction id associated with the encoded bridge transaction to prove"}},"refund(bytes)":{"params":{"request":"The encoded bridge transaction to refund"}},"relay(bytes)":{"params":{"request":"The encoded bridge transaction to relay on destination chain"}},"relay(bytes,address)":{"params":{"relayer":"The address of the relaying entity which should have control of the origin funds when claimed","request":"The encoded bridge transaction to relay on destination chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"BridgeProofDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"BridgeProofProvided\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"quoteId\",\"type\":\"bytes\"}],\"name\":\"BridgeQuoteDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainGasAmount\",\"type\":\"uint256\"}],\"name\":\"BridgeRelayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"}],\"name\":\"BridgeRequested\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"quoteRelayer\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"quoteExclusivitySeconds\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"quoteId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"zapNative\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"zapData\",\"type\":\"bytes\"}],\"internalType\":\"struct IFastBridgeV2.BridgeParamsV2\",\"name\":\"paramsV2\",\"type\":\"tuple\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"bridgeProofs\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"timestamp\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"bridgeRelays\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"bridgeStatuses\",\"outputs\":[{\"internalType\":\"enum IFastBridgeV2.BridgeStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"canClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"dispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"getBridgeTransaction\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"originSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeTransaction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"getBridgeTransactionV2\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"originSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusivityRelayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exclusivityEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zapNative\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"zapData\",\"type\":\"bytes\"}],\"internalType\":\"struct IFastBridgeV2.BridgeTransactionV2\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"prove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"destTxHash\",\"type\":\"bytes32\"}],\"name\":\"prove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))\":{\"params\":{\"params\":\"The parameters required to bridge\"}},\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256),(address,int256,bytes,uint256,bytes))\":{\"params\":{\"params\":\"The parameters required to bridge\",\"paramsV2\":\"The parameters for exclusivity fill rights (optional, can be left empty)\"}},\"bridgeProofs(bytes32)\":{\"params\":{\"transactionId\":\"The ID of the bridge transaction\"},\"returns\":{\"relayer\":\"The relayer address of the bridge proof\",\"timestamp\":\"The timestamp of the bridge proof\"}},\"bridgeRelays(bytes32)\":{\"params\":{\"transactionId\":\"The ID of the transaction to check\"},\"returns\":{\"_0\":\"True if the transaction has been relayed, false otherwise\"}},\"bridgeStatuses(bytes32)\":{\"params\":{\"transactionId\":\"The ID of the bridge transaction\"},\"returns\":{\"_0\":\"BridgeStatus Status of the bridge transaction\"}},\"canClaim(bytes32,address)\":{\"params\":{\"relayer\":\"The address of the relayer attempting to claim\",\"transactionId\":\"The transaction id associated with the encoded bridge transaction to check\"}},\"claim(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to claim on origin chain\"}},\"claim(bytes,address)\":{\"params\":{\"request\":\"The encoded bridge transaction to claim on origin chain\",\"to\":\"The recipient address of the funds\"}},\"dispute(bytes32)\":{\"params\":{\"transactionId\":\"The transaction id associated with the encoded bridge transaction to dispute\"}},\"getBridgeTransaction(bytes)\":{\"params\":{\"request\":\"The bridge request to decode\"}},\"getBridgeTransactionV2(bytes)\":{\"params\":{\"request\":\"The bridge request to decode\"}},\"prove(bytes,bytes32)\":{\"params\":{\"destTxHash\":\"The destination tx hash proving bridge transaction was relayed\",\"request\":\"The encoded bridge transaction to prove on origin chain\"}},\"prove(bytes32,bytes32,address)\":{\"params\":{\"destTxHash\":\"The destination tx hash proving bridge transaction was relayed\",\"relayer\":\"The address of the relaying entity which should have control of the origin funds when claimed\",\"transactionId\":\"The transaction id associated with the encoded bridge transaction to prove\"}},\"refund(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to refund\"}},\"relay(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to relay on destination chain\"}},\"relay(bytes,address)\":{\"params\":{\"relayer\":\"The address of the relaying entity which should have control of the origin funds when claimed\",\"request\":\"The encoded bridge transaction to relay on destination chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))\":{\"notice\":\"Initiates bridge on origin chain to be relayed by off-chain relayer\"},\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256),(address,int256,bytes,uint256,bytes))\":{\"notice\":\"Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability to provide temporary exclusivity fill rights for the quote relayer.\"},\"bridgeProofs(bytes32)\":{\"notice\":\"Returns the timestamp and relayer of a bridge proof\"},\"bridgeRelays(bytes32)\":{\"notice\":\"Checks if a transaction has been relayed\"},\"bridgeStatuses(bytes32)\":{\"notice\":\"Returns the status of a bridge transaction\"},\"canClaim(bytes32,address)\":{\"notice\":\"Checks if the dispute period has passed so bridge deposit can be claimed\"},\"claim(bytes)\":{\"notice\":\"Completes bridge transaction on origin chain by claiming originally deposited capital.Can only send funds to the relayer address on the proof.\"},\"claim(bytes,address)\":{\"notice\":\"Completes bridge transaction on origin chain by claiming originally deposited capital\"},\"dispute(bytes32)\":{\"notice\":\"Disputes an outstanding proof in case relayer provided dest chain tx is invalid\"},\"getBridgeTransaction(bytes)\":{\"notice\":\"Decodes bridge request into a bridge transaction\"},\"getBridgeTransactionV2(bytes)\":{\"notice\":\"Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2\"},\"prove(bytes,bytes32)\":{\"notice\":\"Provides proof on origin side that relayer provided funds on destination side of bridge transaction\"},\"prove(bytes32,bytes32,address)\":{\"notice\":\"Provides proof on origin side that relayer provided funds on destination side of bridge transaction\"},\"refund(bytes)\":{\"notice\":\"Refunds an outstanding bridge transaction in case optimistic bridging failed\"},\"relay(bytes)\":{\"notice\":\"Relays destination side of bridge transaction by off-chain relayer\"},\"relay(bytes,address)\":{\"notice\":\"Relays destination side of bridge transaction by off-chain relayer\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/BridgeTransactionV2Harness.sol\":\"IFastBridgeV2\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/BridgeTransactionV2Harness.sol\":{\"keccak256\":\"0x163fc97efd1365765820c3f01e2d17aa275f32bfbdcd651602808861111a7c00\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://3fbd6475c98b3c1c7e4492e7a59c79a87cc991b403cefd1ac3a980afe441419e\",\"dweb:/ipfs/QmTCQazGcsUMZXtHLFXHwg3Nmc3xFxxFWZ4KY6qXTWpmPx\"]}},\"version\":1}"},"hashes":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":"45851694","bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256),(address,int256,bytes,uint256,bytes))":"bfc7c607","bridgeProofs(bytes32)":"91ad5039","bridgeRelays(bytes32)":"8379a24f","bridgeStatuses(bytes32)":"051287bc","canClaim(bytes32,address)":"aa9641ab","claim(bytes)":"c63ff8dd","claim(bytes,address)":"41fcb612","dispute(bytes32)":"add98c70","getBridgeTransaction(bytes)":"ac11fb1a","getBridgeTransactionV2(bytes)":"5aa6ccba","prove(bytes,bytes32)":"886d36ff","prove(bytes32,bytes32,address)":"18e4357d","refund(bytes)":"5eb7d946","relay(bytes)":"8f0d6f17","relay(bytes,address)":"9c9545f0"}}}