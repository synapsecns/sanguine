{"solidity/BridgeTransactionV2.sol:BridgeTransactionV2Lib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122015e035caa40406d51f5c7b0d5428e946b6e76cdb0ace342f3f3b4702af80f9a564736f6c63430008180033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122015e035caa40406d51f5c7b0d5428e946b6e76cdb0ace342f3f3b4702af80f9a564736f6c63430008180033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// contracts/interfaces/IFastBridge.sol\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        bool sendChainGas;\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(\n        bytes32 indexed transactionId,\n        address indexed sender,\n        bytes request,\n        uint32 destChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        bool sendChainGas\n    );\n    event BridgeRelayed(\n        bytes32 indexed transactionId,\n        address indexed relayer,\n        address indexed to,\n        uint32 originChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        uint256 chainGasAmount\n    );\n    event BridgeProofProvided(bytes32 indexed transactionId, address indexed relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 indexed transactionId, address indexed relayer);\n    event BridgeDepositClaimed(\n        bytes32 indexed transactionId, address indexed relayer, address indexed to, address token, uint256 amount\n    );\n    event BridgeDepositRefunded(bytes32 indexed transactionId, address indexed to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address sender;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount; // should include protocol fee (if any)\n        uint256 destAmount; // should include relayer fee\n        bool sendChainGas;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    function refund(bytes memory request) external;\n\n    // ============ Views ============\n\n    /// @notice Decodes bridge request into a bridge transaction\n    /// @param request The bridge request to decode\n    function getBridgeTransaction(bytes memory request) external view returns (BridgeTransaction memory);\n\n    /// @notice Checks if the dispute period has passed so bridge deposit can be claimed\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to check\n    /// @param relayer The address of the relayer attempting to claim\n    function canClaim(bytes32 transactionId, address relayer) external view returns (bool);\n}\n\n// contracts/interfaces/IFastBridgeV2.sol\n\ninterface IFastBridgeV2 is IFastBridge {\n    enum BridgeStatus {\n        NULL, // doesn't exist yet\n        REQUESTED,\n        RELAYER_PROVED,\n        RELAYER_CLAIMED,\n        REFUNDED\n    }\n\n    struct BridgeTxDetails {\n        BridgeStatus status;\n        uint32 destChainId;\n        uint56 proofBlockTimestamp;\n        address proofRelayer;\n    }\n\n    struct BridgeRelay {\n        uint48 blockNumber;\n        uint48 blockTimestamp;\n        address relayer;\n    }\n\n    /// @notice New params introduced in the FastBridgeV2.\n    /// We are passing fields from the older BridgeParams struct outside of this struct\n    /// for backwards compatibility.\n    /// Note: quoteRelayer and quoteExclusivitySeconds are either both zero (indicating no exclusivity)\n    /// or both non-zero (indicating exclusivity for the given period).\n    /// Note: zapNative \u003e 0 can NOT be used with destToken = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE (native token)\n    /// @param quoteRelayer             Relayer that provided the quote for the transaction\n    /// @param quoteExclusivitySeconds  Period of time the quote relayer is guaranteed exclusivity after user's deposit\n    /// @param quoteId                  Unique quote identifier used for tracking the quote\n    /// @param zapNative                ETH value to send to the recipient (if any)\n    /// @param zapData                  Parameters for the Zap to the destination recipient (if any)\n    struct BridgeParamsV2 {\n        address quoteRelayer;\n        int256 quoteExclusivitySeconds;\n        bytes quoteId;\n        uint256 zapNative;\n        bytes zapData;\n    }\n\n    /// @notice Updated bridge transaction struct to include parameters introduced in FastBridgeV2.\n    /// Note: only `exclusivityRelayer` can fill such a transaction until `exclusivityEndTime`.\n    struct BridgeTransactionV2 {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        // Note: sendChainGas flag from V1 is deprecated\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n        address exclusivityRelayer;\n        uint256 exclusivityEndTime;\n        uint256 zapNative; // ETH value to send to the recipient (if any)\n        bytes zapData; // data to pass for the Zap action (if any)\n    }\n\n    event BridgeQuoteDetails(bytes32 indexed transactionId, bytes quoteId);\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability\n    /// to provide temporary exclusivity fill rights for the quote relayer.\n    /// @param params   The parameters required to bridge\n    /// @param paramsV2 The parameters for exclusivity fill rights (optional, can be left empty)\n    function bridge(BridgeParams memory params, BridgeParamsV2 memory paramsV2) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function relay(bytes memory request, address relayer) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to prove\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function prove(bytes32 transactionId, bytes32 destTxHash, address relayer) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital.\n    /// @notice Can only send funds to the relayer address on the proof.\n    /// @param request The encoded bridge transaction to claim on origin chain\n    function claim(bytes memory request) external;\n    /// @notice Checks if a transaction has been relayed\n    /// @param transactionId The ID of the transaction to check\n    /// @return True if the transaction has been relayed, false otherwise\n    function bridgeRelays(bytes32 transactionId) external view returns (bool);\n\n    /// @notice Returns the status of a bridge transaction\n    /// @param transactionId The ID of the bridge transaction\n    /// @return BridgeStatus Status of the bridge transaction\n    function bridgeStatuses(bytes32 transactionId) external view returns (BridgeStatus);\n\n    /// @notice Returns the timestamp and relayer of a bridge proof\n    /// @param transactionId The ID of the bridge transaction\n    /// @return timestamp The timestamp of the bridge proof\n    /// @return relayer The relayer address of the bridge proof\n    function bridgeProofs(bytes32 transactionId) external view returns (uint96 timestamp, address relayer);\n\n    /// @notice Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2\n    /// @param request The bridge request to decode\n    function getBridgeTransactionV2(bytes memory request) external view returns (BridgeTransactionV2 memory);\n}\n\n// contracts/libs/BridgeTransactionV2.sol\n\n// solhint-disable no-inline-assembly\nlibrary BridgeTransactionV2Lib {\n    uint16 internal constant VERSION = 2;\n\n    // Offsets of the fields in the packed BridgeTransactionV2 struct\n    // uint16   version                 [000 .. 002)\n    // uint32   originChainId           [002 .. 006)\n    // uint32   destChainId             [006 .. 010)\n    // address  originSender            [010 .. 030)\n    // address  destRecipient           [030 .. 050)\n    // address  originToken             [050 .. 070)\n    // address  destToken               [070 .. 090)\n    // uint256  originAmount            [090 .. 122)\n    // uint256  destAmount              [122 .. 154)\n    // uint256  originFeeAmount         [154 .. 186)\n    // uint256  deadline                [186 .. 218)\n    // uint256  nonce                   [218 .. 250)\n    // address  exclusivityRelayer      [250 .. 270)\n    // uint256  exclusivityEndTime      [270 .. 302)\n    // uint256  zapNative               [302 .. 334)\n    // bytes    zapData                 [334 .. ***)\n\n    // forgefmt: disable-start\n    uint256 private constant OFFSET_ORIGIN_CHAIN_ID      = 2;\n    uint256 private constant OFFSET_DEST_CHAIN_ID        = 6;\n    uint256 private constant OFFSET_ORIGIN_SENDER        = 10;\n    uint256 private constant OFFSET_DEST_RECIPIENT       = 30;\n    uint256 private constant OFFSET_ORIGIN_TOKEN         = 50;\n    uint256 private constant OFFSET_DEST_TOKEN           = 70;\n    uint256 private constant OFFSET_ORIGIN_AMOUNT        = 90;\n    uint256 private constant OFFSET_DEST_AMOUNT          = 122;\n    uint256 private constant OFFSET_ORIGIN_FEE_AMOUNT    = 154;\n    uint256 private constant OFFSET_DEADLINE             = 186;\n    uint256 private constant OFFSET_NONCE                = 218;\n    uint256 private constant OFFSET_EXCLUSIVITY_RELAYER  = 250;\n    uint256 private constant OFFSET_EXCLUSIVITY_END_TIME = 270;\n    uint256 private constant OFFSET_ZAP_NATIVE           = 302;\n    uint256 private constant OFFSET_ZAP_DATA             = 334;\n    // forgefmt: disable-end\n\n    error BridgeTransactionV2__InvalidEncodedTx();\n    error BridgeTransactionV2__UnsupportedVersion(uint16 version);\n\n    /// @notice Validates the encoded transaction to be a tightly packed encoded payload for BridgeTransactionV2.\n    /// @dev Checks the minimum length and the version, use this function before decoding any of the fields.\n    function validateV2(bytes calldata encodedTx) internal pure {\n        // Check the minimum length: must at least include all static fields.\n        if (encodedTx.length \u003c OFFSET_ZAP_DATA) revert BridgeTransactionV2__InvalidEncodedTx();\n        // Once we validated the length, we can be sure that the version field is present.\n        uint16 version_ = version(encodedTx);\n        if (version_ != VERSION) revert BridgeTransactionV2__UnsupportedVersion(version_);\n    }\n\n    /// @notice Encodes the BridgeTransactionV2 struct by tightly packing the fields.\n    /// @dev `abi.decode` will not work as a result of the tightly packed fields. Use `decodeV2` to decode instead.\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) internal pure returns (bytes memory) {\n        // We split the encoding into two parts to avoid stack-too-deep error\n        bytes memory firstPart = abi.encodePacked(\n            VERSION,\n            bridgeTx.originChainId,\n            bridgeTx.destChainId,\n            bridgeTx.originSender,\n            bridgeTx.destRecipient,\n            bridgeTx.originToken,\n            bridgeTx.destToken,\n            bridgeTx.originAmount\n        );\n        return abi.encodePacked(\n            firstPart,\n            bridgeTx.destAmount,\n            bridgeTx.originFeeAmount,\n            // Note: we skip the deprecated `sendChainGas` flag, which was present in BridgeTransaction V1\n            bridgeTx.deadline,\n            bridgeTx.nonce,\n            // New V2 fields: exclusivity\n            bridgeTx.exclusivityRelayer,\n            bridgeTx.exclusivityEndTime,\n            // New V2 fields: Zap\n            bridgeTx.zapNative,\n            bridgeTx.zapData\n        );\n    }\n\n    /// @notice Decodes the BridgeTransactionV2 struct from the encoded transaction.\n    /// @dev Encoded BridgeTransactionV2 struct must be tightly packed.\n    /// Use `validateV2` before decoding to ensure the encoded transaction is valid.\n    function decodeV2(bytes calldata encodedTx)\n        internal\n        pure\n        returns (IFastBridgeV2.BridgeTransactionV2 memory bridgeTx)\n    {\n        bridgeTx.originChainId = originChainId(encodedTx);\n        bridgeTx.destChainId = destChainId(encodedTx);\n        bridgeTx.originSender = originSender(encodedTx);\n        bridgeTx.destRecipient = destRecipient(encodedTx);\n        bridgeTx.originToken = originToken(encodedTx);\n        bridgeTx.destToken = destToken(encodedTx);\n        bridgeTx.originAmount = originAmount(encodedTx);\n        bridgeTx.destAmount = destAmount(encodedTx);\n        bridgeTx.originFeeAmount = originFeeAmount(encodedTx);\n        bridgeTx.deadline = deadline(encodedTx);\n        bridgeTx.nonce = nonce(encodedTx);\n        bridgeTx.exclusivityRelayer = exclusivityRelayer(encodedTx);\n        bridgeTx.exclusivityEndTime = exclusivityEndTime(encodedTx);\n        bridgeTx.zapNative = zapNative(encodedTx);\n        bridgeTx.zapData = zapData(encodedTx);\n    }\n\n    /// @notice Extracts the version from the encoded transaction.\n    function version(bytes calldata encodedTx) internal pure returns (uint16 version_) {\n        // Load 32 bytes from the start and shift it 240 bits to the right to get the highest 16 bits.\n        assembly {\n            version_ := shr(240, calldataload(encodedTx.offset))\n        }\n    }\n\n    /// @notice Extracts the origin chain ID from the encoded transaction.\n    function originChainId(bytes calldata encodedTx) internal pure returns (uint32 originChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            originChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the destination chain ID from the encoded transaction.\n    function destChainId(bytes calldata encodedTx) internal pure returns (uint32 destChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            destChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_DEST_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the origin sender from the encoded transaction.\n    function originSender(bytes calldata encodedTx) internal pure returns (address originSender_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originSender_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_SENDER)))\n        }\n    }\n\n    /// @notice Extracts the destination recipient from the encoded transaction.\n    function destRecipient(bytes calldata encodedTx) internal pure returns (address destRecipient_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destRecipient_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_RECIPIENT)))\n        }\n    }\n\n    /// @notice Extracts the origin token from the encoded transaction.\n    function originToken(bytes calldata encodedTx) internal pure returns (address originToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the destination token from the encoded transaction.\n    function destToken(bytes calldata encodedTx) internal pure returns (address destToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the origin amount from the encoded transaction.\n    function originAmount(bytes calldata encodedTx) internal pure returns (uint256 originAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the destination amount from the encoded transaction.\n    function destAmount(bytes calldata encodedTx) internal pure returns (uint256 destAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            destAmount_ := calldataload(add(encodedTx.offset, OFFSET_DEST_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the origin fee amount from the encoded transaction.\n    function originFeeAmount(bytes calldata encodedTx) internal pure returns (uint256 originFeeAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originFeeAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_FEE_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the deadline from the encoded transaction.\n    function deadline(bytes calldata encodedTx) internal pure returns (uint256 deadline_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            deadline_ := calldataload(add(encodedTx.offset, OFFSET_DEADLINE))\n        }\n    }\n\n    /// @notice Extracts the nonce from the encoded transaction.\n    function nonce(bytes calldata encodedTx) internal pure returns (uint256 nonce_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            nonce_ := calldataload(add(encodedTx.offset, OFFSET_NONCE))\n        }\n    }\n\n    /// @notice Extracts the exclusivity relayer from the encoded transaction.\n    function exclusivityRelayer(bytes calldata encodedTx) internal pure returns (address exclusivityRelayer_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            exclusivityRelayer_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_RELAYER)))\n        }\n    }\n\n    /// @notice Extracts the exclusivity end time from the encoded transaction.\n    function exclusivityEndTime(bytes calldata encodedTx) internal pure returns (uint256 exclusivityEndTime_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            exclusivityEndTime_ := calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_END_TIME))\n        }\n    }\n\n    /// @notice Extracts the Zap's native value from the encoded transaction.\n    function zapNative(bytes calldata encodedTx) internal pure returns (uint256 zapNative_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            zapNative_ := calldataload(add(encodedTx.offset, OFFSET_ZAP_NATIVE))\n        }\n    }\n\n    /// @notice Extracts the Zap's data from the encoded transaction.\n    function zapData(bytes calldata encodedTx) internal pure returns (bytes calldata zapData_) {\n        zapData_ = encodedTx[OFFSET_ZAP_DATA:];\n    }\n}\n","language":"Solidity","languageVersion":"0.8.24","compilerVersion":"0.8.24","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"9943:11496:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;9943:11496:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"9943:11496:0:-:0;;;;;;;;","abiDefinition":[{"inputs":[],"name":"BridgeTransactionV2__InvalidEncodedTx","type":"error"},{"inputs":[{"internalType":"uint16","name":"version","type":"uint16"}],"name":"BridgeTransactionV2__UnsupportedVersion","type":"error"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"BridgeTransactionV2__InvalidEncodedTx\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"version\",\"type\":\"uint16\"}],\"name\":\"BridgeTransactionV2__UnsupportedVersion\",\"type\":\"error\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/BridgeTransactionV2.sol\":\"BridgeTransactionV2Lib\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/BridgeTransactionV2.sol\":{\"keccak256\":\"0x84a8a79ef0e3a7c425f5af24e773f8ad7177797466cc0c3315dee333da4e2477\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://810ce2d94aac2e372f9fb90d8f7b18cfd3bce24e9005e6b7aac569e6517a03d1\",\"dweb:/ipfs/QmbiF4SoMDGUTTL3Zo2fB67oSqFY9SY6Whx8GM9gpUNkbf\"]}},\"version\":1}"},"hashes":{}},"solidity/BridgeTransactionV2.sol:IFastBridge":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// contracts/interfaces/IFastBridge.sol\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        bool sendChainGas;\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(\n        bytes32 indexed transactionId,\n        address indexed sender,\n        bytes request,\n        uint32 destChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        bool sendChainGas\n    );\n    event BridgeRelayed(\n        bytes32 indexed transactionId,\n        address indexed relayer,\n        address indexed to,\n        uint32 originChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        uint256 chainGasAmount\n    );\n    event BridgeProofProvided(bytes32 indexed transactionId, address indexed relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 indexed transactionId, address indexed relayer);\n    event BridgeDepositClaimed(\n        bytes32 indexed transactionId, address indexed relayer, address indexed to, address token, uint256 amount\n    );\n    event BridgeDepositRefunded(bytes32 indexed transactionId, address indexed to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address sender;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount; // should include protocol fee (if any)\n        uint256 destAmount; // should include relayer fee\n        bool sendChainGas;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    function refund(bytes memory request) external;\n\n    // ============ Views ============\n\n    /// @notice Decodes bridge request into a bridge transaction\n    /// @param request The bridge request to decode\n    function getBridgeTransaction(bytes memory request) external view returns (BridgeTransaction memory);\n\n    /// @notice Checks if the dispute period has passed so bridge deposit can be claimed\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to check\n    /// @param relayer The address of the relayer attempting to claim\n    function canClaim(bytes32 transactionId, address relayer) external view returns (bool);\n}\n\n// contracts/interfaces/IFastBridgeV2.sol\n\ninterface IFastBridgeV2 is IFastBridge {\n    enum BridgeStatus {\n        NULL, // doesn't exist yet\n        REQUESTED,\n        RELAYER_PROVED,\n        RELAYER_CLAIMED,\n        REFUNDED\n    }\n\n    struct BridgeTxDetails {\n        BridgeStatus status;\n        uint32 destChainId;\n        uint56 proofBlockTimestamp;\n        address proofRelayer;\n    }\n\n    struct BridgeRelay {\n        uint48 blockNumber;\n        uint48 blockTimestamp;\n        address relayer;\n    }\n\n    /// @notice New params introduced in the FastBridgeV2.\n    /// We are passing fields from the older BridgeParams struct outside of this struct\n    /// for backwards compatibility.\n    /// Note: quoteRelayer and quoteExclusivitySeconds are either both zero (indicating no exclusivity)\n    /// or both non-zero (indicating exclusivity for the given period).\n    /// Note: zapNative \u003e 0 can NOT be used with destToken = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE (native token)\n    /// @param quoteRelayer             Relayer that provided the quote for the transaction\n    /// @param quoteExclusivitySeconds  Period of time the quote relayer is guaranteed exclusivity after user's deposit\n    /// @param quoteId                  Unique quote identifier used for tracking the quote\n    /// @param zapNative                ETH value to send to the recipient (if any)\n    /// @param zapData                  Parameters for the Zap to the destination recipient (if any)\n    struct BridgeParamsV2 {\n        address quoteRelayer;\n        int256 quoteExclusivitySeconds;\n        bytes quoteId;\n        uint256 zapNative;\n        bytes zapData;\n    }\n\n    /// @notice Updated bridge transaction struct to include parameters introduced in FastBridgeV2.\n    /// Note: only `exclusivityRelayer` can fill such a transaction until `exclusivityEndTime`.\n    struct BridgeTransactionV2 {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        // Note: sendChainGas flag from V1 is deprecated\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n        address exclusivityRelayer;\n        uint256 exclusivityEndTime;\n        uint256 zapNative; // ETH value to send to the recipient (if any)\n        bytes zapData; // data to pass for the Zap action (if any)\n    }\n\n    event BridgeQuoteDetails(bytes32 indexed transactionId, bytes quoteId);\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability\n    /// to provide temporary exclusivity fill rights for the quote relayer.\n    /// @param params   The parameters required to bridge\n    /// @param paramsV2 The parameters for exclusivity fill rights (optional, can be left empty)\n    function bridge(BridgeParams memory params, BridgeParamsV2 memory paramsV2) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function relay(bytes memory request, address relayer) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to prove\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function prove(bytes32 transactionId, bytes32 destTxHash, address relayer) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital.\n    /// @notice Can only send funds to the relayer address on the proof.\n    /// @param request The encoded bridge transaction to claim on origin chain\n    function claim(bytes memory request) external;\n    /// @notice Checks if a transaction has been relayed\n    /// @param transactionId The ID of the transaction to check\n    /// @return True if the transaction has been relayed, false otherwise\n    function bridgeRelays(bytes32 transactionId) external view returns (bool);\n\n    /// @notice Returns the status of a bridge transaction\n    /// @param transactionId The ID of the bridge transaction\n    /// @return BridgeStatus Status of the bridge transaction\n    function bridgeStatuses(bytes32 transactionId) external view returns (BridgeStatus);\n\n    /// @notice Returns the timestamp and relayer of a bridge proof\n    /// @param transactionId The ID of the bridge transaction\n    /// @return timestamp The timestamp of the bridge proof\n    /// @return relayer The relayer address of the bridge proof\n    function bridgeProofs(bytes32 transactionId) external view returns (uint96 timestamp, address relayer);\n\n    /// @notice Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2\n    /// @param request The bridge request to decode\n    function getBridgeTransactionV2(bytes memory request) external view returns (BridgeTransactionV2 memory);\n}\n\n// contracts/libs/BridgeTransactionV2.sol\n\n// solhint-disable no-inline-assembly\nlibrary BridgeTransactionV2Lib {\n    uint16 internal constant VERSION = 2;\n\n    // Offsets of the fields in the packed BridgeTransactionV2 struct\n    // uint16   version                 [000 .. 002)\n    // uint32   originChainId           [002 .. 006)\n    // uint32   destChainId             [006 .. 010)\n    // address  originSender            [010 .. 030)\n    // address  destRecipient           [030 .. 050)\n    // address  originToken             [050 .. 070)\n    // address  destToken               [070 .. 090)\n    // uint256  originAmount            [090 .. 122)\n    // uint256  destAmount              [122 .. 154)\n    // uint256  originFeeAmount         [154 .. 186)\n    // uint256  deadline                [186 .. 218)\n    // uint256  nonce                   [218 .. 250)\n    // address  exclusivityRelayer      [250 .. 270)\n    // uint256  exclusivityEndTime      [270 .. 302)\n    // uint256  zapNative               [302 .. 334)\n    // bytes    zapData                 [334 .. ***)\n\n    // forgefmt: disable-start\n    uint256 private constant OFFSET_ORIGIN_CHAIN_ID      = 2;\n    uint256 private constant OFFSET_DEST_CHAIN_ID        = 6;\n    uint256 private constant OFFSET_ORIGIN_SENDER        = 10;\n    uint256 private constant OFFSET_DEST_RECIPIENT       = 30;\n    uint256 private constant OFFSET_ORIGIN_TOKEN         = 50;\n    uint256 private constant OFFSET_DEST_TOKEN           = 70;\n    uint256 private constant OFFSET_ORIGIN_AMOUNT        = 90;\n    uint256 private constant OFFSET_DEST_AMOUNT          = 122;\n    uint256 private constant OFFSET_ORIGIN_FEE_AMOUNT    = 154;\n    uint256 private constant OFFSET_DEADLINE             = 186;\n    uint256 private constant OFFSET_NONCE                = 218;\n    uint256 private constant OFFSET_EXCLUSIVITY_RELAYER  = 250;\n    uint256 private constant OFFSET_EXCLUSIVITY_END_TIME = 270;\n    uint256 private constant OFFSET_ZAP_NATIVE           = 302;\n    uint256 private constant OFFSET_ZAP_DATA             = 334;\n    // forgefmt: disable-end\n\n    error BridgeTransactionV2__InvalidEncodedTx();\n    error BridgeTransactionV2__UnsupportedVersion(uint16 version);\n\n    /// @notice Validates the encoded transaction to be a tightly packed encoded payload for BridgeTransactionV2.\n    /// @dev Checks the minimum length and the version, use this function before decoding any of the fields.\n    function validateV2(bytes calldata encodedTx) internal pure {\n        // Check the minimum length: must at least include all static fields.\n        if (encodedTx.length \u003c OFFSET_ZAP_DATA) revert BridgeTransactionV2__InvalidEncodedTx();\n        // Once we validated the length, we can be sure that the version field is present.\n        uint16 version_ = version(encodedTx);\n        if (version_ != VERSION) revert BridgeTransactionV2__UnsupportedVersion(version_);\n    }\n\n    /// @notice Encodes the BridgeTransactionV2 struct by tightly packing the fields.\n    /// @dev `abi.decode` will not work as a result of the tightly packed fields. Use `decodeV2` to decode instead.\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) internal pure returns (bytes memory) {\n        // We split the encoding into two parts to avoid stack-too-deep error\n        bytes memory firstPart = abi.encodePacked(\n            VERSION,\n            bridgeTx.originChainId,\n            bridgeTx.destChainId,\n            bridgeTx.originSender,\n            bridgeTx.destRecipient,\n            bridgeTx.originToken,\n            bridgeTx.destToken,\n            bridgeTx.originAmount\n        );\n        return abi.encodePacked(\n            firstPart,\n            bridgeTx.destAmount,\n            bridgeTx.originFeeAmount,\n            // Note: we skip the deprecated `sendChainGas` flag, which was present in BridgeTransaction V1\n            bridgeTx.deadline,\n            bridgeTx.nonce,\n            // New V2 fields: exclusivity\n            bridgeTx.exclusivityRelayer,\n            bridgeTx.exclusivityEndTime,\n            // New V2 fields: Zap\n            bridgeTx.zapNative,\n            bridgeTx.zapData\n        );\n    }\n\n    /// @notice Decodes the BridgeTransactionV2 struct from the encoded transaction.\n    /// @dev Encoded BridgeTransactionV2 struct must be tightly packed.\n    /// Use `validateV2` before decoding to ensure the encoded transaction is valid.\n    function decodeV2(bytes calldata encodedTx)\n        internal\n        pure\n        returns (IFastBridgeV2.BridgeTransactionV2 memory bridgeTx)\n    {\n        bridgeTx.originChainId = originChainId(encodedTx);\n        bridgeTx.destChainId = destChainId(encodedTx);\n        bridgeTx.originSender = originSender(encodedTx);\n        bridgeTx.destRecipient = destRecipient(encodedTx);\n        bridgeTx.originToken = originToken(encodedTx);\n        bridgeTx.destToken = destToken(encodedTx);\n        bridgeTx.originAmount = originAmount(encodedTx);\n        bridgeTx.destAmount = destAmount(encodedTx);\n        bridgeTx.originFeeAmount = originFeeAmount(encodedTx);\n        bridgeTx.deadline = deadline(encodedTx);\n        bridgeTx.nonce = nonce(encodedTx);\n        bridgeTx.exclusivityRelayer = exclusivityRelayer(encodedTx);\n        bridgeTx.exclusivityEndTime = exclusivityEndTime(encodedTx);\n        bridgeTx.zapNative = zapNative(encodedTx);\n        bridgeTx.zapData = zapData(encodedTx);\n    }\n\n    /// @notice Extracts the version from the encoded transaction.\n    function version(bytes calldata encodedTx) internal pure returns (uint16 version_) {\n        // Load 32 bytes from the start and shift it 240 bits to the right to get the highest 16 bits.\n        assembly {\n            version_ := shr(240, calldataload(encodedTx.offset))\n        }\n    }\n\n    /// @notice Extracts the origin chain ID from the encoded transaction.\n    function originChainId(bytes calldata encodedTx) internal pure returns (uint32 originChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            originChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the destination chain ID from the encoded transaction.\n    function destChainId(bytes calldata encodedTx) internal pure returns (uint32 destChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            destChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_DEST_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the origin sender from the encoded transaction.\n    function originSender(bytes calldata encodedTx) internal pure returns (address originSender_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originSender_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_SENDER)))\n        }\n    }\n\n    /// @notice Extracts the destination recipient from the encoded transaction.\n    function destRecipient(bytes calldata encodedTx) internal pure returns (address destRecipient_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destRecipient_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_RECIPIENT)))\n        }\n    }\n\n    /// @notice Extracts the origin token from the encoded transaction.\n    function originToken(bytes calldata encodedTx) internal pure returns (address originToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the destination token from the encoded transaction.\n    function destToken(bytes calldata encodedTx) internal pure returns (address destToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the origin amount from the encoded transaction.\n    function originAmount(bytes calldata encodedTx) internal pure returns (uint256 originAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the destination amount from the encoded transaction.\n    function destAmount(bytes calldata encodedTx) internal pure returns (uint256 destAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            destAmount_ := calldataload(add(encodedTx.offset, OFFSET_DEST_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the origin fee amount from the encoded transaction.\n    function originFeeAmount(bytes calldata encodedTx) internal pure returns (uint256 originFeeAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originFeeAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_FEE_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the deadline from the encoded transaction.\n    function deadline(bytes calldata encodedTx) internal pure returns (uint256 deadline_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            deadline_ := calldataload(add(encodedTx.offset, OFFSET_DEADLINE))\n        }\n    }\n\n    /// @notice Extracts the nonce from the encoded transaction.\n    function nonce(bytes calldata encodedTx) internal pure returns (uint256 nonce_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            nonce_ := calldataload(add(encodedTx.offset, OFFSET_NONCE))\n        }\n    }\n\n    /// @notice Extracts the exclusivity relayer from the encoded transaction.\n    function exclusivityRelayer(bytes calldata encodedTx) internal pure returns (address exclusivityRelayer_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            exclusivityRelayer_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_RELAYER)))\n        }\n    }\n\n    /// @notice Extracts the exclusivity end time from the encoded transaction.\n    function exclusivityEndTime(bytes calldata encodedTx) internal pure returns (uint256 exclusivityEndTime_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            exclusivityEndTime_ := calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_END_TIME))\n        }\n    }\n\n    /// @notice Extracts the Zap's native value from the encoded transaction.\n    function zapNative(bytes calldata encodedTx) internal pure returns (uint256 zapNative_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            zapNative_ := calldataload(add(encodedTx.offset, OFFSET_ZAP_NATIVE))\n        }\n    }\n\n    /// @notice Extracts the Zap's data from the encoded transaction.\n    function zapData(bytes calldata encodedTx) internal pure returns (bytes calldata zapData_) {\n        zapData_ = encodedTx[OFFSET_ZAP_DATA:];\n    }\n}\n","language":"Solidity","languageVersion":"0.8.24","compilerVersion":"0.8.24","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositRefunded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"}],"name":"BridgeProofDisputed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"bytes32","name":"transactionHash","type":"bytes32"}],"name":"BridgeProofProvided","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint32","name":"originChainId","type":"uint32"},{"indexed":false,"internalType":"address","name":"originToken","type":"address"},{"indexed":false,"internalType":"address","name":"destToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"originAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"destAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"chainGasAmount","type":"uint256"}],"name":"BridgeRelayed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"request","type":"bytes"},{"indexed":false,"internalType":"uint32","name":"destChainId","type":"uint32"},{"indexed":false,"internalType":"address","name":"originToken","type":"address"},{"indexed":false,"internalType":"address","name":"destToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"originAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"destAmount","type":"uint256"},{"indexed":false,"internalType":"bool","name":"sendChainGas","type":"bool"}],"name":"BridgeRequested","type":"event"},{"inputs":[{"components":[{"internalType":"uint32","name":"dstChainId","type":"uint32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"bool","name":"sendChainGas","type":"bool"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct IFastBridge.BridgeParams","name":"params","type":"tuple"}],"name":"bridge","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"address","name":"relayer","type":"address"}],"name":"canClaim","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"address","name":"to","type":"address"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"dispute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"getBridgeTransaction","outputs":[{"components":[{"internalType":"uint32","name":"originChainId","type":"uint32"},{"internalType":"uint32","name":"destChainId","type":"uint32"},{"internalType":"address","name":"originSender","type":"address"},{"internalType":"address","name":"destRecipient","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"originFeeAmount","type":"uint256"},{"internalType":"bool","name":"sendChainGas","type":"bool"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"}],"internalType":"struct IFastBridge.BridgeTransaction","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"bytes32","name":"destTxHash","type":"bytes32"}],"name":"prove","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"refund","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"relay","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":{"notice":"Initiates bridge on origin chain to be relayed by off-chain relayer"},"canClaim(bytes32,address)":{"notice":"Checks if the dispute period has passed so bridge deposit can be claimed"},"claim(bytes,address)":{"notice":"Completes bridge transaction on origin chain by claiming originally deposited capital"},"dispute(bytes32)":{"notice":"Disputes an outstanding proof in case relayer provided dest chain tx is invalid"},"getBridgeTransaction(bytes)":{"notice":"Decodes bridge request into a bridge transaction"},"prove(bytes,bytes32)":{"notice":"Provides proof on origin side that relayer provided funds on destination side of bridge transaction"},"refund(bytes)":{"notice":"Refunds an outstanding bridge transaction in case optimistic bridging failed"},"relay(bytes)":{"notice":"Relays destination side of bridge transaction by off-chain relayer"}},"version":1},"developerDoc":{"kind":"dev","methods":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":{"params":{"params":"The parameters required to bridge"}},"canClaim(bytes32,address)":{"params":{"relayer":"The address of the relayer attempting to claim","transactionId":"The transaction id associated with the encoded bridge transaction to check"}},"claim(bytes,address)":{"params":{"request":"The encoded bridge transaction to claim on origin chain","to":"The recipient address of the funds"}},"dispute(bytes32)":{"params":{"transactionId":"The transaction id associated with the encoded bridge transaction to dispute"}},"getBridgeTransaction(bytes)":{"params":{"request":"The bridge request to decode"}},"prove(bytes,bytes32)":{"params":{"destTxHash":"The destination tx hash proving bridge transaction was relayed","request":"The encoded bridge transaction to prove on origin chain"}},"refund(bytes)":{"params":{"request":"The encoded bridge transaction to refund"}},"relay(bytes)":{"params":{"request":"The encoded bridge transaction to relay on destination chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"BridgeProofDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"BridgeProofProvided\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainGasAmount\",\"type\":\"uint256\"}],\"name\":\"BridgeRelayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"}],\"name\":\"BridgeRequested\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"canClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"dispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"getBridgeTransaction\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"originSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeTransaction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"destTxHash\",\"type\":\"bytes32\"}],\"name\":\"prove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))\":{\"params\":{\"params\":\"The parameters required to bridge\"}},\"canClaim(bytes32,address)\":{\"params\":{\"relayer\":\"The address of the relayer attempting to claim\",\"transactionId\":\"The transaction id associated with the encoded bridge transaction to check\"}},\"claim(bytes,address)\":{\"params\":{\"request\":\"The encoded bridge transaction to claim on origin chain\",\"to\":\"The recipient address of the funds\"}},\"dispute(bytes32)\":{\"params\":{\"transactionId\":\"The transaction id associated with the encoded bridge transaction to dispute\"}},\"getBridgeTransaction(bytes)\":{\"params\":{\"request\":\"The bridge request to decode\"}},\"prove(bytes,bytes32)\":{\"params\":{\"destTxHash\":\"The destination tx hash proving bridge transaction was relayed\",\"request\":\"The encoded bridge transaction to prove on origin chain\"}},\"refund(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to refund\"}},\"relay(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to relay on destination chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))\":{\"notice\":\"Initiates bridge on origin chain to be relayed by off-chain relayer\"},\"canClaim(bytes32,address)\":{\"notice\":\"Checks if the dispute period has passed so bridge deposit can be claimed\"},\"claim(bytes,address)\":{\"notice\":\"Completes bridge transaction on origin chain by claiming originally deposited capital\"},\"dispute(bytes32)\":{\"notice\":\"Disputes an outstanding proof in case relayer provided dest chain tx is invalid\"},\"getBridgeTransaction(bytes)\":{\"notice\":\"Decodes bridge request into a bridge transaction\"},\"prove(bytes,bytes32)\":{\"notice\":\"Provides proof on origin side that relayer provided funds on destination side of bridge transaction\"},\"refund(bytes)\":{\"notice\":\"Refunds an outstanding bridge transaction in case optimistic bridging failed\"},\"relay(bytes)\":{\"notice\":\"Relays destination side of bridge transaction by off-chain relayer\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/BridgeTransactionV2.sol\":\"IFastBridge\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/BridgeTransactionV2.sol\":{\"keccak256\":\"0x84a8a79ef0e3a7c425f5af24e773f8ad7177797466cc0c3315dee333da4e2477\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://810ce2d94aac2e372f9fb90d8f7b18cfd3bce24e9005e6b7aac569e6517a03d1\",\"dweb:/ipfs/QmbiF4SoMDGUTTL3Zo2fB67oSqFY9SY6Whx8GM9gpUNkbf\"]}},\"version\":1}"},"hashes":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":"45851694","canClaim(bytes32,address)":"aa9641ab","claim(bytes,address)":"41fcb612","dispute(bytes32)":"add98c70","getBridgeTransaction(bytes)":"ac11fb1a","prove(bytes,bytes32)":"886d36ff","refund(bytes)":"5eb7d946","relay(bytes)":"8f0d6f17"}},"solidity/BridgeTransactionV2.sol:IFastBridgeV2":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n// contracts/interfaces/IFastBridge.sol\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        bool sendChainGas;\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(\n        bytes32 indexed transactionId,\n        address indexed sender,\n        bytes request,\n        uint32 destChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        bool sendChainGas\n    );\n    event BridgeRelayed(\n        bytes32 indexed transactionId,\n        address indexed relayer,\n        address indexed to,\n        uint32 originChainId,\n        address originToken,\n        address destToken,\n        uint256 originAmount,\n        uint256 destAmount,\n        uint256 chainGasAmount\n    );\n    event BridgeProofProvided(bytes32 indexed transactionId, address indexed relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 indexed transactionId, address indexed relayer);\n    event BridgeDepositClaimed(\n        bytes32 indexed transactionId, address indexed relayer, address indexed to, address token, uint256 amount\n    );\n    event BridgeDepositRefunded(bytes32 indexed transactionId, address indexed to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address sender;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount; // should include protocol fee (if any)\n        uint256 destAmount; // should include relayer fee\n        bool sendChainGas;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    function refund(bytes memory request) external;\n\n    // ============ Views ============\n\n    /// @notice Decodes bridge request into a bridge transaction\n    /// @param request The bridge request to decode\n    function getBridgeTransaction(bytes memory request) external view returns (BridgeTransaction memory);\n\n    /// @notice Checks if the dispute period has passed so bridge deposit can be claimed\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to check\n    /// @param relayer The address of the relayer attempting to claim\n    function canClaim(bytes32 transactionId, address relayer) external view returns (bool);\n}\n\n// contracts/interfaces/IFastBridgeV2.sol\n\ninterface IFastBridgeV2 is IFastBridge {\n    enum BridgeStatus {\n        NULL, // doesn't exist yet\n        REQUESTED,\n        RELAYER_PROVED,\n        RELAYER_CLAIMED,\n        REFUNDED\n    }\n\n    struct BridgeTxDetails {\n        BridgeStatus status;\n        uint32 destChainId;\n        uint56 proofBlockTimestamp;\n        address proofRelayer;\n    }\n\n    struct BridgeRelay {\n        uint48 blockNumber;\n        uint48 blockTimestamp;\n        address relayer;\n    }\n\n    /// @notice New params introduced in the FastBridgeV2.\n    /// We are passing fields from the older BridgeParams struct outside of this struct\n    /// for backwards compatibility.\n    /// Note: quoteRelayer and quoteExclusivitySeconds are either both zero (indicating no exclusivity)\n    /// or both non-zero (indicating exclusivity for the given period).\n    /// Note: zapNative \u003e 0 can NOT be used with destToken = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE (native token)\n    /// @param quoteRelayer             Relayer that provided the quote for the transaction\n    /// @param quoteExclusivitySeconds  Period of time the quote relayer is guaranteed exclusivity after user's deposit\n    /// @param quoteId                  Unique quote identifier used for tracking the quote\n    /// @param zapNative                ETH value to send to the recipient (if any)\n    /// @param zapData                  Parameters for the Zap to the destination recipient (if any)\n    struct BridgeParamsV2 {\n        address quoteRelayer;\n        int256 quoteExclusivitySeconds;\n        bytes quoteId;\n        uint256 zapNative;\n        bytes zapData;\n    }\n\n    /// @notice Updated bridge transaction struct to include parameters introduced in FastBridgeV2.\n    /// Note: only `exclusivityRelayer` can fill such a transaction until `exclusivityEndTime`.\n    struct BridgeTransactionV2 {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount; // amount in on origin bridge less originFeeAmount\n        uint256 destAmount;\n        uint256 originFeeAmount;\n        // Note: sendChainGas flag from V1 is deprecated\n        uint256 deadline; // user specified deadline for destination relay\n        uint256 nonce;\n        address exclusivityRelayer;\n        uint256 exclusivityEndTime;\n        uint256 zapNative; // ETH value to send to the recipient (if any)\n        bytes zapData; // data to pass for the Zap action (if any)\n    }\n\n    event BridgeQuoteDetails(bytes32 indexed transactionId, bytes quoteId);\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability\n    /// to provide temporary exclusivity fill rights for the quote relayer.\n    /// @param params   The parameters required to bridge\n    /// @param paramsV2 The parameters for exclusivity fill rights (optional, can be left empty)\n    function bridge(BridgeParams memory params, BridgeParamsV2 memory paramsV2) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function relay(bytes memory request, address relayer) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to prove\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    /// @param relayer The address of the relaying entity which should have control of the origin funds when claimed\n    function prove(bytes32 transactionId, bytes32 destTxHash, address relayer) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital.\n    /// @notice Can only send funds to the relayer address on the proof.\n    /// @param request The encoded bridge transaction to claim on origin chain\n    function claim(bytes memory request) external;\n    /// @notice Checks if a transaction has been relayed\n    /// @param transactionId The ID of the transaction to check\n    /// @return True if the transaction has been relayed, false otherwise\n    function bridgeRelays(bytes32 transactionId) external view returns (bool);\n\n    /// @notice Returns the status of a bridge transaction\n    /// @param transactionId The ID of the bridge transaction\n    /// @return BridgeStatus Status of the bridge transaction\n    function bridgeStatuses(bytes32 transactionId) external view returns (BridgeStatus);\n\n    /// @notice Returns the timestamp and relayer of a bridge proof\n    /// @param transactionId The ID of the bridge transaction\n    /// @return timestamp The timestamp of the bridge proof\n    /// @return relayer The relayer address of the bridge proof\n    function bridgeProofs(bytes32 transactionId) external view returns (uint96 timestamp, address relayer);\n\n    /// @notice Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2\n    /// @param request The bridge request to decode\n    function getBridgeTransactionV2(bytes memory request) external view returns (BridgeTransactionV2 memory);\n}\n\n// contracts/libs/BridgeTransactionV2.sol\n\n// solhint-disable no-inline-assembly\nlibrary BridgeTransactionV2Lib {\n    uint16 internal constant VERSION = 2;\n\n    // Offsets of the fields in the packed BridgeTransactionV2 struct\n    // uint16   version                 [000 .. 002)\n    // uint32   originChainId           [002 .. 006)\n    // uint32   destChainId             [006 .. 010)\n    // address  originSender            [010 .. 030)\n    // address  destRecipient           [030 .. 050)\n    // address  originToken             [050 .. 070)\n    // address  destToken               [070 .. 090)\n    // uint256  originAmount            [090 .. 122)\n    // uint256  destAmount              [122 .. 154)\n    // uint256  originFeeAmount         [154 .. 186)\n    // uint256  deadline                [186 .. 218)\n    // uint256  nonce                   [218 .. 250)\n    // address  exclusivityRelayer      [250 .. 270)\n    // uint256  exclusivityEndTime      [270 .. 302)\n    // uint256  zapNative               [302 .. 334)\n    // bytes    zapData                 [334 .. ***)\n\n    // forgefmt: disable-start\n    uint256 private constant OFFSET_ORIGIN_CHAIN_ID      = 2;\n    uint256 private constant OFFSET_DEST_CHAIN_ID        = 6;\n    uint256 private constant OFFSET_ORIGIN_SENDER        = 10;\n    uint256 private constant OFFSET_DEST_RECIPIENT       = 30;\n    uint256 private constant OFFSET_ORIGIN_TOKEN         = 50;\n    uint256 private constant OFFSET_DEST_TOKEN           = 70;\n    uint256 private constant OFFSET_ORIGIN_AMOUNT        = 90;\n    uint256 private constant OFFSET_DEST_AMOUNT          = 122;\n    uint256 private constant OFFSET_ORIGIN_FEE_AMOUNT    = 154;\n    uint256 private constant OFFSET_DEADLINE             = 186;\n    uint256 private constant OFFSET_NONCE                = 218;\n    uint256 private constant OFFSET_EXCLUSIVITY_RELAYER  = 250;\n    uint256 private constant OFFSET_EXCLUSIVITY_END_TIME = 270;\n    uint256 private constant OFFSET_ZAP_NATIVE           = 302;\n    uint256 private constant OFFSET_ZAP_DATA             = 334;\n    // forgefmt: disable-end\n\n    error BridgeTransactionV2__InvalidEncodedTx();\n    error BridgeTransactionV2__UnsupportedVersion(uint16 version);\n\n    /// @notice Validates the encoded transaction to be a tightly packed encoded payload for BridgeTransactionV2.\n    /// @dev Checks the minimum length and the version, use this function before decoding any of the fields.\n    function validateV2(bytes calldata encodedTx) internal pure {\n        // Check the minimum length: must at least include all static fields.\n        if (encodedTx.length \u003c OFFSET_ZAP_DATA) revert BridgeTransactionV2__InvalidEncodedTx();\n        // Once we validated the length, we can be sure that the version field is present.\n        uint16 version_ = version(encodedTx);\n        if (version_ != VERSION) revert BridgeTransactionV2__UnsupportedVersion(version_);\n    }\n\n    /// @notice Encodes the BridgeTransactionV2 struct by tightly packing the fields.\n    /// @dev `abi.decode` will not work as a result of the tightly packed fields. Use `decodeV2` to decode instead.\n    function encodeV2(IFastBridgeV2.BridgeTransactionV2 memory bridgeTx) internal pure returns (bytes memory) {\n        // We split the encoding into two parts to avoid stack-too-deep error\n        bytes memory firstPart = abi.encodePacked(\n            VERSION,\n            bridgeTx.originChainId,\n            bridgeTx.destChainId,\n            bridgeTx.originSender,\n            bridgeTx.destRecipient,\n            bridgeTx.originToken,\n            bridgeTx.destToken,\n            bridgeTx.originAmount\n        );\n        return abi.encodePacked(\n            firstPart,\n            bridgeTx.destAmount,\n            bridgeTx.originFeeAmount,\n            // Note: we skip the deprecated `sendChainGas` flag, which was present in BridgeTransaction V1\n            bridgeTx.deadline,\n            bridgeTx.nonce,\n            // New V2 fields: exclusivity\n            bridgeTx.exclusivityRelayer,\n            bridgeTx.exclusivityEndTime,\n            // New V2 fields: Zap\n            bridgeTx.zapNative,\n            bridgeTx.zapData\n        );\n    }\n\n    /// @notice Decodes the BridgeTransactionV2 struct from the encoded transaction.\n    /// @dev Encoded BridgeTransactionV2 struct must be tightly packed.\n    /// Use `validateV2` before decoding to ensure the encoded transaction is valid.\n    function decodeV2(bytes calldata encodedTx)\n        internal\n        pure\n        returns (IFastBridgeV2.BridgeTransactionV2 memory bridgeTx)\n    {\n        bridgeTx.originChainId = originChainId(encodedTx);\n        bridgeTx.destChainId = destChainId(encodedTx);\n        bridgeTx.originSender = originSender(encodedTx);\n        bridgeTx.destRecipient = destRecipient(encodedTx);\n        bridgeTx.originToken = originToken(encodedTx);\n        bridgeTx.destToken = destToken(encodedTx);\n        bridgeTx.originAmount = originAmount(encodedTx);\n        bridgeTx.destAmount = destAmount(encodedTx);\n        bridgeTx.originFeeAmount = originFeeAmount(encodedTx);\n        bridgeTx.deadline = deadline(encodedTx);\n        bridgeTx.nonce = nonce(encodedTx);\n        bridgeTx.exclusivityRelayer = exclusivityRelayer(encodedTx);\n        bridgeTx.exclusivityEndTime = exclusivityEndTime(encodedTx);\n        bridgeTx.zapNative = zapNative(encodedTx);\n        bridgeTx.zapData = zapData(encodedTx);\n    }\n\n    /// @notice Extracts the version from the encoded transaction.\n    function version(bytes calldata encodedTx) internal pure returns (uint16 version_) {\n        // Load 32 bytes from the start and shift it 240 bits to the right to get the highest 16 bits.\n        assembly {\n            version_ := shr(240, calldataload(encodedTx.offset))\n        }\n    }\n\n    /// @notice Extracts the origin chain ID from the encoded transaction.\n    function originChainId(bytes calldata encodedTx) internal pure returns (uint32 originChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            originChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the destination chain ID from the encoded transaction.\n    function destChainId(bytes calldata encodedTx) internal pure returns (uint32 destChainId_) {\n        // Load 32 bytes from the offset and shift it 224 bits to the right to get the highest 32 bits.\n        assembly {\n            destChainId_ := shr(224, calldataload(add(encodedTx.offset, OFFSET_DEST_CHAIN_ID)))\n        }\n    }\n\n    /// @notice Extracts the origin sender from the encoded transaction.\n    function originSender(bytes calldata encodedTx) internal pure returns (address originSender_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originSender_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_SENDER)))\n        }\n    }\n\n    /// @notice Extracts the destination recipient from the encoded transaction.\n    function destRecipient(bytes calldata encodedTx) internal pure returns (address destRecipient_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destRecipient_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_RECIPIENT)))\n        }\n    }\n\n    /// @notice Extracts the origin token from the encoded transaction.\n    function originToken(bytes calldata encodedTx) internal pure returns (address originToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            originToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_ORIGIN_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the destination token from the encoded transaction.\n    function destToken(bytes calldata encodedTx) internal pure returns (address destToken_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            destToken_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_DEST_TOKEN)))\n        }\n    }\n\n    /// @notice Extracts the origin amount from the encoded transaction.\n    function originAmount(bytes calldata encodedTx) internal pure returns (uint256 originAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the destination amount from the encoded transaction.\n    function destAmount(bytes calldata encodedTx) internal pure returns (uint256 destAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            destAmount_ := calldataload(add(encodedTx.offset, OFFSET_DEST_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the origin fee amount from the encoded transaction.\n    function originFeeAmount(bytes calldata encodedTx) internal pure returns (uint256 originFeeAmount_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            originFeeAmount_ := calldataload(add(encodedTx.offset, OFFSET_ORIGIN_FEE_AMOUNT))\n        }\n    }\n\n    /// @notice Extracts the deadline from the encoded transaction.\n    function deadline(bytes calldata encodedTx) internal pure returns (uint256 deadline_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            deadline_ := calldataload(add(encodedTx.offset, OFFSET_DEADLINE))\n        }\n    }\n\n    /// @notice Extracts the nonce from the encoded transaction.\n    function nonce(bytes calldata encodedTx) internal pure returns (uint256 nonce_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            nonce_ := calldataload(add(encodedTx.offset, OFFSET_NONCE))\n        }\n    }\n\n    /// @notice Extracts the exclusivity relayer from the encoded transaction.\n    function exclusivityRelayer(bytes calldata encodedTx) internal pure returns (address exclusivityRelayer_) {\n        // Load 32 bytes from the offset and shift it 96 bits to the right to get the highest 160 bits.\n        assembly {\n            exclusivityRelayer_ := shr(96, calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_RELAYER)))\n        }\n    }\n\n    /// @notice Extracts the exclusivity end time from the encoded transaction.\n    function exclusivityEndTime(bytes calldata encodedTx) internal pure returns (uint256 exclusivityEndTime_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            exclusivityEndTime_ := calldataload(add(encodedTx.offset, OFFSET_EXCLUSIVITY_END_TIME))\n        }\n    }\n\n    /// @notice Extracts the Zap's native value from the encoded transaction.\n    function zapNative(bytes calldata encodedTx) internal pure returns (uint256 zapNative_) {\n        // Load 32 bytes from the offset. No shift is applied, as we need the full 256 bits.\n        assembly {\n            zapNative_ := calldataload(add(encodedTx.offset, OFFSET_ZAP_NATIVE))\n        }\n    }\n\n    /// @notice Extracts the Zap's data from the encoded transaction.\n    function zapData(bytes calldata encodedTx) internal pure returns (bytes calldata zapData_) {\n        zapData_ = encodedTx[OFFSET_ZAP_DATA:];\n    }\n}\n","language":"Solidity","languageVersion":"0.8.24","compilerVersion":"0.8.24","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositRefunded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"}],"name":"BridgeProofDisputed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"bytes32","name":"transactionHash","type":"bytes32"}],"name":"BridgeProofProvided","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"quoteId","type":"bytes"}],"name":"BridgeQuoteDetails","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint32","name":"originChainId","type":"uint32"},{"indexed":false,"internalType":"address","name":"originToken","type":"address"},{"indexed":false,"internalType":"address","name":"destToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"originAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"destAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"chainGasAmount","type":"uint256"}],"name":"BridgeRelayed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"request","type":"bytes"},{"indexed":false,"internalType":"uint32","name":"destChainId","type":"uint32"},{"indexed":false,"internalType":"address","name":"originToken","type":"address"},{"indexed":false,"internalType":"address","name":"destToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"originAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"destAmount","type":"uint256"},{"indexed":false,"internalType":"bool","name":"sendChainGas","type":"bool"}],"name":"BridgeRequested","type":"event"},{"inputs":[{"components":[{"internalType":"uint32","name":"dstChainId","type":"uint32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"bool","name":"sendChainGas","type":"bool"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct IFastBridge.BridgeParams","name":"params","type":"tuple"}],"name":"bridge","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"components":[{"internalType":"uint32","name":"dstChainId","type":"uint32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"bool","name":"sendChainGas","type":"bool"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct IFastBridge.BridgeParams","name":"params","type":"tuple"},{"components":[{"internalType":"address","name":"quoteRelayer","type":"address"},{"internalType":"int256","name":"quoteExclusivitySeconds","type":"int256"},{"internalType":"bytes","name":"quoteId","type":"bytes"},{"internalType":"uint256","name":"zapNative","type":"uint256"},{"internalType":"bytes","name":"zapData","type":"bytes"}],"internalType":"struct IFastBridgeV2.BridgeParamsV2","name":"paramsV2","type":"tuple"}],"name":"bridge","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"bridgeProofs","outputs":[{"internalType":"uint96","name":"timestamp","type":"uint96"},{"internalType":"address","name":"relayer","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"bridgeRelays","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"bridgeStatuses","outputs":[{"internalType":"enum IFastBridgeV2.BridgeStatus","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"address","name":"relayer","type":"address"}],"name":"canClaim","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"address","name":"to","type":"address"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"dispute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"getBridgeTransaction","outputs":[{"components":[{"internalType":"uint32","name":"originChainId","type":"uint32"},{"internalType":"uint32","name":"destChainId","type":"uint32"},{"internalType":"address","name":"originSender","type":"address"},{"internalType":"address","name":"destRecipient","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"originFeeAmount","type":"uint256"},{"internalType":"bool","name":"sendChainGas","type":"bool"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"}],"internalType":"struct IFastBridge.BridgeTransaction","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"getBridgeTransactionV2","outputs":[{"components":[{"internalType":"uint32","name":"originChainId","type":"uint32"},{"internalType":"uint32","name":"destChainId","type":"uint32"},{"internalType":"address","name":"originSender","type":"address"},{"internalType":"address","name":"destRecipient","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"originFeeAmount","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint256","name":"nonce","type":"uint256"},{"internalType":"address","name":"exclusivityRelayer","type":"address"},{"internalType":"uint256","name":"exclusivityEndTime","type":"uint256"},{"internalType":"uint256","name":"zapNative","type":"uint256"},{"internalType":"bytes","name":"zapData","type":"bytes"}],"internalType":"struct IFastBridgeV2.BridgeTransactionV2","name":"","type":"tuple"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"bytes32","name":"destTxHash","type":"bytes32"},{"internalType":"address","name":"relayer","type":"address"}],"name":"prove","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"bytes32","name":"destTxHash","type":"bytes32"}],"name":"prove","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"refund","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"relay","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"address","name":"relayer","type":"address"}],"name":"relay","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":{"notice":"Initiates bridge on origin chain to be relayed by off-chain relayer"},"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256),(address,int256,bytes,uint256,bytes))":{"notice":"Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability to provide temporary exclusivity fill rights for the quote relayer."},"bridgeProofs(bytes32)":{"notice":"Returns the timestamp and relayer of a bridge proof"},"bridgeRelays(bytes32)":{"notice":"Checks if a transaction has been relayed"},"bridgeStatuses(bytes32)":{"notice":"Returns the status of a bridge transaction"},"canClaim(bytes32,address)":{"notice":"Checks if the dispute period has passed so bridge deposit can be claimed"},"claim(bytes)":{"notice":"Completes bridge transaction on origin chain by claiming originally deposited capital.Can only send funds to the relayer address on the proof."},"claim(bytes,address)":{"notice":"Completes bridge transaction on origin chain by claiming originally deposited capital"},"dispute(bytes32)":{"notice":"Disputes an outstanding proof in case relayer provided dest chain tx is invalid"},"getBridgeTransaction(bytes)":{"notice":"Decodes bridge request into a bridge transaction"},"getBridgeTransactionV2(bytes)":{"notice":"Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2"},"prove(bytes,bytes32)":{"notice":"Provides proof on origin side that relayer provided funds on destination side of bridge transaction"},"prove(bytes32,bytes32,address)":{"notice":"Provides proof on origin side that relayer provided funds on destination side of bridge transaction"},"refund(bytes)":{"notice":"Refunds an outstanding bridge transaction in case optimistic bridging failed"},"relay(bytes)":{"notice":"Relays destination side of bridge transaction by off-chain relayer"},"relay(bytes,address)":{"notice":"Relays destination side of bridge transaction by off-chain relayer"}},"version":1},"developerDoc":{"kind":"dev","methods":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":{"params":{"params":"The parameters required to bridge"}},"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256),(address,int256,bytes,uint256,bytes))":{"params":{"params":"The parameters required to bridge","paramsV2":"The parameters for exclusivity fill rights (optional, can be left empty)"}},"bridgeProofs(bytes32)":{"params":{"transactionId":"The ID of the bridge transaction"},"returns":{"relayer":"The relayer address of the bridge proof","timestamp":"The timestamp of the bridge proof"}},"bridgeRelays(bytes32)":{"params":{"transactionId":"The ID of the transaction to check"},"returns":{"_0":"True if the transaction has been relayed, false otherwise"}},"bridgeStatuses(bytes32)":{"params":{"transactionId":"The ID of the bridge transaction"},"returns":{"_0":"BridgeStatus Status of the bridge transaction"}},"canClaim(bytes32,address)":{"params":{"relayer":"The address of the relayer attempting to claim","transactionId":"The transaction id associated with the encoded bridge transaction to check"}},"claim(bytes)":{"params":{"request":"The encoded bridge transaction to claim on origin chain"}},"claim(bytes,address)":{"params":{"request":"The encoded bridge transaction to claim on origin chain","to":"The recipient address of the funds"}},"dispute(bytes32)":{"params":{"transactionId":"The transaction id associated with the encoded bridge transaction to dispute"}},"getBridgeTransaction(bytes)":{"params":{"request":"The bridge request to decode"}},"getBridgeTransactionV2(bytes)":{"params":{"request":"The bridge request to decode"}},"prove(bytes,bytes32)":{"params":{"destTxHash":"The destination tx hash proving bridge transaction was relayed","request":"The encoded bridge transaction to prove on origin chain"}},"prove(bytes32,bytes32,address)":{"params":{"destTxHash":"The destination tx hash proving bridge transaction was relayed","relayer":"The address of the relaying entity which should have control of the origin funds when claimed","transactionId":"The transaction id associated with the encoded bridge transaction to prove"}},"refund(bytes)":{"params":{"request":"The encoded bridge transaction to refund"}},"relay(bytes)":{"params":{"request":"The encoded bridge transaction to relay on destination chain"}},"relay(bytes,address)":{"params":{"relayer":"The address of the relaying entity which should have control of the origin funds when claimed","request":"The encoded bridge transaction to relay on destination chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.24+commit.e11b9ed9\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"BridgeProofDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"BridgeProofProvided\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"quoteId\",\"type\":\"bytes\"}],\"name\":\"BridgeQuoteDetails\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainGasAmount\",\"type\":\"uint256\"}],\"name\":\"BridgeRelayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"}],\"name\":\"BridgeRequested\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeParams\",\"name\":\"params\",\"type\":\"tuple\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"quoteRelayer\",\"type\":\"address\"},{\"internalType\":\"int256\",\"name\":\"quoteExclusivitySeconds\",\"type\":\"int256\"},{\"internalType\":\"bytes\",\"name\":\"quoteId\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"zapNative\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"zapData\",\"type\":\"bytes\"}],\"internalType\":\"struct IFastBridgeV2.BridgeParamsV2\",\"name\":\"paramsV2\",\"type\":\"tuple\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"bridgeProofs\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"timestamp\",\"type\":\"uint96\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"bridgeRelays\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"bridgeStatuses\",\"outputs\":[{\"internalType\":\"enum IFastBridgeV2.BridgeStatus\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"canClaim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"dispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"getBridgeTransaction\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"originSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"sendChainGas\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeTransaction\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"getBridgeTransactionV2\",\"outputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"originChainId\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"destChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"originSender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destRecipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originFeeAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"nonce\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusivityRelayer\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exclusivityEndTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"zapNative\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"zapData\",\"type\":\"bytes\"}],\"internalType\":\"struct IFastBridgeV2.BridgeTransactionV2\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destTxHash\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"prove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"destTxHash\",\"type\":\"bytes32\"}],\"name\":\"prove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))\":{\"params\":{\"params\":\"The parameters required to bridge\"}},\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256),(address,int256,bytes,uint256,bytes))\":{\"params\":{\"params\":\"The parameters required to bridge\",\"paramsV2\":\"The parameters for exclusivity fill rights (optional, can be left empty)\"}},\"bridgeProofs(bytes32)\":{\"params\":{\"transactionId\":\"The ID of the bridge transaction\"},\"returns\":{\"relayer\":\"The relayer address of the bridge proof\",\"timestamp\":\"The timestamp of the bridge proof\"}},\"bridgeRelays(bytes32)\":{\"params\":{\"transactionId\":\"The ID of the transaction to check\"},\"returns\":{\"_0\":\"True if the transaction has been relayed, false otherwise\"}},\"bridgeStatuses(bytes32)\":{\"params\":{\"transactionId\":\"The ID of the bridge transaction\"},\"returns\":{\"_0\":\"BridgeStatus Status of the bridge transaction\"}},\"canClaim(bytes32,address)\":{\"params\":{\"relayer\":\"The address of the relayer attempting to claim\",\"transactionId\":\"The transaction id associated with the encoded bridge transaction to check\"}},\"claim(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to claim on origin chain\"}},\"claim(bytes,address)\":{\"params\":{\"request\":\"The encoded bridge transaction to claim on origin chain\",\"to\":\"The recipient address of the funds\"}},\"dispute(bytes32)\":{\"params\":{\"transactionId\":\"The transaction id associated with the encoded bridge transaction to dispute\"}},\"getBridgeTransaction(bytes)\":{\"params\":{\"request\":\"The bridge request to decode\"}},\"getBridgeTransactionV2(bytes)\":{\"params\":{\"request\":\"The bridge request to decode\"}},\"prove(bytes,bytes32)\":{\"params\":{\"destTxHash\":\"The destination tx hash proving bridge transaction was relayed\",\"request\":\"The encoded bridge transaction to prove on origin chain\"}},\"prove(bytes32,bytes32,address)\":{\"params\":{\"destTxHash\":\"The destination tx hash proving bridge transaction was relayed\",\"relayer\":\"The address of the relaying entity which should have control of the origin funds when claimed\",\"transactionId\":\"The transaction id associated with the encoded bridge transaction to prove\"}},\"refund(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to refund\"}},\"relay(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to relay on destination chain\"}},\"relay(bytes,address)\":{\"params\":{\"relayer\":\"The address of the relaying entity which should have control of the origin funds when claimed\",\"request\":\"The encoded bridge transaction to relay on destination chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))\":{\"notice\":\"Initiates bridge on origin chain to be relayed by off-chain relayer\"},\"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256),(address,int256,bytes,uint256,bytes))\":{\"notice\":\"Initiates bridge on origin chain to be relayed by off-chain relayer, with the ability to provide temporary exclusivity fill rights for the quote relayer.\"},\"bridgeProofs(bytes32)\":{\"notice\":\"Returns the timestamp and relayer of a bridge proof\"},\"bridgeRelays(bytes32)\":{\"notice\":\"Checks if a transaction has been relayed\"},\"bridgeStatuses(bytes32)\":{\"notice\":\"Returns the status of a bridge transaction\"},\"canClaim(bytes32,address)\":{\"notice\":\"Checks if the dispute period has passed so bridge deposit can be claimed\"},\"claim(bytes)\":{\"notice\":\"Completes bridge transaction on origin chain by claiming originally deposited capital.Can only send funds to the relayer address on the proof.\"},\"claim(bytes,address)\":{\"notice\":\"Completes bridge transaction on origin chain by claiming originally deposited capital\"},\"dispute(bytes32)\":{\"notice\":\"Disputes an outstanding proof in case relayer provided dest chain tx is invalid\"},\"getBridgeTransaction(bytes)\":{\"notice\":\"Decodes bridge request into a bridge transaction\"},\"getBridgeTransactionV2(bytes)\":{\"notice\":\"Decodes bridge request into a bridge transaction V2 struct used by FastBridgeV2\"},\"prove(bytes,bytes32)\":{\"notice\":\"Provides proof on origin side that relayer provided funds on destination side of bridge transaction\"},\"prove(bytes32,bytes32,address)\":{\"notice\":\"Provides proof on origin side that relayer provided funds on destination side of bridge transaction\"},\"refund(bytes)\":{\"notice\":\"Refunds an outstanding bridge transaction in case optimistic bridging failed\"},\"relay(bytes)\":{\"notice\":\"Relays destination side of bridge transaction by off-chain relayer\"},\"relay(bytes,address)\":{\"notice\":\"Relays destination side of bridge transaction by off-chain relayer\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/BridgeTransactionV2.sol\":\"IFastBridgeV2\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/BridgeTransactionV2.sol\":{\"keccak256\":\"0x84a8a79ef0e3a7c425f5af24e773f8ad7177797466cc0c3315dee333da4e2477\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://810ce2d94aac2e372f9fb90d8f7b18cfd3bce24e9005e6b7aac569e6517a03d1\",\"dweb:/ipfs/QmbiF4SoMDGUTTL3Zo2fB67oSqFY9SY6Whx8GM9gpUNkbf\"]}},\"version\":1}"},"hashes":{"bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256))":"45851694","bridge((uint32,address,address,address,address,uint256,uint256,bool,uint256),(address,int256,bytes,uint256,bytes))":"bfc7c607","bridgeProofs(bytes32)":"91ad5039","bridgeRelays(bytes32)":"8379a24f","bridgeStatuses(bytes32)":"051287bc","canClaim(bytes32,address)":"aa9641ab","claim(bytes)":"c63ff8dd","claim(bytes,address)":"41fcb612","dispute(bytes32)":"add98c70","getBridgeTransaction(bytes)":"ac11fb1a","getBridgeTransactionV2(bytes)":"5aa6ccba","prove(bytes,bytes32)":"886d36ff","prove(bytes32,bytes32,address)":"18e4357d","refund(bytes)":"5eb7d946","relay(bytes)":"8f0d6f17","relay(bytes,address)":"9c9545f0"}}}