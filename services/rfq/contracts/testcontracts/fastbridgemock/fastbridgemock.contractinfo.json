{"solidity/FastBridgeMock.sol:AccessControl":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module that allows children to implement role-based access control mechanisms. This is a lightweight version that doesn't allow enumerating role members except through off-chain means by accessing the contract event logs. Some applications may benefit from on-chain enumerability, for those cases see {AccessControlEnumerable}. Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be unique. The best way to achieve this is by using `public constant` hash digests: ```solidity bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\"); ``` Roles can be used to represent a set of permissions. To restrict access to a function call, use {hasRole}: ```solidity function foo() public {     require(hasRole(MY_ROLE, msg.sender));     ... } ``` Roles can be granted and revoked dynamically via the {grantRole} and {revokeRole} functions. Each role has an associated admin role, and only accounts that have a role's admin role can call {grantRole} and {revokeRole}. By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means that only accounts with this role will be able to grant or revoke other roles. More complex role relationships can be created by using {_setRoleAdmin}. WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to grant and revoke this role. Extra precautions should be taken to secure accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules} to enforce additional security measures for this role.","errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module that allows children to implement role-based access control mechanisms. This is a lightweight version that doesn't allow enumerating role members except through off-chain means by accessing the contract event logs. Some applications may benefit from on-chain enumerability, for those cases see {AccessControlEnumerable}. Roles are referred to by their `bytes32` identifier. These should be exposed in the external API and be unique. The best way to achieve this is by using `public constant` hash digests: ```solidity bytes32 public constant MY_ROLE = keccak256(\\\"MY_ROLE\\\"); ``` Roles can be used to represent a set of permissions. To restrict access to a function call, use {hasRole}: ```solidity function foo() public {     require(hasRole(MY_ROLE, msg.sender));     ... } ``` Roles can be granted and revoked dynamically via the {grantRole} and {revokeRole} functions. Each role has an associated admin role, and only accounts that have a role's admin role can call {grantRole} and {revokeRole}. By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means that only accounts with this role will be able to grant or revoke other roles. More complex role relationships can be created by using {_setRoleAdmin}. WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to grant and revoke this role. Extra precautions should be taken to secure accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules} to enforce additional security measures for this role.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"AccessControl\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","getRoleAdmin(bytes32)":"248a9ca3","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","supportsInterface(bytes4)":"01ffc9a7"}},"solidity/FastBridgeMock.sol:Admin":{"code":"0x608060405234801561001057600080fd5b50604051610ea0380380610ea083398101604081905261002f91610196565b806001600160a01b03811661005e57604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b6100678161007a565b50610073600082610096565b50506101c6565b600180546001600160a01b031916905561009381610146565b50565b60008281526002602090815260408083206001600160a01b038516845290915281205460ff1661013c5760008381526002602090815260408083206001600160a01b03861684529091529020805460ff191660011790556100f43390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a4506001610140565b5060005b92915050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000602082840312156101a857600080fd5b81516001600160a01b03811681146101bf57600080fd5b9392505050565b610ccb806101d56000396000f3fe608060405234801561001057600080fd5b50600436106101365760003560e01c80638da5cb5b116100b2578063b623501611610081578063dd39f00d11610066578063dd39f00d146102f3578063e30c397814610306578063f2fde38b1461032457600080fd5b8063b6235016146102cd578063d547741f146102e057600080fd5b80638da5cb5b1461021957806391d1485414610258578063926d7d7f1461029e578063a217fddf146102c557600080fd5b806336568abe116101095780636913a63c116100ee5780636913a63c146101f6578063715018a61461020957806379ba50971461021157600080fd5b806336568abe146101d057806360f0a5ac146101e357600080fd5b806301ffc9a71461013b57806303ed0ee514610163578063248a9ca3146101985780632f2ff15d146101bb575b600080fd5b61014e610149366004610bc3565b610337565b60405190151581526020015b60405180910390f35b61018a7f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d81565b60405190815260200161015a565b61018a6101a6366004610c0c565b60009081526002602052604090206001015490565b6101ce6101c9366004610c4e565b6103d0565b005b6101ce6101de366004610c4e565b6103fb565b6101ce6101f1366004610c7a565b610459565b6101ce610204366004610c7a565b61050c565b6101ce6105b8565b6101ce6105cc565b60005473ffffffffffffffffffffffffffffffffffffffff165b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161015a565b61014e610266366004610c4e565b600091825260026020908152604080842073ffffffffffffffffffffffffffffffffffffffff93909316845291905290205460ff1690565b61018a7fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc481565b61018a600081565b6101ce6102db366004610c7a565b610648565b6101ce6102ee366004610c4e565b6106f4565b6101ce610301366004610c7a565b610719565b60015473ffffffffffffffffffffffffffffffffffffffff16610233565b6101ce610332366004610c7a565b6107c5565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b0000000000000000000000000000000000000000000000000000000014806103ca57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6000828152600260205260409020600101546103eb81610875565b6103f5838361087f565b50505050565b73ffffffffffffffffffffffffffffffffffffffff8116331461044a576040517f6697b23200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610454828261097f565b505050565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661049457600080fd5b6104be7fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc48261097f565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f10e1f7ce9fd7d1b90a66d13a2ab3cb8dd7f29f3f8d520b143b063ccfbab6906b906020015b60405180910390a150565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661054757600080fd5b6105717f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d8261087f565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f93405f05cd04f0d1bd875f2de00f1f3890484ffd0589248953bdfd29ba7f2f5990602001610501565b6105c0610a3e565b6105ca6000610a91565b565b600154339073ffffffffffffffffffffffffffffffffffffffff16811461063c576040517f118cdaa700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff821660048201526024015b60405180910390fd5b61064581610a91565b50565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661068357600080fd5b6106ad7f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d8261097f565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f59926e0a78d12238b668b31c8e3f6ece235a59a00ede111d883e255b68c4d04890602001610501565b60008281526002602052604090206001015461070f81610875565b6103f5838361097f565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661075457600080fd5b61077e7fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc48261087f565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f03580ee9f53a62b7cb409a2cb56f9be87747dd15017afc5cef6eef321e4fb2c590602001610501565b6107cd610a3e565b6001805473ffffffffffffffffffffffffffffffffffffffff83167fffffffffffffffffffffffff0000000000000000000000000000000000000000909116811790915561083060005473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b6106458133610ac2565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915281205460ff1661097757600083815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff86168452909152902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790556109153390565b73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45060016103ca565b5060006103ca565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915281205460ff161561097757600083815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8616808552925280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45060016103ca565b60005473ffffffffffffffffffffffffffffffffffffffff1633146105ca576040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152602401610633565b600180547fffffffffffffffffffffffff000000000000000000000000000000000000000016905561064581610b4e565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915290205460ff16610b4a576040517fe2517d3f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8216600482015260248101839052604401610633565b5050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600060208284031215610bd557600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610c0557600080fd5b9392505050565b600060208284031215610c1e57600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610c4957600080fd5b919050565b60008060408385031215610c6157600080fd5b82359150610c7160208401610c25565b90509250929050565b600060208284031215610c8c57600080fd5b610c0582610c2556fea2646970667358221220ccd11a2de9b678965ca74c70a1a5609affaeda2f7720b8737490f4a1218d1d1164736f6c63430008140033","runtime-code":"0x608060405234801561001057600080fd5b50600436106101365760003560e01c80638da5cb5b116100b2578063b623501611610081578063dd39f00d11610066578063dd39f00d146102f3578063e30c397814610306578063f2fde38b1461032457600080fd5b8063b6235016146102cd578063d547741f146102e057600080fd5b80638da5cb5b1461021957806391d1485414610258578063926d7d7f1461029e578063a217fddf146102c557600080fd5b806336568abe116101095780636913a63c116100ee5780636913a63c146101f6578063715018a61461020957806379ba50971461021157600080fd5b806336568abe146101d057806360f0a5ac146101e357600080fd5b806301ffc9a71461013b57806303ed0ee514610163578063248a9ca3146101985780632f2ff15d146101bb575b600080fd5b61014e610149366004610bc3565b610337565b60405190151581526020015b60405180910390f35b61018a7f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d81565b60405190815260200161015a565b61018a6101a6366004610c0c565b60009081526002602052604090206001015490565b6101ce6101c9366004610c4e565b6103d0565b005b6101ce6101de366004610c4e565b6103fb565b6101ce6101f1366004610c7a565b610459565b6101ce610204366004610c7a565b61050c565b6101ce6105b8565b6101ce6105cc565b60005473ffffffffffffffffffffffffffffffffffffffff165b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161015a565b61014e610266366004610c4e565b600091825260026020908152604080842073ffffffffffffffffffffffffffffffffffffffff93909316845291905290205460ff1690565b61018a7fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc481565b61018a600081565b6101ce6102db366004610c7a565b610648565b6101ce6102ee366004610c4e565b6106f4565b6101ce610301366004610c7a565b610719565b60015473ffffffffffffffffffffffffffffffffffffffff16610233565b6101ce610332366004610c7a565b6107c5565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b0000000000000000000000000000000000000000000000000000000014806103ca57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6000828152600260205260409020600101546103eb81610875565b6103f5838361087f565b50505050565b73ffffffffffffffffffffffffffffffffffffffff8116331461044a576040517f6697b23200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610454828261097f565b505050565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661049457600080fd5b6104be7fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc48261097f565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f10e1f7ce9fd7d1b90a66d13a2ab3cb8dd7f29f3f8d520b143b063ccfbab6906b906020015b60405180910390a150565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661054757600080fd5b6105717f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d8261087f565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f93405f05cd04f0d1bd875f2de00f1f3890484ffd0589248953bdfd29ba7f2f5990602001610501565b6105c0610a3e565b6105ca6000610a91565b565b600154339073ffffffffffffffffffffffffffffffffffffffff16811461063c576040517f118cdaa700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff821660048201526024015b60405180910390fd5b61064581610a91565b50565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661068357600080fd5b6106ad7f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d8261097f565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f59926e0a78d12238b668b31c8e3f6ece235a59a00ede111d883e255b68c4d04890602001610501565b60008281526002602052604090206001015461070f81610875565b6103f5838361097f565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661075457600080fd5b61077e7fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc48261087f565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f03580ee9f53a62b7cb409a2cb56f9be87747dd15017afc5cef6eef321e4fb2c590602001610501565b6107cd610a3e565b6001805473ffffffffffffffffffffffffffffffffffffffff83167fffffffffffffffffffffffff0000000000000000000000000000000000000000909116811790915561083060005473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b6106458133610ac2565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915281205460ff1661097757600083815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff86168452909152902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff001660011790556109153390565b73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a45060016103ca565b5060006103ca565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915281205460ff161561097757600083815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8616808552925280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a45060016103ca565b60005473ffffffffffffffffffffffffffffffffffffffff1633146105ca576040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152602401610633565b600180547fffffffffffffffffffffffff000000000000000000000000000000000000000016905561064581610b4e565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915290205460ff16610b4a576040517fe2517d3f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8216600482015260248101839052604401610633565b5050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600060208284031215610bd557600080fd5b81357fffffffff0000000000000000000000000000000000000000000000000000000081168114610c0557600080fd5b9392505050565b600060208284031215610c1e57600080fd5b5035919050565b803573ffffffffffffffffffffffffffffffffffffffff81168114610c4957600080fd5b919050565b60008060408385031215610c6157600080fd5b82359150610c7160208401610c25565b90509250929050565b600060208284031215610c8c57600080fd5b610c0582610c2556fea2646970667358221220ccd11a2de9b678965ca74c70a1a5609affaeda2f7720b8737490f4a1218d1d1164736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"18358:1328:0:-:0;;;18801:99;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;18837:6;-1:-1:-1;;;;;2207:26:0;;2203:95;;2256:31;;-1:-1:-1;;;2256:31:0;;2284:1;2256:31;;;455:51:1;428:18;;2256:31:0;;;;;;;2203:95;2307:32;2326:12;2307:18;:32::i;:::-;-1:-1:-1;18855:38:0::1;13063:4;18886:6:::0;18855:10:::1;:38::i;:::-;;18801:99:::0;18358:1328;;5750:153;5839:13;5832:20;;-1:-1:-1;;;;;;5832:20:0;;;5862:34;5887:8;5862:24;:34::i;:::-;5750:153;:::o;17010:316::-;17087:4;13785:12;;;:6;:12;;;;;;;;-1:-1:-1;;;;;13785:29:0;;;;;;;;;;;;17103:217;;17146:12;;;;:6;:12;;;;;;;;-1:-1:-1;;;;;17146:29:0;;;;;;;;;:36;;-1:-1:-1;;17146:36:0;17178:4;17146:36;;;17228:12;880:10;;801:96;17228:12;-1:-1:-1;;;;;17201:40:0;17219:7;-1:-1:-1;;;;;17201:40:0;17213:4;17201:40;;;;;;;;;;-1:-1:-1;17262:4:0;17255:11;;17103:217;-1:-1:-1;17304:5:0;17103:217;17010:316;;;;:::o;3846:187::-;3919:16;3938:6;;-1:-1:-1;;;;;3954:17:0;;;-1:-1:-1;;;;;;3954:17:0;;;;;;3986:40;;3938:6;;;;;;;3986:40;;3919:16;3986:40;3909:124;3846:187;:::o;14:290:1:-;84:6;137:2;125:9;116:7;112:23;108:32;105:52;;;153:1;150;143:12;105:52;179:16;;-1:-1:-1;;;;;224:31:1;;214:42;;204:70;;270:1;267;260:12;204:70;293:5;14:290;-1:-1:-1;;;14:290:1:o;309:203::-;18358:1328:0;;;;;;","srcMapRuntime":"18358:1328:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13396:202;;;;;;:::i;:::-;;:::i;:::-;;;516:14:1;;509:22;491:41;;479:2;464:18;13396:202:0;;;;;;;;18488:60;;18525:23;18488:60;;;;;689:25:1;;;677:2;662:18;18488:60:0;543:177:1;14641:120:0;;;;;;:::i;:::-;14706:7;14732:12;;;:6;:12;;;;;:22;;;;14641:120;15057:136;;;;;;:::i;:::-;;:::i;:::-;;16159:245;;;;;;:::i;:::-;;:::i;19105:199::-;;;;;;:::i;:::-;;:::i;19310:181::-;;;;;;:::i;:::-;;:::i;3227:101::-;;;:::i;5983:229::-;;;:::i;2572:85::-;2618:7;2644:6;;;2572:85;;;1737:42:1;1725:55;;;1707:74;;1695:2;1680:18;2572:85:0;1561:226:1;13685:136:0;;;;;;:::i;:::-;13762:4;13785:12;;;:6;:12;;;;;;;;:29;;;;;;;;;;;;;;;;13685:136;18418:64;;18457:25;18418:64;;13018:49;;13063:4;13018:49;;19497:187;;;;;;:::i;:::-;;:::i;15473:138::-;;;;;;:::i;:::-;;:::i;18906:193::-;;;;;;:::i;:::-;;:::i;5096:99::-;5175:13;;;;5096:99;;5388:178;;;;;;:::i;:::-;;:::i;13396:202::-;13481:4;13504:47;;;13519:32;13504:47;;:87;;-1:-1:-1;11087:25:0;11072:40;;;;13555:36;13497:94;13396:202;-1:-1:-1;;13396:202:0:o;15057:136::-;14706:7;14732:12;;;:6;:12;;;;;:22;;;13295:16;13306:4;13295:10;:16::i;:::-;15161:25:::1;15172:4;15178:7;15161:10;:25::i;:::-;;15057:136:::0;;;:::o;16159:245::-;16252:34;;;880:10;16252:34;16248:102;;16309:30;;;;;;;;;;;;;;16248:102;16360:37;16372:4;16378:18;16360:11;:37::i;:::-;;16159:245;;:::o;19105:199::-;19201:10;13063:4;13785:29;;;:12;;:29;:12;:29;;;;;19165:48;;;;;;19223:35;18457:25;19249:8;19223:11;:35::i;:::-;-1:-1:-1;19273:24:0;;1737:42:1;1725:55;;1707:74;;19273:24:0;;1695:2:1;1680:18;19273:24:0;;;;;;;;19105:199;:::o;19310:181::-;19399:10;13063:4;13785:29;;;:12;;:29;:12;:29;;;;;19363:48;;;;;;19421:30;18525:23;19444:6;19421:10;:30::i;:::-;-1:-1:-1;19466:18:0;;1737:42:1;1725:55;;1707:74;;19466:18:0;;1695:2:1;1680:18;19466::0;1561:226:1;3227:101:0;2465:13;:11;:13::i;:::-;3291:30:::1;3318:1;3291:18;:30::i;:::-;3227:101::o:0;5983:229::-;5175:13;;880:10;;6078:24;5175:13;6078:24;;6074:96;;6125:34;;;;;1737:42:1;1725:55;;6125:34:0;;;1707:74:1;1680:18;;6125:34:0;;;;;;;;6074:96;6179:26;6198:6;6179:18;:26::i;:::-;6025:187;5983:229::o;19497:187::-;19589:10;13063:4;13785:29;;;:12;;:29;:12;:29;;;;;19553:48;;;;;;19611:31;18525:23;19635:6;19611:11;:31::i;:::-;-1:-1:-1;19657:20:0;;1737:42:1;1725:55;;1707:74;;19657:20:0;;1695:2:1;1680:18;19657:20:0;1561:226:1;15473:138:0;14706:7;14732:12;;;:6;:12;;;;;:22;;;13295:16;13306:4;13295:10;:16::i;:::-;15578:26:::1;15590:4;15596:7;15578:11;:26::i;18906:193::-:0;18999:10;13063:4;13785:29;;;:12;;:29;:12;:29;;;;;18963:48;;;;;;19021:34;18457:25;19046:8;19021:10;:34::i;:::-;-1:-1:-1;19070:22:0;;1737:42:1;1725:55;;1707:74;;19070:22:0;;1695:2:1;1680:18;19070:22:0;1561:226:1;5388:178:0;2465:13;:11;:13::i;:::-;5477::::1;:24:::0;;::::1;::::0;::::1;::::0;;;::::1;::::0;::::1;::::0;;;5541:7:::1;2618::::0;2644:6;;;;2572:85;5541:7:::1;5516:43;;;;;;;;;;;;5388:178:::0;:::o;14030:103::-;14096:30;14107:4;880:10;14096;:30::i;17010:316::-;17087:4;13785:12;;;:6;:12;;;;;;;;:29;;;;;;;;;;;;;17103:217;;17146:12;;;;:6;:12;;;;;;;;:29;;;;;;;;;;:36;;;;17178:4;17146:36;;;17228:12;880:10;;801:96;17228:12;17201:40;;17219:7;17201:40;;17213:4;17201:40;;;;;;;;;;-1:-1:-1;17262:4:0;17255:11;;17103:217;-1:-1:-1;17304:5:0;17297:12;;17561:317;17639:4;13785:12;;;:6;:12;;;;;;;;:29;;;;;;;;;;;;;17655:217;;;17729:5;17697:12;;;:6;:12;;;;;;;;:29;;;;;;;;;;;:37;;;;;;17753:40;880:10;;17697:12;;17753:40;;17729:5;17753:40;-1:-1:-1;17814:4:0;17807:11;;2730:162;2618:7;2644:6;2789:23;2644:6;880:10;2789:23;2785:101;;2835:40;;;;;880:10;2835:40;;;1707:74:1;1680:18;;2835:40:0;1561:226:1;5750:153:0;5839:13;5832:20;;;;;;5862:34;5887:8;5862:24;:34::i;14263:197::-;13762:4;13785:12;;;:6;:12;;;;;;;;:29;;;;;;;;;;;;;14346:108;;14396:47;;;;;1996:42:1;1984:55;;14396:47:0;;;1966:74:1;2056:18;;;2049:34;;;1939:18;;14396:47:0;1792:297:1;14346:108:0;14263:197;;:::o;3846:187::-;3919:16;3938:6;;;3954:17;;;;;;;;;;3986:40;;3938:6;;;;;;;3986:40;;3919:16;3986:40;3909:124;3846:187;:::o;14:332:1:-;72:6;125:2;113:9;104:7;100:23;96:32;93:52;;;141:1;138;131:12;93:52;180:9;167:23;230:66;223:5;219:78;212:5;209:89;199:117;;312:1;309;302:12;199:117;335:5;14:332;-1:-1:-1;;;14:332:1:o;725:180::-;784:6;837:2;825:9;816:7;812:23;808:32;805:52;;;853:1;850;843:12;805:52;-1:-1:-1;876:23:1;;725:180;-1:-1:-1;725:180:1:o;910:196::-;978:20;;1038:42;1027:54;;1017:65;;1007:93;;1096:1;1093;1086:12;1007:93;910:196;;;:::o;1111:254::-;1179:6;1187;1240:2;1228:9;1219:7;1215:23;1211:32;1208:52;;;1256:1;1253;1246:12;1208:52;1292:9;1279:23;1269:33;;1321:38;1355:2;1344:9;1340:18;1321:38;:::i;:::-;1311:48;;1111:254;;;;;:::o;1370:186::-;1429:6;1482:2;1470:9;1461:7;1457:23;1453:32;1450:52;;;1498:1;1495;1488:12;1450:52;1521:29;1540:9;1521:29;:::i","abiDefinition":[{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"guard","type":"address"}],"name":"GuardAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"guard","type":"address"}],"name":"GuardRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferStarted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"relayer","type":"address"}],"name":"RelayerAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"relayer","type":"address"}],"name":"RelayerRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"GUARD_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"RELAYER_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"acceptOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_guard","type":"address"}],"name":"addGuard","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_relayer","type":"address"}],"name":"addRelayer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_guard","type":"address"}],"name":"removeGuard","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_relayer","type":"address"}],"name":"removeRelayer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}],"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"acceptOwnership()":{"details":"The new owner accepts the ownership transfer."},"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"owner()":{"details":"Returns the address of the current owner."},"pendingOwner()":{"details":"Returns the address of the pending owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."},"transferOwnership(address)":{"details":"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"GuardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"GuardRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GUARD_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAYER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guard\",\"type\":\"address\"}],\"name\":\"addGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"addRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guard\",\"type\":\"address\"}],\"name\":\"removeGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"removeRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}],\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"Admin\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","GUARD_ROLE()":"03ed0ee5","RELAYER_ROLE()":"926d7d7f","acceptOwnership()":"79ba5097","addGuard(address)":"6913a63c","addRelayer(address)":"dd39f00d","getRoleAdmin(bytes32)":"248a9ca3","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","owner()":"8da5cb5b","pendingOwner()":"e30c3978","removeGuard(address)":"b6235016","removeRelayer(address)":"60f0a5ac","renounceOwnership()":"715018a6","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","supportsInterface(bytes4)":"01ffc9a7","transferOwnership(address)":"f2fde38b"}},"solidity/FastBridgeMock.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"Context\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{}},"solidity/FastBridgeMock.sol:ERC165":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Implementation of the {IERC165} interface. Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ```","kind":"dev","methods":{"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Implementation of the {IERC165} interface. Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check for the additional interface id that will be supported. For example: ```solidity function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId); } ```\",\"kind\":\"dev\",\"methods\":{\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"ERC165\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{"supportsInterface(bytes4)":"01ffc9a7"}},"solidity/FastBridgeMock.sol:FastBridgeMock":{"code":"0x60a06040523480156200001157600080fd5b506040516200187f3803806200187f8339810160408190526200003491620001ac565b80806001600160a01b0381166200006557604051631e4fbdf760e01b81526000600482015260240160405180910390fd5b62000070816200008b565b506200007e600082620000a9565b50504360805250620001de565b600180546001600160a01b0319169055620000a6816200015c565b50565b60008281526002602090815260408083206001600160a01b038516845290915281205460ff16620001525760008381526002602090815260408083206001600160a01b03861684529091529020805460ff19166001179055620001093390565b6001600160a01b0316826001600160a01b0316847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a450600162000156565b5060005b92915050565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b600060208284031215620001bf57600080fd5b81516001600160a01b0381168114620001d757600080fd5b9392505050565b608051611685620001fa60003960006104ad01526116856000f3fe6080604052600436106101c25760003560e01c80638da5cb5b116100f7578063aedf009d11610095578063dd39f00d11610064578063dd39f00d14610560578063e30c397814610580578063ef059bd3146102e1578063f2fde38b146105ab57600080fd5b8063aedf009d146104ea578063affed0e01461050a578063b623501614610520578063d547741f1461054057600080fd5b8063926d7d7f116100d1578063926d7d7f14610452578063a217fddf14610486578063a3ec191a1461049b578063add98c70146104cf57600080fd5b80638da5cb5b146103a55780638f0d6f17146103f157806391d14854146103ff57600080fd5b806341fcb612116101645780636d708f4b1161013e5780636d708f4b14610340578063715018a61461036057806379ba509714610375578063886d36ff1461038a57600080fd5b806341fcb612146102e157806360f0a5ac146103005780636913a63c1461032057600080fd5b8063248a9ca3116101a0578063248a9ca3146102515780632694648f146102815780632f2ff15d146102a157806336568abe146102c157600080fd5b806301ffc9a7146101c757806303ed0ee5146101fc5780630728e3ad1461023e575b600080fd5b3480156101d357600080fd5b506101e76101e236600461103b565b6105cb565b60405190151581526020015b60405180910390f35b34801561020857600080fd5b506102307f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d81565b6040519081526020016101f3565b61024f61024c36600461118e565b50565b005b34801561025d57600080fd5b5061023061026c3660046111aa565b60009081526002602052604090206001015490565b34801561028d57600080fd5b5061024f61029c3660046111c3565b610664565b3480156102ad57600080fd5b5061024f6102bc366004611218565b6106d0565b3480156102cd57600080fd5b5061024f6102dc366004611218565b6106fb565b3480156102ed57600080fd5b5061024f6102fc3660046112ef565b5050565b34801561030c57600080fd5b5061024f61031b366004611334565b610759565b34801561032c57600080fd5b5061024f61033b366004611334565b61080c565b34801561034c57600080fd5b5061024f61035b36600461134f565b6108b8565b34801561036c57600080fd5b5061024f6109f7565b34801561038157600080fd5b5061024f610a0b565b34801561039657600080fd5b5061024f6102fc36600461138d565b3480156103b157600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff165b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101f3565b61024f61024c3660046113d2565b34801561040b57600080fd5b506101e761041a366004611218565b600091825260026020908152604080842073ffffffffffffffffffffffffffffffffffffffff93909316845291905290205460ff1690565b34801561045e57600080fd5b506102307fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc481565b34801561049257600080fd5b50610230600081565b3480156104a757600080fd5b506102307f000000000000000000000000000000000000000000000000000000000000000081565b3480156104db57600080fd5b5061024f61024c3660046111aa565b3480156104f657600080fd5b5061024f61050536600461140f565b610a84565b34801561051657600080fd5b5061023060035481565b34801561052c57600080fd5b5061024f61053b366004611334565b610ac4565b34801561054c57600080fd5b5061024f61055b366004611218565b610b70565b34801561056c57600080fd5b5061024f61057b366004611334565b610b95565b34801561058c57600080fd5b5060015473ffffffffffffffffffffffffffffffffffffffff166103cc565b3480156105b757600080fd5b5061024f6105c6366004611334565b610c41565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b00000000000000000000000000000000000000000000000000000000148061065e57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6040805186815273ffffffffffffffffffffffffffffffffffffffff868116602083015285811682840152841660608201526080810183905290517f7212c977e94cbafc6e4685aee721574624efaa1993ce2b48d1bb37c27ffa13f49181900360a00190a15050505050565b6000828152600260205260409020600101546106eb81610cf1565b6106f58383610cfb565b50505050565b73ffffffffffffffffffffffffffffffffffffffff8116331461074a576040517f6697b23200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6107548282610dfb565b505050565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661079457600080fd5b6107be7fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc482610dfb565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f10e1f7ce9fd7d1b90a66d13a2ab3cb8dd7f29f3f8d520b143b063ccfbab6906b906020015b60405180910390a150565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661084757600080fd5b6108717f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d82610cfb565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f93405f05cd04f0d1bd875f2de00f1f3890484ffd0589248953bdfd29ba7f2f5990602001610801565b60006040518061014001604052804663ffffffff168152602001836000015163ffffffff1681526020013373ffffffffffffffffffffffffffffffffffffffff168152602001836020015173ffffffffffffffffffffffffffffffffffffffff168152602001836040015173ffffffffffffffffffffffffffffffffffffffff168152602001836060015173ffffffffffffffffffffffffffffffffffffffff168152602001836080015181526020018360a0015181526020018360c0015181526020016003600081548092919061098f90611466565b9091555090526040516109a591906020016114c5565b60405160208183030381529060405290507f2a8233b619c9d479346e133f609855c0a94d89fbcfa62f846a9f0cfdd1198ccf8433836040516109e9939291906115be565b60405180910390a150505050565b6109ff610eba565b610a096000610f0d565b565b600154339073ffffffffffffffffffffffffffffffffffffffff168114610a7b576040517f118cdaa700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff821660048201526024015b60405180910390fd5b61024c81610f0d565b7f2a8233b619c9d479346e133f609855c0a94d89fbcfa62f846a9f0cfdd1198ccf838383604051610ab7939291906115be565b60405180910390a1505050565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff16610aff57600080fd5b610b297f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d82610dfb565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f59926e0a78d12238b668b31c8e3f6ece235a59a00ede111d883e255b68c4d04890602001610801565b600082815260026020526040902060010154610b8b81610cf1565b6106f58383610dfb565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff16610bd057600080fd5b610bfa7fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc482610cfb565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f03580ee9f53a62b7cb409a2cb56f9be87747dd15017afc5cef6eef321e4fb2c590602001610801565b610c49610eba565b6001805473ffffffffffffffffffffffffffffffffffffffff83167fffffffffffffffffffffffff00000000000000000000000000000000000000009091168117909155610cac60005473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b61024c8133610f3e565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915281205460ff16610df357600083815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff86168452909152902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001179055610d913390565b73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a450600161065e565b50600061065e565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915281205460ff1615610df357600083815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8616808552925280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a450600161065e565b60005473ffffffffffffffffffffffffffffffffffffffff163314610a09576040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152602401610a72565b600180547fffffffffffffffffffffffff000000000000000000000000000000000000000016905561024c81610fc6565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915290205460ff166102fc576040517fe2517d3f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8216600482015260248101839052604401610a72565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006020828403121561104d57600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461107d57600080fd5b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160e0810167ffffffffffffffff811182821017156110d6576110d6611084565b60405290565b803573ffffffffffffffffffffffffffffffffffffffff8116811461110057600080fd5b919050565b600060e0828403121561111757600080fd5b61111f6110b3565b9050813563ffffffff8116811461113557600080fd5b8152611143602083016110dc565b6020820152611154604083016110dc565b6040820152611165606083016110dc565b60608201526080820135608082015260a082013560a082015260c082013560c082015292915050565b600060e082840312156111a057600080fd5b61107d8383611105565b6000602082840312156111bc57600080fd5b5035919050565b600080600080600060a086880312156111db57600080fd5b853594506111eb602087016110dc565b93506111f9604087016110dc565b9250611207606087016110dc565b949793965091946080013592915050565b6000806040838503121561122b57600080fd5b8235915061123b602084016110dc565b90509250929050565b600082601f83011261125557600080fd5b813567ffffffffffffffff8082111561127057611270611084565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019082821181831017156112b6576112b6611084565b816040528381528660208588010111156112cf57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806040838503121561130257600080fd5b823567ffffffffffffffff81111561131957600080fd5b61132585828601611244565b92505061123b602084016110dc565b60006020828403121561134657600080fd5b61107d826110dc565b6000806000610120848603121561136557600080fd5b83359250611375602085016110dc565b91506113848560408601611105565b90509250925092565b600080604083850312156113a057600080fd5b823567ffffffffffffffff8111156113b757600080fd5b6113c385828601611244565b95602094909401359450505050565b6000602082840312156113e457600080fd5b813567ffffffffffffffff8111156113fb57600080fd5b61140784828501611244565b949350505050565b60008060006060848603121561142457600080fd5b83359250611434602085016110dc565b9150604084013567ffffffffffffffff81111561145057600080fd5b61145c86828701611244565b9150509250925092565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036114be577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b815163ffffffff168152610140810160208301516114eb602084018263ffffffff169052565b506040830151611513604084018273ffffffffffffffffffffffffffffffffffffffff169052565b50606083015161153b606084018273ffffffffffffffffffffffffffffffffffffffff169052565b506080830151611563608084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060a083015161158b60a084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060c083015160c083015260e083015160e083015261010080840151818401525061012080840151818401525092915050565b8381526000602073ffffffffffffffffffffffffffffffffffffffff85168184015260606040840152835180606085015260005b8181101561160e578581018301518582016080015282016115f2565b5060006080828601015260807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168501019250505094935050505056fea2646970667358221220cb669a3be6f16cc68af0cd12fd9ca4ed54699359efbf823316b0c55831adbb1164736f6c63430008140033","runtime-code":"0x6080604052600436106101c25760003560e01c80638da5cb5b116100f7578063aedf009d11610095578063dd39f00d11610064578063dd39f00d14610560578063e30c397814610580578063ef059bd3146102e1578063f2fde38b146105ab57600080fd5b8063aedf009d146104ea578063affed0e01461050a578063b623501614610520578063d547741f1461054057600080fd5b8063926d7d7f116100d1578063926d7d7f14610452578063a217fddf14610486578063a3ec191a1461049b578063add98c70146104cf57600080fd5b80638da5cb5b146103a55780638f0d6f17146103f157806391d14854146103ff57600080fd5b806341fcb612116101645780636d708f4b1161013e5780636d708f4b14610340578063715018a61461036057806379ba509714610375578063886d36ff1461038a57600080fd5b806341fcb612146102e157806360f0a5ac146103005780636913a63c1461032057600080fd5b8063248a9ca3116101a0578063248a9ca3146102515780632694648f146102815780632f2ff15d146102a157806336568abe146102c157600080fd5b806301ffc9a7146101c757806303ed0ee5146101fc5780630728e3ad1461023e575b600080fd5b3480156101d357600080fd5b506101e76101e236600461103b565b6105cb565b60405190151581526020015b60405180910390f35b34801561020857600080fd5b506102307f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d81565b6040519081526020016101f3565b61024f61024c36600461118e565b50565b005b34801561025d57600080fd5b5061023061026c3660046111aa565b60009081526002602052604090206001015490565b34801561028d57600080fd5b5061024f61029c3660046111c3565b610664565b3480156102ad57600080fd5b5061024f6102bc366004611218565b6106d0565b3480156102cd57600080fd5b5061024f6102dc366004611218565b6106fb565b3480156102ed57600080fd5b5061024f6102fc3660046112ef565b5050565b34801561030c57600080fd5b5061024f61031b366004611334565b610759565b34801561032c57600080fd5b5061024f61033b366004611334565b61080c565b34801561034c57600080fd5b5061024f61035b36600461134f565b6108b8565b34801561036c57600080fd5b5061024f6109f7565b34801561038157600080fd5b5061024f610a0b565b34801561039657600080fd5b5061024f6102fc36600461138d565b3480156103b157600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff165b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016101f3565b61024f61024c3660046113d2565b34801561040b57600080fd5b506101e761041a366004611218565b600091825260026020908152604080842073ffffffffffffffffffffffffffffffffffffffff93909316845291905290205460ff1690565b34801561045e57600080fd5b506102307fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc481565b34801561049257600080fd5b50610230600081565b3480156104a757600080fd5b506102307f000000000000000000000000000000000000000000000000000000000000000081565b3480156104db57600080fd5b5061024f61024c3660046111aa565b3480156104f657600080fd5b5061024f61050536600461140f565b610a84565b34801561051657600080fd5b5061023060035481565b34801561052c57600080fd5b5061024f61053b366004611334565b610ac4565b34801561054c57600080fd5b5061024f61055b366004611218565b610b70565b34801561056c57600080fd5b5061024f61057b366004611334565b610b95565b34801561058c57600080fd5b5060015473ffffffffffffffffffffffffffffffffffffffff166103cc565b3480156105b757600080fd5b5061024f6105c6366004611334565b610c41565b60007fffffffff0000000000000000000000000000000000000000000000000000000082167f7965db0b00000000000000000000000000000000000000000000000000000000148061065e57507f01ffc9a7000000000000000000000000000000000000000000000000000000007fffffffff000000000000000000000000000000000000000000000000000000008316145b92915050565b6040805186815273ffffffffffffffffffffffffffffffffffffffff868116602083015285811682840152841660608201526080810183905290517f7212c977e94cbafc6e4685aee721574624efaa1993ce2b48d1bb37c27ffa13f49181900360a00190a15050505050565b6000828152600260205260409020600101546106eb81610cf1565b6106f58383610cfb565b50505050565b73ffffffffffffffffffffffffffffffffffffffff8116331461074a576040517f6697b23200000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6107548282610dfb565b505050565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661079457600080fd5b6107be7fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc482610dfb565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f10e1f7ce9fd7d1b90a66d13a2ab3cb8dd7f29f3f8d520b143b063ccfbab6906b906020015b60405180910390a150565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff1661084757600080fd5b6108717f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d82610cfb565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f93405f05cd04f0d1bd875f2de00f1f3890484ffd0589248953bdfd29ba7f2f5990602001610801565b60006040518061014001604052804663ffffffff168152602001836000015163ffffffff1681526020013373ffffffffffffffffffffffffffffffffffffffff168152602001836020015173ffffffffffffffffffffffffffffffffffffffff168152602001836040015173ffffffffffffffffffffffffffffffffffffffff168152602001836060015173ffffffffffffffffffffffffffffffffffffffff168152602001836080015181526020018360a0015181526020018360c0015181526020016003600081548092919061098f90611466565b9091555090526040516109a591906020016114c5565b60405160208183030381529060405290507f2a8233b619c9d479346e133f609855c0a94d89fbcfa62f846a9f0cfdd1198ccf8433836040516109e9939291906115be565b60405180910390a150505050565b6109ff610eba565b610a096000610f0d565b565b600154339073ffffffffffffffffffffffffffffffffffffffff168114610a7b576040517f118cdaa700000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff821660048201526024015b60405180910390fd5b61024c81610f0d565b7f2a8233b619c9d479346e133f609855c0a94d89fbcfa62f846a9f0cfdd1198ccf838383604051610ab7939291906115be565b60405180910390a1505050565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff16610aff57600080fd5b610b297f043c983c49d46f0e102151eaf8085d4a2e6571d5df2d47b013f39bddfd4a639d82610dfb565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f59926e0a78d12238b668b31c8e3f6ece235a59a00ede111d883e255b68c4d04890602001610801565b600082815260026020526040902060010154610b8b81610cf1565b6106f58383610dfb565b3360009081527fac33ff75c19e70fe83507db0d683fd3465c996598dc972688b7ace676c89077b602052604090205460ff16610bd057600080fd5b610bfa7fe2b7fb3b832174769106daebcfd6d1970523240dda11281102db9363b83b0dc482610cfb565b5060405173ffffffffffffffffffffffffffffffffffffffff821681527f03580ee9f53a62b7cb409a2cb56f9be87747dd15017afc5cef6eef321e4fb2c590602001610801565b610c49610eba565b6001805473ffffffffffffffffffffffffffffffffffffffff83167fffffffffffffffffffffffff00000000000000000000000000000000000000009091168117909155610cac60005473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff167f38d16b8cac22d99fc7c124b9cd0de2d3fa1faef420bfe791d8c362d765e2270060405160405180910390a350565b61024c8133610f3e565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915281205460ff16610df357600083815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff86168452909152902080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00166001179055610d913390565b73ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16847f2f8788117e7eff1d82e926ec794901d17c78024a50270940304540a733656f0d60405160405180910390a450600161065e565b50600061065e565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915281205460ff1615610df357600083815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8616808552925280832080547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0016905551339286917ff6391f5c32d9c69d2a47ea670b442974b53935d1edc7fd64eb21e047a839171b9190a450600161065e565b60005473ffffffffffffffffffffffffffffffffffffffff163314610a09576040517f118cdaa7000000000000000000000000000000000000000000000000000000008152336004820152602401610a72565b600180547fffffffffffffffffffffffff000000000000000000000000000000000000000016905561024c81610fc6565b600082815260026020908152604080832073ffffffffffffffffffffffffffffffffffffffff8516845290915290205460ff166102fc576040517fe2517d3f00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8216600482015260248101839052604401610a72565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60006020828403121561104d57600080fd5b81357fffffffff000000000000000000000000000000000000000000000000000000008116811461107d57600080fd5b9392505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160e0810167ffffffffffffffff811182821017156110d6576110d6611084565b60405290565b803573ffffffffffffffffffffffffffffffffffffffff8116811461110057600080fd5b919050565b600060e0828403121561111757600080fd5b61111f6110b3565b9050813563ffffffff8116811461113557600080fd5b8152611143602083016110dc565b6020820152611154604083016110dc565b6040820152611165606083016110dc565b60608201526080820135608082015260a082013560a082015260c082013560c082015292915050565b600060e082840312156111a057600080fd5b61107d8383611105565b6000602082840312156111bc57600080fd5b5035919050565b600080600080600060a086880312156111db57600080fd5b853594506111eb602087016110dc565b93506111f9604087016110dc565b9250611207606087016110dc565b949793965091946080013592915050565b6000806040838503121561122b57600080fd5b8235915061123b602084016110dc565b90509250929050565b600082601f83011261125557600080fd5b813567ffffffffffffffff8082111561127057611270611084565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f011681019082821181831017156112b6576112b6611084565b816040528381528660208588010111156112cf57600080fd5b836020870160208301376000602085830101528094505050505092915050565b6000806040838503121561130257600080fd5b823567ffffffffffffffff81111561131957600080fd5b61132585828601611244565b92505061123b602084016110dc565b60006020828403121561134657600080fd5b61107d826110dc565b6000806000610120848603121561136557600080fd5b83359250611375602085016110dc565b91506113848560408601611105565b90509250925092565b600080604083850312156113a057600080fd5b823567ffffffffffffffff8111156113b757600080fd5b6113c385828601611244565b95602094909401359450505050565b6000602082840312156113e457600080fd5b813567ffffffffffffffff8111156113fb57600080fd5b61140784828501611244565b949350505050565b60008060006060848603121561142457600080fd5b83359250611434602085016110dc565b9150604084013567ffffffffffffffff81111561145057600080fd5b61145c86828701611244565b9150509250925092565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82036114be577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b5060010190565b815163ffffffff168152610140810160208301516114eb602084018263ffffffff169052565b506040830151611513604084018273ffffffffffffffffffffffffffffffffffffffff169052565b50606083015161153b606084018273ffffffffffffffffffffffffffffffffffffffff169052565b506080830151611563608084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060a083015161158b60a084018273ffffffffffffffffffffffffffffffffffffffff169052565b5060c083015160c083015260e083015160e083015261010080840151818401525061012080840151818401525092915050565b8381526000602073ffffffffffffffffffffffffffffffffffffffff85168184015260606040840152835180606085015260005b8181101561160e578581018301518582016080015282016115f2565b5060006080828601015260807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f8301168501019250505094935050505056fea2646970667358221220cb669a3be6f16cc68af0cd12fd9ca4ed54699359efbf823316b0c55831adbb1164736f6c63430008140033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"22643:2024:0:-:0;;;22789:85;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;22823:6;;-1:-1:-1;;;;;2207:26:0;;2203:95;;2256:31;;-1:-1:-1;;;2256:31:0;;2284:1;2256:31;;;455:51:1;428:18;;2256:31:0;;;;;;;2203:95;2307:32;2326:12;2307:18;:32::i;:::-;-1:-1:-1;18855:38:0::1;13063:4;18886:6:::0;18855:10:::1;:38::i;:::-;-1:-1:-1::0;;22855:12:0::1;22841:26;::::0;-1:-1:-1;22643:2024:0;;5750:153;5839:13;5832:20;;-1:-1:-1;;;;;;5832:20:0;;;5862:34;5887:8;5862:24;:34::i;:::-;5750:153;:::o;17010:316::-;17087:4;13785:12;;;:6;:12;;;;;;;;-1:-1:-1;;;;;13785:29:0;;;;;;;;;;;;17103:217;;17146:12;;;;:6;:12;;;;;;;;-1:-1:-1;;;;;17146:29:0;;;;;;;;;:36;;-1:-1:-1;;17146:36:0;17178:4;17146:36;;;17228:12;880:10;;801:96;17228:12;-1:-1:-1;;;;;17201:40:0;17219:7;-1:-1:-1;;;;;17201:40:0;17213:4;17201:40;;;;;;;;;;-1:-1:-1;17262:4:0;17255:11;;17103:217;-1:-1:-1;17304:5:0;17103:217;17010:316;;;;:::o;3846:187::-;3919:16;3938:6;;-1:-1:-1;;;;;3954:17:0;;;-1:-1:-1;;;;;;3954:17:0;;;;;;3986:40;;3938:6;;;;;;;3986:40;;3919:16;3986:40;3909:124;3846:187;:::o;14:290:1:-;84:6;137:2;125:9;116:7;112:23;108:32;105:52;;;153:1;150;143:12;105:52;179:16;;-1:-1:-1;;;;;224:31:1;;214:42;;204:70;;270:1;267;260:12;204:70;293:5;14:290;-1:-1:-1;;;14:290:1:o;309:203::-;22643:2024:0;;;;;;;;;;;;","srcMapRuntime":"22643:2024:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;13396:202;;;;;;;;;;-1:-1:-1;13396:202:0;;;;;:::i;:::-;;:::i;:::-;;;516:14:1;;509:22;491:41;;479:2;464:18;13396:202:0;;;;;;;;18488:60;;;;;;;;;;;;18525:23;18488:60;;;;;689:25:1;;;677:2;662:18;18488:60:0;543:177:1;24115:89:0;;;;;;:::i;:::-;;;;;14641:120;;;;;;;;;;-1:-1:-1;14641:120:0;;;;;:::i;:::-;14706:7;14732:12;;;:6;:12;;;;;:22;;;;14641:120;23911:198;;;;;;;;;;-1:-1:-1;23911:198:0;;;;;:::i;:::-;;:::i;15057:136::-;;;;;;;;;;-1:-1:-1;15057:136:0;;;;;:::i;:::-;;:::i;16159:245::-;;;;;;;;;;-1:-1:-1;16159:245:0;;;;;:::i;:::-;;:::i;24400:87::-;;;;;;;;;;-1:-1:-1;24400:87:0;;;;;:::i;:::-;;;;19105:199;;;;;;;;;;-1:-1:-1;19105:199:0;;;;;:::i;:::-;;:::i;19310:181::-;;;;;;;;;;-1:-1:-1;19310:181:0;;;;;:::i;:::-;;:::i;22939:789::-;;;;;;;;;;-1:-1:-1;22939:789:0;;;;;:::i;:::-;;:::i;3227:101::-;;;;;;;;;;;;;:::i;5983:229::-;;;;;;;;;;;;;:::i;24299:95::-;;;;;;;;;;-1:-1:-1;24299:95:0;;;;;:::i;2572:85::-;;;;;;;;;;-1:-1:-1;2618:7:0;2644:6;;;2572:85;;;5729:42:1;5717:55;;;5699:74;;5687:2;5672:18;2572:85:0;5553:226:1;24210:83:0;;;;;;:::i;13685:136::-;;;;;;;;;;-1:-1:-1;13685:136:0;;;;;:::i;:::-;13762:4;13785:12;;;:6;:12;;;;;;;;:29;;;;;;;;;;;;;;;;13685:136;18418:64;;;;;;;;;;;;18457:25;18418:64;;13018:49;;;;;;;;;;-1:-1:-1;13018:49:0;13063:4;13018:49;;22746:36;;;;;;;;;;;;;;;24493:78;;;;;;;;;;-1:-1:-1;24493:78:0;;;;;:::i;23734:171::-;;;;;;;;;;-1:-1:-1;23734:171:0;;;;;:::i;:::-;;:::i;22912:20::-;;;;;;;;;;;;;;;;19497:187;;;;;;;;;;-1:-1:-1;19497:187:0;;;;;:::i;:::-;;:::i;15473:138::-;;;;;;;;;;-1:-1:-1;15473:138:0;;;;;:::i;:::-;;:::i;18906:193::-;;;;;;;;;;-1:-1:-1;18906:193:0;;;;;:::i;:::-;;:::i;5096:99::-;;;;;;;;;;-1:-1:-1;5175:13:0;;;;5096:99;;5388:178;;;;;;;;;;-1:-1:-1;5388:178:0;;;;;:::i;:::-;;:::i;13396:202::-;13481:4;13504:47;;;13519:32;13504:47;;:87;;-1:-1:-1;11087:25:0;11072:40;;;;13555:36;13497:94;13396:202;-1:-1:-1;;13396:202:0:o;23911:198::-;24046:56;;;7017:25:1;;;7061:42;7139:15;;;7134:2;7119:18;;7112:43;7191:15;;;7171:18;;;7164:43;7243:15;;7238:2;7223:18;;7216:43;7290:3;7275:19;;7268:35;;;24046:56:0;;;;;;;7004:3:1;24046:56:0;;;23911:198;;;;;:::o;15057:136::-;14706:7;14732:12;;;:6;:12;;;;;:22;;;13295:16;13306:4;13295:10;:16::i;:::-;15161:25:::1;15172:4;15178:7;15161:10;:25::i;:::-;;15057:136:::0;;;:::o;16159:245::-;16252:34;;;880:10;16252:34;16248:102;;16309:30;;;;;;;;;;;;;;16248:102;16360:37;16372:4;16378:18;16360:11;:37::i;:::-;;16159:245;;:::o;19105:199::-;19201:10;13063:4;13785:29;;;:12;;:29;:12;:29;;;;;19165:48;;;;;;19223:35;18457:25;19249:8;19223:11;:35::i;:::-;-1:-1:-1;19273:24:0;;5729:42:1;5717:55;;5699:74;;19273:24:0;;5687:2:1;5672:18;19273:24:0;;;;;;;;19105:199;:::o;19310:181::-;19399:10;13063:4;13785:29;;;:12;;:29;:12;:29;;;;;19363:48;;;;;;19421:30;18525:23;19444:6;19421:10;:30::i;:::-;-1:-1:-1;19466:18:0;;5729:42:1;5717:55;;5699:74;;19466:18:0;;5687:2:1;5672:18;19466::0;5553:226:1;22939:789:0;23052:20;23099:545;;;;;;;;23157:13;23099:545;;;;;;23202:6;:17;;;23099:545;;;;;;23251:10;23099:545;;;;;;23294:6;:9;;;23099:545;;;;;;23334:6;:18;;;23099:545;;;;;;23381:6;:16;;;23099:545;;;;;;23429:6;:19;;;23099:545;;;;23502:6;:17;;;23099:545;;;;23547:6;:15;;;23099:545;;;;23587:5;;:7;;;;;;;;;:::i;:::-;;;;-1:-1:-1;23099:545:0;;23075:579;;;;;;;;:::i;:::-;;;;;;;;;;;;;23052:602;;23670:51;23686:13;23701:10;23713:7;23670:51;;;;;;;;:::i;:::-;;;;;;;;23042:686;22939:789;;;:::o;3227:101::-;2465:13;:11;:13::i;:::-;3291:30:::1;3318:1;3291:18;:30::i;:::-;3227:101::o:0;5983:229::-;5175:13;;880:10;;6078:24;5175:13;6078:24;;6074:96;;6125:34;;;;;5729:42:1;5717:55;;6125:34:0;;;5699:74:1;5672:18;;6125:34:0;;;;;;;;6074:96;6179:26;6198:6;6179:18;:26::i;23734:171::-;23851:47;23867:13;23882:6;23890:7;23851:47;;;;;;;;:::i;:::-;;;;;;;;23734:171;;;:::o;19497:187::-;19589:10;13063:4;13785:29;;;:12;;:29;:12;:29;;;;;19553:48;;;;;;19611:31;18525:23;19635:6;19611:11;:31::i;:::-;-1:-1:-1;19657:20:0;;5729:42:1;5717:55;;5699:74;;19657:20:0;;5687:2:1;5672:18;19657:20:0;5553:226:1;15473:138:0;14706:7;14732:12;;;:6;:12;;;;;:22;;;13295:16;13306:4;13295:10;:16::i;:::-;15578:26:::1;15590:4;15596:7;15578:11;:26::i;18906:193::-:0;18999:10;13063:4;13785:29;;;:12;;:29;:12;:29;;;;;18963:48;;;;;;19021:34;18457:25;19046:8;19021:10;:34::i;:::-;-1:-1:-1;19070:22:0;;5729:42:1;5717:55;;5699:74;;19070:22:0;;5687:2:1;5672:18;19070:22:0;5553:226:1;5388:178:0;2465:13;:11;:13::i;:::-;5477::::1;:24:::0;;::::1;::::0;::::1;::::0;;;::::1;::::0;::::1;::::0;;;5541:7:::1;2618::::0;2644:6;;;;2572:85;5541:7:::1;5516:43;;;;;;;;;;;;5388:178:::0;:::o;14030:103::-;14096:30;14107:4;880:10;14096;:30::i;17010:316::-;17087:4;13785:12;;;:6;:12;;;;;;;;:29;;;;;;;;;;;;;17103:217;;17146:12;;;;:6;:12;;;;;;;;:29;;;;;;;;;;:36;;;;17178:4;17146:36;;;17228:12;880:10;;801:96;17228:12;17201:40;;17219:7;17201:40;;17213:4;17201:40;;;;;;;;;;-1:-1:-1;17262:4:0;17255:11;;17103:217;-1:-1:-1;17304:5:0;17297:12;;17561:317;17639:4;13785:12;;;:6;:12;;;;;;;;:29;;;;;;;;;;;;;17655:217;;;17729:5;17697:12;;;:6;:12;;;;;;;;:29;;;;;;;;;;;:37;;;;;;17753:40;880:10;;17697:12;;17753:40;;17729:5;17753:40;-1:-1:-1;17814:4:0;17807:11;;2730:162;2618:7;2644:6;2789:23;2644:6;880:10;2789:23;2785:101;;2835:40;;;;;880:10;2835:40;;;5699:74:1;5672:18;;2835:40:0;5553:226:1;5750:153:0;5839:13;5832:20;;;;;;5862:34;5887:8;5862:24;:34::i;14263:197::-;13762:4;13785:12;;;:6;:12;;;;;;;;:29;;;;;;;;;;;;;14346:108;;14396:47;;;;;9933:42:1;9921:55;;14396:47:0;;;9903:74:1;9993:18;;;9986:34;;;9876:18;;14396:47:0;9729:297:1;3846:187:0;3919:16;3938:6;;;3954:17;;;;;;;;;;3986:40;;3938:6;;;;;;;3986:40;;3919:16;3986:40;3909:124;3846:187;:::o;14:332:1:-;72:6;125:2;113:9;104:7;100:23;96:32;93:52;;;141:1;138;131:12;93:52;180:9;167:23;230:66;223:5;219:78;212:5;209:89;199:117;;312:1;309;302:12;199:117;335:5;14:332;-1:-1:-1;;;14:332:1:o;725:184::-;777:77;774:1;767:88;874:4;871:1;864:15;898:4;895:1;888:15;914:248;981:2;975:9;1023:4;1011:17;;1058:18;1043:34;;1079:22;;;1040:62;1037:88;;;1105:18;;:::i;:::-;1141:2;1134:22;914:248;:::o;1167:196::-;1235:20;;1295:42;1284:54;;1274:65;;1264:93;;1353:1;1350;1343:12;1264:93;1167:196;;;:::o;1368:736::-;1427:5;1475:4;1463:9;1458:3;1454:19;1450:30;1447:50;;;1493:1;1490;1483:12;1447:50;1515:17;;:::i;:::-;1506:26;;1569:9;1556:23;1623:10;1614:7;1610:24;1601:7;1598:37;1588:65;;1649:1;1646;1639:12;1588:65;1662:22;;1716:38;1750:2;1735:18;;1716:38;:::i;:::-;1711:2;1704:5;1700:14;1693:62;1787:38;1821:2;1810:9;1806:18;1787:38;:::i;:::-;1782:2;1775:5;1771:14;1764:62;1858:38;1892:2;1881:9;1877:18;1858:38;:::i;:::-;1853:2;1846:5;1842:14;1835:62;1958:3;1947:9;1943:19;1930:33;1924:3;1917:5;1913:15;1906:58;2025:3;2014:9;2010:19;1997:33;1991:3;1984:5;1980:15;1973:58;2092:3;2081:9;2077:19;2064:33;2058:3;2051:5;2047:15;2040:58;1368:736;;;;:::o;2109:237::-;2197:6;2250:3;2238:9;2229:7;2225:23;2221:33;2218:53;;;2267:1;2264;2257:12;2218:53;2290:50;2332:7;2321:9;2290:50;:::i;2351:180::-;2410:6;2463:2;2451:9;2442:7;2438:23;2434:32;2431:52;;;2479:1;2476;2469:12;2431:52;-1:-1:-1;2502:23:1;;2351:180;-1:-1:-1;2351:180:1:o;2536:472::-;2631:6;2639;2647;2655;2663;2716:3;2704:9;2695:7;2691:23;2687:33;2684:53;;;2733:1;2730;2723:12;2684:53;2769:9;2756:23;2746:33;;2798:38;2832:2;2821:9;2817:18;2798:38;:::i;:::-;2788:48;;2855:38;2889:2;2878:9;2874:18;2855:38;:::i;:::-;2845:48;;2912:38;2946:2;2935:9;2931:18;2912:38;:::i;:::-;2536:472;;;;-1:-1:-1;2536:472:1;;2997:3;2982:19;2969:33;;2536:472;-1:-1:-1;;2536:472:1:o;3013:254::-;3081:6;3089;3142:2;3130:9;3121:7;3117:23;3113:32;3110:52;;;3158:1;3155;3148:12;3110:52;3194:9;3181:23;3171:33;;3223:38;3257:2;3246:9;3242:18;3223:38;:::i;:::-;3213:48;;3013:254;;;;;:::o;3272:777::-;3314:5;3367:3;3360:4;3352:6;3348:17;3344:27;3334:55;;3385:1;3382;3375:12;3334:55;3421:6;3408:20;3447:18;3484:2;3480;3477:10;3474:36;;;3490:18;;:::i;:::-;3624:2;3618:9;3686:4;3678:13;;3529:66;3674:22;;;3698:2;3670:31;3666:40;3654:53;;;3722:18;;;3742:22;;;3719:46;3716:72;;;3768:18;;:::i;:::-;3808:10;3804:2;3797:22;3843:2;3835:6;3828:18;3889:3;3882:4;3877:2;3869:6;3865:15;3861:26;3858:35;3855:55;;;3906:1;3903;3896:12;3855:55;3970:2;3963:4;3955:6;3951:17;3944:4;3936:6;3932:17;3919:54;4017:1;4010:4;4005:2;3997:6;3993:15;3989:26;3982:37;4037:6;4028:15;;;;;;3272:777;;;;:::o;4054:394::-;4131:6;4139;4192:2;4180:9;4171:7;4167:23;4163:32;4160:52;;;4208:1;4205;4198:12;4160:52;4248:9;4235:23;4281:18;4273:6;4270:30;4267:50;;;4313:1;4310;4303:12;4267:50;4336:49;4377:7;4368:6;4357:9;4353:22;4336:49;:::i;:::-;4326:59;;;4404:38;4438:2;4427:9;4423:18;4404:38;:::i;4453:186::-;4512:6;4565:2;4553:9;4544:7;4540:23;4536:32;4533:52;;;4581:1;4578;4571:12;4533:52;4604:29;4623:9;4604:29;:::i;4644:379::-;4750:6;4758;4766;4819:3;4807:9;4798:7;4794:23;4790:33;4787:53;;;4836:1;4833;4826:12;4787:53;4872:9;4859:23;4849:33;;4901:38;4935:2;4924:9;4920:18;4901:38;:::i;:::-;4891:48;;4958:59;5009:7;5004:2;4993:9;4989:18;4958:59;:::i;:::-;4948:69;;4644:379;;;;;:::o;5028:388::-;5105:6;5113;5166:2;5154:9;5145:7;5141:23;5137:32;5134:52;;;5182:1;5179;5172:12;5134:52;5222:9;5209:23;5255:18;5247:6;5244:30;5241:50;;;5287:1;5284;5277:12;5241:50;5310:49;5351:7;5342:6;5331:9;5327:22;5310:49;:::i;:::-;5300:59;5406:2;5391:18;;;;5378:32;;-1:-1:-1;;;;5028:388:1:o;5784:320::-;5852:6;5905:2;5893:9;5884:7;5880:23;5876:32;5873:52;;;5921:1;5918;5911:12;5873:52;5961:9;5948:23;5994:18;5986:6;5983:30;5980:50;;;6026:1;6023;6016:12;5980:50;6049:49;6090:7;6081:6;6070:9;6066:22;6049:49;:::i;:::-;6039:59;5784:320;-1:-1:-1;;;;5784:320:1:o;6291:462::-;6377:6;6385;6393;6446:2;6434:9;6425:7;6421:23;6417:32;6414:52;;;6462:1;6459;6452:12;6414:52;6498:9;6485:23;6475:33;;6527:38;6561:2;6550:9;6546:18;6527:38;:::i;:::-;6517:48;;6616:2;6605:9;6601:18;6588:32;6643:18;6635:6;6632:30;6629:50;;;6675:1;6672;6665:12;6629:50;6698:49;6739:7;6730:6;6719:9;6715:22;6698:49;:::i;:::-;6688:59;;;6291:462;;;;;:::o;7314:349::-;7353:3;7384:66;7377:5;7374:77;7371:257;;7484:77;7481:1;7474:88;7585:4;7582:1;7575:15;7613:4;7610:1;7603:15;7371:257;-1:-1:-1;7655:1:1;7644:13;;7314:349::o;7767:1153::-;8000:13;;7744:10;7733:22;7721:35;;7969:3;7954:19;;8072:4;8064:6;8060:17;8054:24;8087:53;8134:4;8123:9;8119:20;8105:12;7744:10;7733:22;7721:35;;7668:94;8087:53;;8189:4;8181:6;8177:17;8171:24;8204:56;8254:4;8243:9;8239:20;8223:14;5498:42;5487:54;5475:67;;5421:127;8204:56;;8309:4;8301:6;8297:17;8291:24;8324:56;8374:4;8363:9;8359:20;8343:14;5498:42;5487:54;5475:67;;5421:127;8324:56;;8429:4;8421:6;8417:17;8411:24;8444:56;8494:4;8483:9;8479:20;8463:14;5498:42;5487:54;5475:67;;5421:127;8444:56;;8549:4;8541:6;8537:17;8531:24;8564:56;8614:4;8603:9;8599:20;8583:14;5498:42;5487:54;5475:67;;5421:127;8564:56;;8676:4;8668:6;8664:17;8658:24;8651:4;8640:9;8636:20;8629:54;8739:4;8731:6;8727:17;8721:24;8714:4;8703:9;8699:20;8692:54;8765:6;8825:2;8817:6;8813:15;8807:22;8802:2;8791:9;8787:18;8780:50;;8849:6;8909:2;8901:6;8897:15;8891:22;8886:2;8875:9;8871:18;8864:50;;7767:1153;;;;:::o;8925:799::-;9128:6;9117:9;9110:25;9091:4;9154:2;9204:42;9196:6;9192:55;9187:2;9176:9;9172:18;9165:83;9284:2;9279;9268:9;9264:18;9257:30;9316:6;9310:13;9359:6;9354:2;9343:9;9339:18;9332:34;9384:1;9394:141;9408:6;9405:1;9402:13;9394:141;;;9504:14;;;9500:23;;9494:30;9469:17;;;9488:3;9465:27;9458:67;9423:10;;9394:141;;;9398:3;9585:1;9579:3;9570:6;9559:9;9555:22;9551:32;9544:43;9714:3;9644:66;9639:2;9631:6;9627:15;9623:88;9612:9;9608:104;9604:114;9596:122;;;;8925:799;;;;;;:::o","abiDefinition":[{"inputs":[{"internalType":"address","name":"_owner","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositRefunded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"relayer","type":"address"}],"name":"BridgeProofDisputed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"bytes32","name":"transactionHash","type":"bytes32"}],"name":"BridgeProofProvided","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeRelayed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"request","type":"bytes"}],"name":"BridgeRequested","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"guard","type":"address"}],"name":"GuardAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"guard","type":"address"}],"name":"GuardRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferStarted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"relayer","type":"address"}],"name":"RelayerAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"relayer","type":"address"}],"name":"RelayerRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[],"name":"DEFAULT_ADMIN_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"GUARD_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"RELAYER_ROLE","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"acceptOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_guard","type":"address"}],"name":"addGuard","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_relayer","type":"address"}],"name":"addRelayer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"components":[{"internalType":"uint32","name":"dstChainId","type":"uint32"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct IFastBridge.BridgeParams","name":"params","type":"tuple"}],"name":"bridge","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"address","name":"to","type":"address"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"deployBlock","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"dispute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"address","name":"relayer","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mockBridgeRelayer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"address","name":"sender","type":"address"},{"components":[{"internalType":"uint32","name":"dstChainId","type":"uint32"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct IFastBridge.BridgeParams","name":"params","type":"tuple"}],"name":"mockBridgeRequest","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"bytes","name":"request","type":"bytes"}],"name":"mockBridgeRequestRaw","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"nonce","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"bytes32","name":"destTxHash","type":"bytes32"}],"name":"prove","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"address","name":"to","type":"address"}],"name":"refund","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"relay","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"_guard","type":"address"}],"name":"removeGuard","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_relayer","type":"address"}],"name":"removeRelayer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"bridge((uint32,address,address,address,uint256,uint256,uint256))":{"notice":"Initiates bridge on origin chain to be relayed by off-chain relayer"},"claim(bytes,address)":{"notice":"Completes bridge transaction on origin chain by claiming originally deposited capital"},"dispute(bytes32)":{"notice":"Disputes an outstanding proof in case relayer provided dest chain tx is invalid"},"prove(bytes,bytes32)":{"notice":"Provides proof on origin side that relayer provided funds on destination side of bridge transaction"},"refund(bytes,address)":{"notice":"Refunds an outstanding bridge transaction in case optimistic bridging failed"},"relay(bytes)":{"notice":"Relays destination side of bridge transaction by off-chain relayer"}},"version":1},"developerDoc":{"errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}],"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"acceptOwnership()":{"details":"The new owner accepts the ownership transfer."},"bridge((uint32,address,address,address,uint256,uint256,uint256))":{"params":{"params":"The parameters required to bridge"}},"claim(bytes,address)":{"params":{"request":"The encoded bridge transaction to claim on origin chain","to":"The recipient address of the funds"}},"dispute(bytes32)":{"params":{"transactionId":"The transaction id associated with the encoded bridge transaction to dispute"}},"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"owner()":{"details":"Returns the address of the current owner."},"pendingOwner()":{"details":"Returns the address of the pending owner."},"prove(bytes,bytes32)":{"params":{"destTxHash":"The destination tx hash proving bridge transaction was relayed","request":"The encoded bridge transaction to prove on origin chain"}},"refund(bytes,address)":{"params":{"request":"The encoded bridge transaction to refund","to":"The recipient address of the funds"}},"relay(bytes)":{"params":{"request":"The encoded bridge transaction to relay on destination chain"}},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event."},"supportsInterface(bytes4)":{"details":"See {IERC165-supportsInterface}."},"transferOwnership(address)":{"details":"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner."}},"stateVariables":{"nonce":{"details":"to prevent replays"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"BridgeProofDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"BridgeProofProvided\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeRelayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"BridgeRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"GuardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"GuardRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"DEFAULT_ADMIN_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"GUARD_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"RELAYER_ROLE\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guard\",\"type\":\"address\"}],\"name\":\"addGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"addRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"deployBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"dispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mockBridgeRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"mockBridgeRequest\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"mockBridgeRequestRaw\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"destTxHash\",\"type\":\"bytes32\"}],\"name\":\"prove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guard\",\"type\":\"address\"}],\"name\":\"removeGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"removeRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}],\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"bridge((uint32,address,address,address,uint256,uint256,uint256))\":{\"params\":{\"params\":\"The parameters required to bridge\"}},\"claim(bytes,address)\":{\"params\":{\"request\":\"The encoded bridge transaction to claim on origin chain\",\"to\":\"The recipient address of the funds\"}},\"dispute(bytes32)\":{\"params\":{\"transactionId\":\"The transaction id associated with the encoded bridge transaction to dispute\"}},\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleGranted} event.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"prove(bytes,bytes32)\":{\"params\":{\"destTxHash\":\"The destination tx hash proving bridge transaction was relayed\",\"request\":\"The encoded bridge transaction to prove on origin chain\"}},\"refund(bytes,address)\":{\"params\":{\"request\":\"The encoded bridge transaction to refund\",\"to\":\"The recipient address of the funds\"}},\"relay(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to relay on destination chain\"}},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been revoked `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`. May emit a {RoleRevoked} event.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role. May emit a {RoleRevoked} event.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner.\"}},\"stateVariables\":{\"nonce\":{\"details\":\"to prevent replays\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"bridge((uint32,address,address,address,uint256,uint256,uint256))\":{\"notice\":\"Initiates bridge on origin chain to be relayed by off-chain relayer\"},\"claim(bytes,address)\":{\"notice\":\"Completes bridge transaction on origin chain by claiming originally deposited capital\"},\"dispute(bytes32)\":{\"notice\":\"Disputes an outstanding proof in case relayer provided dest chain tx is invalid\"},\"prove(bytes,bytes32)\":{\"notice\":\"Provides proof on origin side that relayer provided funds on destination side of bridge transaction\"},\"refund(bytes,address)\":{\"notice\":\"Refunds an outstanding bridge transaction in case optimistic bridging failed\"},\"relay(bytes)\":{\"notice\":\"Relays destination side of bridge transaction by off-chain relayer\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"FastBridgeMock\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{"DEFAULT_ADMIN_ROLE()":"a217fddf","GUARD_ROLE()":"03ed0ee5","RELAYER_ROLE()":"926d7d7f","acceptOwnership()":"79ba5097","addGuard(address)":"6913a63c","addRelayer(address)":"dd39f00d","bridge((uint32,address,address,address,uint256,uint256,uint256))":"0728e3ad","claim(bytes,address)":"41fcb612","deployBlock()":"a3ec191a","dispute(bytes32)":"add98c70","getRoleAdmin(bytes32)":"248a9ca3","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","mockBridgeRelayer(bytes32,address,address,address,uint256)":"2694648f","mockBridgeRequest(bytes32,address,(uint32,address,address,address,uint256,uint256,uint256))":"6d708f4b","mockBridgeRequestRaw(bytes32,address,bytes)":"aedf009d","nonce()":"affed0e0","owner()":"8da5cb5b","pendingOwner()":"e30c3978","prove(bytes,bytes32)":"886d36ff","refund(bytes,address)":"ef059bd3","relay(bytes)":"8f0d6f17","removeGuard(address)":"b6235016","removeRelayer(address)":"60f0a5ac","renounceOwnership()":"715018a6","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f","supportsInterface(bytes4)":"01ffc9a7","transferOwnership(address)":"f2fde38b"}},"solidity/FastBridgeMock.sol:IAccessControl":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"AccessControlBadConfirmation","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"},{"internalType":"bytes32","name":"neededRole","type":"bytes32"}],"name":"AccessControlUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"previousAdminRole","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"newAdminRole","type":"bytes32"}],"name":"RoleAdminChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleGranted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"role","type":"bytes32"},{"indexed":true,"internalType":"address","name":"account","type":"address"},{"indexed":true,"internalType":"address","name":"sender","type":"address"}],"name":"RoleRevoked","type":"event"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"}],"name":"getRoleAdmin","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"grantRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"hasRole","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"callerConfirmation","type":"address"}],"name":"renounceRole","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"role","type":"bytes32"},{"internalType":"address","name":"account","type":"address"}],"name":"revokeRole","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"External interface of AccessControl declared to support ERC-165 detection.","errors":{"AccessControlBadConfirmation()":[{"details":"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}."}],"AccessControlUnauthorizedAccount(address,bytes32)":[{"details":"The `account` is missing a role."}]},"events":{"RoleAdminChanged(bytes32,bytes32,bytes32)":{"details":"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this."},"RoleGranted(bytes32,address,address)":{"details":"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}."},"RoleRevoked(bytes32,address,address)":{"details":"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)"}},"kind":"dev","methods":{"getRoleAdmin(bytes32)":{"details":"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}."},"grantRole(bytes32,address)":{"details":"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role."},"hasRole(bytes32,address)":{"details":"Returns `true` if `account` has been granted `role`."},"renounceRole(bytes32,address)":{"details":"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`."},"revokeRole(bytes32,address)":{"details":"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"AccessControlBadConfirmation\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"neededRole\",\"type\":\"bytes32\"}],\"name\":\"AccessControlUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"previousAdminRole\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"newAdminRole\",\"type\":\"bytes32\"}],\"name\":\"RoleAdminChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"RoleRevoked\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"getRoleAdmin\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"grantRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"callerConfirmation\",\"type\":\"address\"}],\"name\":\"renounceRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"role\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeRole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"External interface of AccessControl declared to support ERC-165 detection.\",\"errors\":{\"AccessControlBadConfirmation()\":[{\"details\":\"The caller of a function is not the expected one. NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\"}],\"AccessControlUnauthorizedAccount(address,bytes32)\":[{\"details\":\"The `account` is missing a role.\"}]},\"events\":{\"RoleAdminChanged(bytes32,bytes32,bytes32)\":{\"details\":\"Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole` `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite {RoleAdminChanged} not being emitted signaling this.\"},\"RoleGranted(bytes32,address,address)\":{\"details\":\"Emitted when `account` is granted `role`. `sender` is the account that originated the contract call, an admin role bearer except when using {AccessControl-_setupRole}.\"},\"RoleRevoked(bytes32,address,address)\":{\"details\":\"Emitted when `account` is revoked `role`. `sender` is the account that originated the contract call:   - if using `revokeRole`, it is the admin role bearer   - if using `renounceRole`, it is the role bearer (i.e. `account`)\"}},\"kind\":\"dev\",\"methods\":{\"getRoleAdmin(bytes32)\":{\"details\":\"Returns the admin role that controls `role`. See {grantRole} and {revokeRole}. To change a role's admin, use {AccessControl-_setRoleAdmin}.\"},\"grantRole(bytes32,address)\":{\"details\":\"Grants `role` to `account`. If `account` had not been already granted `role`, emits a {RoleGranted} event. Requirements: - the caller must have ``role``'s admin role.\"},\"hasRole(bytes32,address)\":{\"details\":\"Returns `true` if `account` has been granted `role`.\"},\"renounceRole(bytes32,address)\":{\"details\":\"Revokes `role` from the calling account. Roles are often managed via {grantRole} and {revokeRole}: this function's purpose is to provide a mechanism for accounts to lose their privileges if they are compromised (such as when a trusted device is misplaced). If the calling account had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must be `callerConfirmation`.\"},\"revokeRole(bytes32,address)\":{\"details\":\"Revokes `role` from `account`. If `account` had been granted `role`, emits a {RoleRevoked} event. Requirements: - the caller must have ``role``'s admin role.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"IAccessControl\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{"getRoleAdmin(bytes32)":"248a9ca3","grantRole(bytes32,address)":"2f2ff15d","hasRole(bytes32,address)":"91d14854","renounceRole(bytes32,address)":"36568abe","revokeRole(bytes32,address)":"d547741f"}},"solidity/FastBridgeMock.sol:IAdmin":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"guard","type":"address"}],"name":"GuardAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"guard","type":"address"}],"name":"GuardRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"relayer","type":"address"}],"name":"RelayerAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"relayer","type":"address"}],"name":"RelayerRemoved","type":"event"},{"inputs":[{"internalType":"address","name":"_guard","type":"address"}],"name":"addGuard","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_relayer","type":"address"}],"name":"addRelayer","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_guard","type":"address"}],"name":"removeGuard","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_relayer","type":"address"}],"name":"removeRelayer","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"GuardAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"guard\",\"type\":\"address\"}],\"name\":\"GuardRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"RelayerRemoved\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guard\",\"type\":\"address\"}],\"name\":\"addGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"addRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_guard\",\"type\":\"address\"}],\"name\":\"removeGuard\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_relayer\",\"type\":\"address\"}],\"name\":\"removeRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"IAdmin\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{"addGuard(address)":"6913a63c","addRelayer(address)":"dd39f00d","removeGuard(address)":"b6235016","removeRelayer(address)":"60f0a5ac"}},"solidity/FastBridgeMock.sol:IERC165":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes4","name":"interfaceId","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Interface of the ERC-165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[ERC]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.","kind":"dev","methods":{"supportsInterface(bytes4)":{"details":"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section] to learn more about how these ids are created. This function call must use less than 30 000 gas."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC-165 standard, as defined in the https://eips.ethereum.org/EIPS/eip-165[ERC]. Implementers can declare support of contract interfaces, which can then be queried by others ({ERC165Checker}). For an implementation, see {ERC165}.\",\"kind\":\"dev\",\"methods\":{\"supportsInterface(bytes4)\":{\"details\":\"Returns true if this contract implements the interface defined by `interfaceId`. See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section] to learn more about how these ids are created. This function call must use less than 30 000 gas.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"IERC165\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{"supportsInterface(bytes4)":"01ffc9a7"}},"solidity/FastBridgeMock.sol:IFastBridge":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositClaimed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeDepositRefunded","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"relayer","type":"address"}],"name":"BridgeProofDisputed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"bytes32","name":"transactionHash","type":"bytes32"}],"name":"BridgeProofProvided","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"BridgeRelayed","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes32","name":"transactionId","type":"bytes32"},{"indexed":false,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"bytes","name":"request","type":"bytes"}],"name":"BridgeRequested","type":"event"},{"inputs":[{"components":[{"internalType":"uint32","name":"dstChainId","type":"uint32"},{"internalType":"address","name":"to","type":"address"},{"internalType":"address","name":"originToken","type":"address"},{"internalType":"address","name":"destToken","type":"address"},{"internalType":"uint256","name":"originAmount","type":"uint256"},{"internalType":"uint256","name":"destAmount","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"internalType":"struct IFastBridge.BridgeParams","name":"params","type":"tuple"}],"name":"bridge","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"address","name":"to","type":"address"}],"name":"claim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"transactionId","type":"bytes32"}],"name":"dispute","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"bytes32","name":"destTxHash","type":"bytes32"}],"name":"prove","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"},{"internalType":"address","name":"to","type":"address"}],"name":"refund","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes","name":"request","type":"bytes"}],"name":"relay","outputs":[],"stateMutability":"payable","type":"function"}],"userDoc":{"kind":"user","methods":{"bridge((uint32,address,address,address,uint256,uint256,uint256))":{"notice":"Initiates bridge on origin chain to be relayed by off-chain relayer"},"claim(bytes,address)":{"notice":"Completes bridge transaction on origin chain by claiming originally deposited capital"},"dispute(bytes32)":{"notice":"Disputes an outstanding proof in case relayer provided dest chain tx is invalid"},"prove(bytes,bytes32)":{"notice":"Provides proof on origin side that relayer provided funds on destination side of bridge transaction"},"refund(bytes,address)":{"notice":"Refunds an outstanding bridge transaction in case optimistic bridging failed"},"relay(bytes)":{"notice":"Relays destination side of bridge transaction by off-chain relayer"}},"version":1},"developerDoc":{"kind":"dev","methods":{"bridge((uint32,address,address,address,uint256,uint256,uint256))":{"params":{"params":"The parameters required to bridge"}},"claim(bytes,address)":{"params":{"request":"The encoded bridge transaction to claim on origin chain","to":"The recipient address of the funds"}},"dispute(bytes32)":{"params":{"transactionId":"The transaction id associated with the encoded bridge transaction to dispute"}},"prove(bytes,bytes32)":{"params":{"destTxHash":"The destination tx hash proving bridge transaction was relayed","request":"The encoded bridge transaction to prove on origin chain"}},"refund(bytes,address)":{"params":{"request":"The encoded bridge transaction to refund","to":"The recipient address of the funds"}},"relay(bytes)":{"params":{"request":"The encoded bridge transaction to relay on destination chain"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeDepositRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"}],\"name\":\"BridgeProofDisputed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"BridgeProofProvided\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BridgeRelayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"BridgeRequested\",\"type\":\"event\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"dstChainId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"originToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"originAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"internalType\":\"struct IFastBridge.BridgeParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"bridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"transactionId\",\"type\":\"bytes32\"}],\"name\":\"dispute\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"destTxHash\",\"type\":\"bytes32\"}],\"name\":\"prove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"}],\"name\":\"refund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"request\",\"type\":\"bytes\"}],\"name\":\"relay\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"bridge((uint32,address,address,address,uint256,uint256,uint256))\":{\"params\":{\"params\":\"The parameters required to bridge\"}},\"claim(bytes,address)\":{\"params\":{\"request\":\"The encoded bridge transaction to claim on origin chain\",\"to\":\"The recipient address of the funds\"}},\"dispute(bytes32)\":{\"params\":{\"transactionId\":\"The transaction id associated with the encoded bridge transaction to dispute\"}},\"prove(bytes,bytes32)\":{\"params\":{\"destTxHash\":\"The destination tx hash proving bridge transaction was relayed\",\"request\":\"The encoded bridge transaction to prove on origin chain\"}},\"refund(bytes,address)\":{\"params\":{\"request\":\"The encoded bridge transaction to refund\",\"to\":\"The recipient address of the funds\"}},\"relay(bytes)\":{\"params\":{\"request\":\"The encoded bridge transaction to relay on destination chain\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"bridge((uint32,address,address,address,uint256,uint256,uint256))\":{\"notice\":\"Initiates bridge on origin chain to be relayed by off-chain relayer\"},\"claim(bytes,address)\":{\"notice\":\"Completes bridge transaction on origin chain by claiming originally deposited capital\"},\"dispute(bytes32)\":{\"notice\":\"Disputes an outstanding proof in case relayer provided dest chain tx is invalid\"},\"prove(bytes,bytes32)\":{\"notice\":\"Provides proof on origin side that relayer provided funds on destination side of bridge transaction\"},\"refund(bytes,address)\":{\"notice\":\"Refunds an outstanding bridge transaction in case optimistic bridging failed\"},\"relay(bytes)\":{\"notice\":\"Relays destination side of bridge transaction by off-chain relayer\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"IFastBridge\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{"bridge((uint32,address,address,address,uint256,uint256,uint256))":"0728e3ad","claim(bytes,address)":"41fcb612","dispute(bytes32)":"add98c70","prove(bytes,bytes32)":"886d36ff","refund(bytes,address)":"ef059bd3","relay(bytes)":"8f0d6f17"}},"solidity/FastBridgeMock.sol:Ownable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the address provided by the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. The initial owner is set to the address provided by the deployer. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the address provided by the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"Ownable\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{"owner()":"8da5cb5b","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}},"solidity/FastBridgeMock.sol:Ownable2Step":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n/**\n * @dev Contract module which provides access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * This extension of the {Ownable} contract includes a two-step mechanism to transfer\n * ownership, where the new owner must call {acceptOwnership} in order to replace the\n * old one. This can help prevent common mistakes, such as transfers of ownership to\n * incorrect accounts, or to contracts that are unable to interact with the\n * permission system.\n *\n * The initial owner is specified at deployment time in the constructor for `Ownable`. This\n * can later be changed with {transferOwnership} and {acceptOwnership}.\n *\n * This module is used through inheritance. It will make available all functions\n * from parent (Ownable).\n */\nabstract contract Ownable2Step is Ownable {\n    address private _pendingOwner;\n\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Returns the address of the pending owner.\n     */\n    function pendingOwner() public view virtual returns (address) {\n        return _pendingOwner;\n    }\n\n    /**\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\n        _pendingOwner = newOwner;\n        emit OwnershipTransferStarted(owner(), newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual override {\n        delete _pendingOwner;\n        super._transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev The new owner accepts the ownership transfer.\n     */\n    function acceptOwnership() public virtual {\n        address sender = _msgSender();\n        if (pendingOwner() != sender) {\n            revert OwnableUnauthorizedAccount(sender);\n        }\n        _transferOwnership(sender);\n    }\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\n/**\n * @dev External interface of AccessControl declared to support ERC-165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\n/**\n * @dev Interface of the ERC-165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[ERC].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[ERC section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC-165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account =\u003e bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role =\u003e RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ninterface IAdmin {\n    // ============ Events ============\n\n    event RelayerAdded(address relayer);\n    event RelayerRemoved(address relayer);\n\n    event GuardAdded(address guard);\n    event GuardRemoved(address guard);\n\n    // ============ Methods ============\n\n    function addRelayer(address _relayer) external;\n\n    function removeRelayer(address _relayer) external;\n\n    function addGuard(address _guard) external;\n\n    function removeGuard(address _guard) external;\n}\n\ncontract Admin is IAdmin, Ownable2Step, AccessControl {\n    bytes32 public constant RELAYER_ROLE = keccak256(\"RELAYER_ROLE\");\n    bytes32 public constant GUARD_ROLE = keccak256(\"GUARD_ROLE\");\n\n    modifier onlyGuard() {\n        require(hasRole(GUARD_ROLE, msg.sender), \"Caller is not a guard\");\n        _;\n    }\n\n    modifier onlyRelayer() {\n        require(hasRole(RELAYER_ROLE, msg.sender), \"Caller is not a relayer\");\n        _;\n    }\n\n    constructor(address _owner) Ownable(_owner) {\n        _grantRole(DEFAULT_ADMIN_ROLE, _owner);\n    }\n\n    function addRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(RELAYER_ROLE, _relayer);\n        emit RelayerAdded(_relayer);\n    }\n\n    function removeRelayer(address _relayer) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(RELAYER_ROLE, _relayer);\n        emit RelayerRemoved(_relayer);\n    }\n\n    function addGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _grantRole(GUARD_ROLE, _guard);\n        emit GuardAdded(_guard);\n    }\n\n    function removeGuard(address _guard) external {\n        require(hasRole(DEFAULT_ADMIN_ROLE, msg.sender));\n        _revokeRole(GUARD_ROLE, _guard);\n        emit GuardRemoved(_guard);\n    }\n}\n\ninterface IFastBridge {\n    struct BridgeTransaction {\n        uint32 originChainId;\n        uint32 destChainId;\n        address originSender; // user (origin)\n        address destRecipient; // user (dest)\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n        uint256 nonce;\n    }\n\n    struct BridgeProof {\n        uint96 timestamp;\n        address relayer;\n    }\n\n    // ============ Events ============\n\n    event BridgeRequested(bytes32 transactionId, address sender, bytes request);\n    event BridgeRelayed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeProofProvided(bytes32 transactionId, address relayer, bytes32 transactionHash);\n    event BridgeProofDisputed(bytes32 transactionId, address relayer);\n    event BridgeDepositClaimed(bytes32 transactionId, address relayer, address to, address token, uint256 amount);\n    event BridgeDepositRefunded(bytes32 transactionId, address to, address token, uint256 amount);\n\n    // ============ Methods ============\n\n    struct BridgeParams {\n        uint32 dstChainId;\n        address to;\n        address originToken;\n        address destToken;\n        uint256 originAmount;\n        uint256 destAmount;\n        uint256 deadline;\n    }\n\n    /// @notice Initiates bridge on origin chain to be relayed by off-chain relayer\n    /// @param params The parameters required to bridge\n    function bridge(BridgeParams memory params) external payable;\n\n    /// @notice Relays destination side of bridge transaction by off-chain relayer\n    /// @param request The encoded bridge transaction to relay on destination chain\n    function relay(bytes memory request) external payable;\n\n    /// @notice Provides proof on origin side that relayer provided funds on destination side of bridge transaction\n    /// @param request The encoded bridge transaction to prove on origin chain\n    /// @param destTxHash The destination tx hash proving bridge transaction was relayed\n    function prove(bytes memory request, bytes32 destTxHash) external;\n\n    /// @notice Completes bridge transaction on origin chain by claiming originally deposited capital\n    /// @param request The encoded bridge transaction to claim on origin chain\n    /// @param to The recipient address of the funds\n    function claim(bytes memory request, address to) external;\n\n    /// @notice Disputes an outstanding proof in case relayer provided dest chain tx is invalid\n    /// @param transactionId The transaction id associated with the encoded bridge transaction to dispute\n    function dispute(bytes32 transactionId) external;\n\n    /// @notice Refunds an outstanding bridge transaction in case optimistic bridging failed\n    /// @param request The encoded bridge transaction to refund\n    /// @param to The recipient address of the funds\n    function refund(bytes memory request, address to) external;\n}\n\ncontract FastBridgeMock is IFastBridge, Admin {\n    // @dev the block the contract was deployed at\n    uint256 public immutable deployBlock;\n\n    constructor(address _owner) Admin(_owner) {\n        deployBlock = block.number;\n    }\n\n    /// @dev to prevent replays\n    uint256 public nonce;\n\n    function mockBridgeRequest(bytes32 transactionId, address sender, BridgeParams memory params) external {\n        bytes memory request = abi.encode(\n            BridgeTransaction({\n                originChainId: uint32(block.chainid),\n                destChainId: params.dstChainId,\n                originSender: msg.sender,\n                destRecipient: params.to,\n                originToken: params.originToken,\n                destToken: params.destToken,\n                originAmount: params.originAmount, // includes relayer fee\n                destAmount: params.destAmount,\n                deadline: params.deadline,\n                nonce: nonce++ // increment nonce on every bridge\n            })\n        );\n\n        emit BridgeRequested(transactionId, msg.sender, request);\n    }\n\n    function mockBridgeRequestRaw(bytes32  transactionId, address sender, bytes memory request) external  {\n        emit BridgeRequested(transactionId, sender, request);\n    }\n\n    function mockBridgeRelayer(bytes32 transactionId, address relayer, address to, address token, uint256 amount) external  {\n        emit BridgeRelayed(transactionId, relayer, to, token, amount);\n    }\n\n    function bridge(BridgeParams memory params) external payable{\n        // do nothing\n    }\n\n    function relay(bytes memory request) external payable {\n        // do nothing\n    }\n\n    function prove(bytes memory request, bytes32 destTxHash) external {\n        // do nothing\n    }\n\n    function claim(bytes memory request, address to) external {\n        // do nothing\n    }\n\n    function dispute(bytes32 transactionId) external {\n        // do nothing\n    }\n\n    function refund(bytes memory request, address to) external {\n        // do nothing\n    }\n}\n","language":"Solidity","languageVersion":"0.8.20","compilerVersion":"0.8.20","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../ --evm-version=istanbul","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"OwnableInvalidOwner","type":"error"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"OwnableUnauthorizedAccount","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferStarted","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"acceptOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"pendingOwner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. This extension of the {Ownable} contract includes a two-step mechanism to transfer ownership, where the new owner must call {acceptOwnership} in order to replace the old one. This can help prevent common mistakes, such as transfers of ownership to incorrect accounts, or to contracts that are unable to interact with the permission system. The initial owner is specified at deployment time in the constructor for `Ownable`. This can later be changed with {transferOwnership} and {acceptOwnership}. This module is used through inheritance. It will make available all functions from parent (Ownable).","errors":{"OwnableInvalidOwner(address)":[{"details":"The owner is not a valid owner account. (eg. `address(0)`)"}],"OwnableUnauthorizedAccount(address)":[{"details":"The caller account is not authorized to perform an operation."}]},"kind":"dev","methods":{"acceptOwnership()":{"details":"The new owner accepts the ownership transfer."},"owner()":{"details":"Returns the address of the current owner."},"pendingOwner()":{"details":"Returns the address of the pending owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"OwnableInvalidOwner\",\"type\":\"error\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"OwnableUnauthorizedAccount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. This extension of the {Ownable} contract includes a two-step mechanism to transfer ownership, where the new owner must call {acceptOwnership} in order to replace the old one. This can help prevent common mistakes, such as transfers of ownership to incorrect accounts, or to contracts that are unable to interact with the permission system. The initial owner is specified at deployment time in the constructor for `Ownable`. This can later be changed with {transferOwnership} and {acceptOwnership}. This module is used through inheritance. It will make available all functions from parent (Ownable).\",\"errors\":{\"OwnableInvalidOwner(address)\":[{\"details\":\"The owner is not a valid owner account. (eg. `address(0)`)\"}],\"OwnableUnauthorizedAccount(address)\":[{\"details\":\"The caller account is not authorized to perform an operation.\"}]},\"kind\":\"dev\",\"methods\":{\"acceptOwnership()\":{\"details\":\"The new owner accepts the ownership transfer.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"pendingOwner()\":{\"details\":\"Returns the address of the pending owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one. Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/FastBridgeMock.sol\":\"Ownable2Step\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/FastBridgeMock.sol\":{\"keccak256\":\"0x33b81bc52e4063d2b08b3ea3c35cc12218e5a1d7b72dd8545c9471fe67ce38d1\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f594396e2d7f70a46028d143ad4a43cd108d0ced25ec6a5f4fa122bbf3780e48\",\"dweb:/ipfs/QmbzRMBsWTFUF8R55HganiiLmAoZBmc8vRq8cjnZ8eQfm8\"]}},\"version\":1}"},"hashes":{"acceptOwnership()":"79ba5097","owner()":"8da5cb5b","pendingOwner()":"e30c3978","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}}}