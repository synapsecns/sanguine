package service

import (
	"context"
	"fmt"

	"github.com/cornelk/hashmap"
	"github.com/synapsecns/sanguine/core/metrics"
	"github.com/synapsecns/sanguine/ethergo/signer/signer"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

const meterName = "github.com/synapsecns/sanguine/services/rfq/relayer/service"

// generate an interface for otelRecorder that exports the public method.
// this allows us to avoid using recordX externally anad makes the package less confusing.
//
// =============================================================================
// =============================================================================
// IMPORTANT: DO NOT REMOVE THIS COMMENT.
// NOTICE: PLEASE MAKE SURE YOU UPDATE BOTH THE DOCS AND THE GRAFANA DASHBOARD (IF NEEDED) AFTER UPDATING METRICS.
// =============================================================================
// =============================================================================
//
//go:generate go run github.com/vburenin/ifacemaker -f otel.go -s otelRecorder -i iOtelRecorder -p service -o otel_generated.go -c "autogenerated file"
type otelRecorder struct {
	metrics metrics.Handler
	// meter is the metrics meter.
	meter metric.Meter
	// statusGauge is the gauge for the status.
	statusGauge metric.Int64ObservableGauge
	// statuses is used for metrics.
	// status -> count
	statuses *hashmap.Map[int, int]
	// signer is the signer for signing transactions.
	signer signer.Signer
}

func newOtelRecorder(meterHandler metrics.Handler, signer signer.Signer) (_ iOtelRecorder, err error) {
	or := otelRecorder{
		metrics:  meterHandler,
		meter:    meterHandler.Meter(meterName),
		statuses: hashmap.New[int, int](),
		signer:   signer,
	}

	or.statusGauge, err = or.meter.Int64ObservableGauge("status")
	if err != nil {
		return nil, fmt.Errorf("could not create last block gauge")
	}

	_, err = or.meter.RegisterCallback(or.recordStatusCounts, or.statusGauge)
	if err != nil {
		return nil, fmt.Errorf("could not register callback for status gauge")
	}

	return &or, nil
}

func (o *otelRecorder) recordStatusCounts(_ context.Context, observer metric.Observer) (err error) {
	if o.metrics == nil || o.statusGauge == nil || o.statuses == nil {
		return nil
	}

	o.statuses.Range(func(status int, count int) bool {
		opts := metric.WithAttributes(
			attribute.Int("status", int(status)),
			attribute.String("wallet", o.signer.Address().Hex()),
		)
		observer.ObserveInt64(o.statusGauge, int64(count), opts)

		return true
	})

	return nil
}

// RecordStatuses records the request status count.
func (o *otelRecorder) RecordStatusCount(status, count int) {
	o.statuses.Set(status, count)
}
