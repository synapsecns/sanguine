{"solidity/MockMessageTransmitter.sol:IMessageTransmitter":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract MessageTransmitterEvents {\n    /**\n     * @notice Emitted when a new message is dispatched\n     * @param message Raw bytes of message\n     */\n    event MessageSent(bytes message);\n\n    /**\n     * @notice Emitted when a new message is received\n     * @param caller Caller (msg.sender) on destination domain\n     * @param sourceDomain The source domain this message originated from\n     * @param nonce The nonce unique to this message\n     * @param sender The sender of this message\n     * @param messageBody message body bytes\n     */\n    event MessageReceived(\n        address indexed caller,\n        uint32 sourceDomain,\n        uint64 indexed nonce,\n        bytes32 sender,\n        bytes messageBody\n    );\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// Very simplified version of CCTP's MessageTransmitter for testing purposes.\ncontract MockMessageTransmitter is MessageTransmitterEvents, IMessageTransmitter {\n    uint32 public override localDomain;\n    uint64 public override nextAvailableNonce;\n\n    event SignatureReceived(bytes signature);\n\n    constructor(uint32 localDomain_) {\n        localDomain = localDomain_;\n        nextAvailableNonce = 1;\n    }\n\n    function sendMessageWithCaller(\n        uint32,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64 reservedNonce) {\n        reservedNonce = nextAvailableNonce;\n        nextAvailableNonce = reservedNonce + 1;\n        emit MessageSent(\n            formatMessage({\n                remoteDomain: localDomain,\n                sender: msg.sender,\n                recipient: address(uint160(uint256(recipient))),\n                destinationCaller: destinationCaller,\n                messageBody: messageBody\n            })\n        );\n    }\n\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success) {\n        // This is added to test if SynapseCCTP could handle MessageTransmitter returning false.\n        if (signature.length == 1) return false;\n        require(signature.length % 65 == 0, \"Invalid attestation length\");\n        (\n            uint32 remoteDomain,\n            bytes32 sender,\n            address recipient,\n            bytes32 destinationCaller,\n            bytes memory messageBody\n        ) = abi.decode(message, (uint32, bytes32, address, bytes32, bytes));\n        if (destinationCaller != 0) {\n            require(destinationCaller == bytes32(uint256(uint160(msg.sender))), \"Invalid caller for message\");\n        }\n        require(\n            ITokenMessenger(recipient).handleReceiveMessage(remoteDomain, sender, messageBody),\n            \"handleReceiveMessage() failed\"\n        );\n        emit SignatureReceived(signature);\n        return true;\n    }\n\n    function formatMessage(\n        uint32 remoteDomain,\n        address sender,\n        address recipient,\n        bytes32 destinationCaller,\n        bytes memory messageBody\n    ) public pure returns (bytes memory message) {\n        message = abi.encode(remoteDomain, sender, recipient, destinationCaller, messageBody);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"localDomain","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextAvailableNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"receiveMessage","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"recipient","type":"bytes32"},{"internalType":"bytes32","name":"destinationCaller","type":"bytes32"},{"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"sendMessageWithCaller","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"receiveMessage(bytes,bytes)":{"notice":"Receives an incoming message, validating the header and passing the body to application-specific handler."},"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)":{"notice":"Sends an outgoing message from the source domain, with a specified caller on the destination domain."}},"version":1},"developerDoc":{"kind":"dev","methods":{"receiveMessage(bytes,bytes)":{"params":{"message":"The message raw bytes","signature":"The message signature"},"returns":{"success":"bool, true if successful"}},"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)":{"details":"Increment nonce, format the message, and emit `MessageSent` event with message information. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard sendMessage() should be preferred for use cases where a specific destination caller is not required.","params":{"destinationCaller":"caller on the destination domain, as bytes32","destinationDomain":"Domain of destination chain","messageBody":"Raw bytes content of message","recipient":"Address of message recipient on destination domain as bytes32"},"returns":{"_0":"nonce reserved by message"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"localDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextAvailableNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCaller\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageBody\",\"type\":\"bytes\"}],\"name\":\"sendMessageWithCaller\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveMessage(bytes,bytes)\":{\"params\":{\"message\":\"The message raw bytes\",\"signature\":\"The message signature\"},\"returns\":{\"success\":\"bool, true if successful\"}},\"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)\":{\"details\":\"Increment nonce, format the message, and emit `MessageSent` event with message information. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard sendMessage() should be preferred for use cases where a specific destination caller is not required.\",\"params\":{\"destinationCaller\":\"caller on the destination domain, as bytes32\",\"destinationDomain\":\"Domain of destination chain\",\"messageBody\":\"Raw bytes content of message\",\"recipient\":\"Address of message recipient on destination domain as bytes32\"},\"returns\":{\"_0\":\"nonce reserved by message\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"receiveMessage(bytes,bytes)\":{\"notice\":\"Receives an incoming message, validating the header and passing the body to application-specific handler.\"},\"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)\":{\"notice\":\"Sends an outgoing message from the source domain, with a specified caller on the destination domain.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MockMessageTransmitter.sol\":\"IMessageTransmitter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MockMessageTransmitter.sol\":{\"keccak256\":\"0x85d7708f952fd505cccca33bbc9c910d511461d01f96969a6b8e7656ee8677c8\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://72bfa66545d9ddde1dc34863555a44aaf30d9661ecec7afbf3cc62e1d8d412de\",\"dweb:/ipfs/QmTpVWa2FbRk1sbKMq9CYFNphQ377WpFCvWJEeHce6FyB1\"]}},\"version\":1}"},"hashes":{"localDomain()":"8d3638f4","nextAvailableNonce()":"8371744e","receiveMessage(bytes,bytes)":"57ecfd28","sendMessageWithCaller(uint32,bytes32,bytes32,bytes)":"f7259a75"}},"solidity/MockMessageTransmitter.sol:ITokenMessenger":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract MessageTransmitterEvents {\n    /**\n     * @notice Emitted when a new message is dispatched\n     * @param message Raw bytes of message\n     */\n    event MessageSent(bytes message);\n\n    /**\n     * @notice Emitted when a new message is received\n     * @param caller Caller (msg.sender) on destination domain\n     * @param sourceDomain The source domain this message originated from\n     * @param nonce The nonce unique to this message\n     * @param sender The sender of this message\n     * @param messageBody message body bytes\n     */\n    event MessageReceived(\n        address indexed caller,\n        uint32 sourceDomain,\n        uint64 indexed nonce,\n        bytes32 sender,\n        bytes messageBody\n    );\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// Very simplified version of CCTP's MessageTransmitter for testing purposes.\ncontract MockMessageTransmitter is MessageTransmitterEvents, IMessageTransmitter {\n    uint32 public override localDomain;\n    uint64 public override nextAvailableNonce;\n\n    event SignatureReceived(bytes signature);\n\n    constructor(uint32 localDomain_) {\n        localDomain = localDomain_;\n        nextAvailableNonce = 1;\n    }\n\n    function sendMessageWithCaller(\n        uint32,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64 reservedNonce) {\n        reservedNonce = nextAvailableNonce;\n        nextAvailableNonce = reservedNonce + 1;\n        emit MessageSent(\n            formatMessage({\n                remoteDomain: localDomain,\n                sender: msg.sender,\n                recipient: address(uint160(uint256(recipient))),\n                destinationCaller: destinationCaller,\n                messageBody: messageBody\n            })\n        );\n    }\n\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success) {\n        // This is added to test if SynapseCCTP could handle MessageTransmitter returning false.\n        if (signature.length == 1) return false;\n        require(signature.length % 65 == 0, \"Invalid attestation length\");\n        (\n            uint32 remoteDomain,\n            bytes32 sender,\n            address recipient,\n            bytes32 destinationCaller,\n            bytes memory messageBody\n        ) = abi.decode(message, (uint32, bytes32, address, bytes32, bytes));\n        if (destinationCaller != 0) {\n            require(destinationCaller == bytes32(uint256(uint160(msg.sender))), \"Invalid caller for message\");\n        }\n        require(\n            ITokenMessenger(recipient).handleReceiveMessage(remoteDomain, sender, messageBody),\n            \"handleReceiveMessage() failed\"\n        );\n        emit SignatureReceived(signature);\n        return true;\n    }\n\n    function formatMessage(\n        uint32 remoteDomain,\n        address sender,\n        address recipient,\n        bytes32 destinationCaller,\n        bytes memory messageBody\n    ) public pure returns (bytes memory message) {\n        message = abi.encode(remoteDomain, sender, recipient, destinationCaller, messageBody);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"mintRecipient","type":"bytes32"},{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"bytes32","name":"destinationCaller","type":"bytes32"}],"name":"depositForBurnWithCaller","outputs":[{"internalType":"uint64","name":"nonce","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"handleReceiveMessage","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"localMessageTransmitter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"localMinter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)":{"notice":"Deposits and burns tokens from sender to be minted on destination domain. The mint on the destination domain must be called by `destinationCaller`. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard depositForBurn() should be preferred for use cases where a specific destination caller is not required. Emits a `DepositForBurn` event."},"handleReceiveMessage(uint32,bytes32,bytes)":{"notice":"Handles an incoming message received by the local MessageTransmitter, and takes the appropriate action. For a burn message, mints the associated token to the requested recipient on the local domain."}},"version":1},"developerDoc":{"kind":"dev","methods":{"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)":{"details":"reverts if: - given destinationCaller is zero address - given burnToken is not supported - given destinationDomain has no TokenMessenger registered - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance to this contract is less than `amount`. - burn() reverts. For example, if `amount` is 0. - MessageTransmitter returns false or reverts.","params":{"amount":"amount of tokens to burn","burnToken":"address of contract to burn deposited tokens, on local domain","destinationCaller":"caller on the destination domain, as bytes32","destinationDomain":"destination domain","mintRecipient":"address of mint recipient on destination domain"},"returns":{"nonce":"unique nonce reserved by message"}},"handleReceiveMessage(uint32,bytes32,bytes)":{"details":"Validates the local sender is the local MessageTransmitter, and the remote sender is a registered remote TokenMessenger for `remoteDomain`.","params":{"messageBody":"The message body bytes.","remoteDomain":"The domain where the message originated from.","sender":"The sender of the message (remote TokenMessenger)."},"returns":{"success":"Bool, true if successful."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"mintRecipient\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCaller\",\"type\":\"bytes32\"}],\"name\":\"depositForBurnWithCaller\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageBody\",\"type\":\"bytes\"}],\"name\":\"handleReceiveMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localMessageTransmitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)\":{\"details\":\"reverts if: - given destinationCaller is zero address - given burnToken is not supported - given destinationDomain has no TokenMessenger registered - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance to this contract is less than `amount`. - burn() reverts. For example, if `amount` is 0. - MessageTransmitter returns false or reverts.\",\"params\":{\"amount\":\"amount of tokens to burn\",\"burnToken\":\"address of contract to burn deposited tokens, on local domain\",\"destinationCaller\":\"caller on the destination domain, as bytes32\",\"destinationDomain\":\"destination domain\",\"mintRecipient\":\"address of mint recipient on destination domain\"},\"returns\":{\"nonce\":\"unique nonce reserved by message\"}},\"handleReceiveMessage(uint32,bytes32,bytes)\":{\"details\":\"Validates the local sender is the local MessageTransmitter, and the remote sender is a registered remote TokenMessenger for `remoteDomain`.\",\"params\":{\"messageBody\":\"The message body bytes.\",\"remoteDomain\":\"The domain where the message originated from.\",\"sender\":\"The sender of the message (remote TokenMessenger).\"},\"returns\":{\"success\":\"Bool, true if successful.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)\":{\"notice\":\"Deposits and burns tokens from sender to be minted on destination domain. The mint on the destination domain must be called by `destinationCaller`. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard depositForBurn() should be preferred for use cases where a specific destination caller is not required. Emits a `DepositForBurn` event.\"},\"handleReceiveMessage(uint32,bytes32,bytes)\":{\"notice\":\"Handles an incoming message received by the local MessageTransmitter, and takes the appropriate action. For a burn message, mints the associated token to the requested recipient on the local domain.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MockMessageTransmitter.sol\":\"ITokenMessenger\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MockMessageTransmitter.sol\":{\"keccak256\":\"0x85d7708f952fd505cccca33bbc9c910d511461d01f96969a6b8e7656ee8677c8\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://72bfa66545d9ddde1dc34863555a44aaf30d9661ecec7afbf3cc62e1d8d412de\",\"dweb:/ipfs/QmTpVWa2FbRk1sbKMq9CYFNphQ377WpFCvWJEeHce6FyB1\"]}},\"version\":1}"},"hashes":{"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)":"f856ddb6","handleReceiveMessage(uint32,bytes32,bytes)":"96abeb70","localMessageTransmitter()":"2c121921","localMinter()":"cb75c11c"}},"solidity/MockMessageTransmitter.sol:MessageTransmitterEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract MessageTransmitterEvents {\n    /**\n     * @notice Emitted when a new message is dispatched\n     * @param message Raw bytes of message\n     */\n    event MessageSent(bytes message);\n\n    /**\n     * @notice Emitted when a new message is received\n     * @param caller Caller (msg.sender) on destination domain\n     * @param sourceDomain The source domain this message originated from\n     * @param nonce The nonce unique to this message\n     * @param sender The sender of this message\n     * @param messageBody message body bytes\n     */\n    event MessageReceived(\n        address indexed caller,\n        uint32 sourceDomain,\n        uint64 indexed nonce,\n        bytes32 sender,\n        bytes messageBody\n    );\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// Very simplified version of CCTP's MessageTransmitter for testing purposes.\ncontract MockMessageTransmitter is MessageTransmitterEvents, IMessageTransmitter {\n    uint32 public override localDomain;\n    uint64 public override nextAvailableNonce;\n\n    event SignatureReceived(bytes signature);\n\n    constructor(uint32 localDomain_) {\n        localDomain = localDomain_;\n        nextAvailableNonce = 1;\n    }\n\n    function sendMessageWithCaller(\n        uint32,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64 reservedNonce) {\n        reservedNonce = nextAvailableNonce;\n        nextAvailableNonce = reservedNonce + 1;\n        emit MessageSent(\n            formatMessage({\n                remoteDomain: localDomain,\n                sender: msg.sender,\n                recipient: address(uint160(uint256(recipient))),\n                destinationCaller: destinationCaller,\n                messageBody: messageBody\n            })\n        );\n    }\n\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success) {\n        // This is added to test if SynapseCCTP could handle MessageTransmitter returning false.\n        if (signature.length == 1) return false;\n        require(signature.length % 65 == 0, \"Invalid attestation length\");\n        (\n            uint32 remoteDomain,\n            bytes32 sender,\n            address recipient,\n            bytes32 destinationCaller,\n            bytes memory messageBody\n        ) = abi.decode(message, (uint32, bytes32, address, bytes32, bytes));\n        if (destinationCaller != 0) {\n            require(destinationCaller == bytes32(uint256(uint160(msg.sender))), \"Invalid caller for message\");\n        }\n        require(\n            ITokenMessenger(recipient).handleReceiveMessage(remoteDomain, sender, messageBody),\n            \"handleReceiveMessage() failed\"\n        );\n        emit SignatureReceived(signature);\n        return true;\n    }\n\n    function formatMessage(\n        uint32 remoteDomain,\n        address sender,\n        address recipient,\n        bytes32 destinationCaller,\n        bytes memory messageBody\n    ) public pure returns (bytes memory message) {\n        message = abi.encode(remoteDomain, sender, recipient, destinationCaller, messageBody);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":false,"internalType":"uint32","name":"sourceDomain","type":"uint32"},{"indexed":true,"internalType":"uint64","name":"nonce","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"sender","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"MessageReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"}],"name":"MessageSent","type":"event"}],"userDoc":{"events":{"MessageReceived(address,uint32,uint64,bytes32,bytes)":{"notice":"Emitted when a new message is received"},"MessageSent(bytes)":{"notice":"Emitted when a new message is dispatched"}},"kind":"user","methods":{},"version":1},"developerDoc":{"events":{"MessageReceived(address,uint32,uint64,bytes32,bytes)":{"params":{"caller":"Caller (msg.sender) on destination domain","messageBody":"message body bytes","nonce":"The nonce unique to this message","sender":"The sender of this message","sourceDomain":"The source domain this message originated from"}},"MessageSent(bytes)":{"params":{"message":"Raw bytes of message"}}},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"sourceDomain\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"messageBody\",\"type\":\"bytes\"}],\"name\":\"MessageReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"}],\"devdoc\":{\"events\":{\"MessageReceived(address,uint32,uint64,bytes32,bytes)\":{\"params\":{\"caller\":\"Caller (msg.sender) on destination domain\",\"messageBody\":\"message body bytes\",\"nonce\":\"The nonce unique to this message\",\"sender\":\"The sender of this message\",\"sourceDomain\":\"The source domain this message originated from\"}},\"MessageSent(bytes)\":{\"params\":{\"message\":\"Raw bytes of message\"}}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"events\":{\"MessageReceived(address,uint32,uint64,bytes32,bytes)\":{\"notice\":\"Emitted when a new message is received\"},\"MessageSent(bytes)\":{\"notice\":\"Emitted when a new message is dispatched\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MockMessageTransmitter.sol\":\"MessageTransmitterEvents\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MockMessageTransmitter.sol\":{\"keccak256\":\"0x85d7708f952fd505cccca33bbc9c910d511461d01f96969a6b8e7656ee8677c8\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://72bfa66545d9ddde1dc34863555a44aaf30d9661ecec7afbf3cc62e1d8d412de\",\"dweb:/ipfs/QmTpVWa2FbRk1sbKMq9CYFNphQ377WpFCvWJEeHce6FyB1\"]}},\"version\":1}"},"hashes":{}},"solidity/MockMessageTransmitter.sol:MockMessageTransmitter":{"code":"0x608060405234801561001057600080fd5b50604051610a42380380610a4283398101604081905261002f91610057565b600080546001600160601b03191663ffffffff90921691909117640100000000179055610084565b60006020828403121561006957600080fd5b815163ffffffff8116811461007d57600080fd5b9392505050565b6109af806100936000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c80638d3638f4116100505780638d3638f4146100c9578063d81bbe02146100ee578063f7259a751461010e57600080fd5b806357ecfd281461006c5780638371744e14610094575b600080fd5b61007f61007a3660046104dd565b610121565b60405190151581526020015b60405180910390f35b6000546100b090640100000000900467ffffffffffffffff1681565b60405167ffffffffffffffff909116815260200161008b565b6000546100d99063ffffffff1681565b60405163ffffffff909116815260200161008b565b6101016100fc366004610661565b610382565b60405161008b9190610742565b6100b061011c36600461075c565b6103b7565b600060018290036101345750600061037a565b61013f6041836107c4565b156101ab576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f496e76616c6964206174746573746174696f6e206c656e67746800000000000060448201526064015b60405180910390fd5b6000808080806101bd898b018b6107ff565b939850919650945092509050811561023857338214610238576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f496e76616c69642063616c6c657220666f72206d65737361676500000000000060448201526064016101a2565b6040517f96abeb7000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8416906396abeb709061028e90889088908690600401610837565b6020604051808303816000875af11580156102ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d19190610865565b610337576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f68616e646c65526563656976654d6573736167652829206661696c656400000060448201526064016101a2565b7fd5abd8bafd66536a7715960b4606ae43cbe944953190b51b2e984dff14d6b6108888604051610368929190610887565b60405180910390a16001955050505050505b949350505050565b6060858585858560405160200161039d9594939291906108d4565b604051602081830303815290604052905095945050505050565b600054640100000000900467ffffffffffffffff166103d781600161092a565b600060046101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b03661047660008054906101000a900463ffffffff16338860001c8888888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061038292505050565b6040516104839190610742565b60405180910390a195945050505050565b60008083601f8401126104a657600080fd5b50813567ffffffffffffffff8111156104be57600080fd5b6020830191508360208285010111156104d657600080fd5b9250929050565b600080600080604085870312156104f357600080fd5b843567ffffffffffffffff8082111561050b57600080fd5b61051788838901610494565b9096509450602087013591508082111561053057600080fd5b5061053d87828801610494565b95989497509550505050565b803563ffffffff8116811461055d57600080fd5b919050565b73ffffffffffffffffffffffffffffffffffffffff8116811461058457600080fd5b50565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126105c757600080fd5b813567ffffffffffffffff808211156105e2576105e2610587565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561062857610628610587565b8160405283815286602085880101111561064157600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600080600060a0868803121561067957600080fd5b61068286610549565b9450602086013561069281610562565b935060408601356106a281610562565b925060608601359150608086013567ffffffffffffffff8111156106c557600080fd5b6106d1888289016105b6565b9150509295509295909350565b6000815180845260005b81811015610704576020818501810151868301820152016106e8565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b60208152600061075560208301846106de565b9392505050565b60008060008060006080868803121561077457600080fd5b61077d86610549565b94506020860135935060408601359250606086013567ffffffffffffffff8111156107a757600080fd5b6107b388828901610494565b969995985093965092949392505050565b6000826107fa577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500690565b600080600080600060a0868803121561081757600080fd5b61082086610549565b94506020860135935060408601356106a281610562565b63ffffffff8416815282602082015260606040820152600061085c60608301846106de565b95945050505050565b60006020828403121561087757600080fd5b8151801515811461075557600080fd5b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b63ffffffff86168152600073ffffffffffffffffffffffffffffffffffffffff808716602084015280861660408401525083606083015260a0608083015261091f60a08301846106de565b979650505050505050565b67ffffffffffffffff818116838216019080821115610972577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b509291505056fea26469706673582212207c37228c4ae7cd15c4835c68e07402b56b73d3dab056c5e4d7ff06bdb231368464736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100675760003560e01c80638d3638f4116100505780638d3638f4146100c9578063d81bbe02146100ee578063f7259a751461010e57600080fd5b806357ecfd281461006c5780638371744e14610094575b600080fd5b61007f61007a3660046104dd565b610121565b60405190151581526020015b60405180910390f35b6000546100b090640100000000900467ffffffffffffffff1681565b60405167ffffffffffffffff909116815260200161008b565b6000546100d99063ffffffff1681565b60405163ffffffff909116815260200161008b565b6101016100fc366004610661565b610382565b60405161008b9190610742565b6100b061011c36600461075c565b6103b7565b600060018290036101345750600061037a565b61013f6041836107c4565b156101ab576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f496e76616c6964206174746573746174696f6e206c656e67746800000000000060448201526064015b60405180910390fd5b6000808080806101bd898b018b6107ff565b939850919650945092509050811561023857338214610238576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f496e76616c69642063616c6c657220666f72206d65737361676500000000000060448201526064016101a2565b6040517f96abeb7000000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8416906396abeb709061028e90889088908690600401610837565b6020604051808303816000875af11580156102ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102d19190610865565b610337576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601d60248201527f68616e646c65526563656976654d6573736167652829206661696c656400000060448201526064016101a2565b7fd5abd8bafd66536a7715960b4606ae43cbe944953190b51b2e984dff14d6b6108888604051610368929190610887565b60405180910390a16001955050505050505b949350505050565b6060858585858560405160200161039d9594939291906108d4565b604051602081830303815290604052905095945050505050565b600054640100000000900467ffffffffffffffff166103d781600161092a565b600060046101000a81548167ffffffffffffffff021916908367ffffffffffffffff1602179055507f8c5261668696ce22758910d05bab8f186d6eb247ceac2af2e82c7dc17669b03661047660008054906101000a900463ffffffff16338860001c8888888080601f01602080910402602001604051908101604052809392919081815260200183838082843760009201919091525061038292505050565b6040516104839190610742565b60405180910390a195945050505050565b60008083601f8401126104a657600080fd5b50813567ffffffffffffffff8111156104be57600080fd5b6020830191508360208285010111156104d657600080fd5b9250929050565b600080600080604085870312156104f357600080fd5b843567ffffffffffffffff8082111561050b57600080fd5b61051788838901610494565b9096509450602087013591508082111561053057600080fd5b5061053d87828801610494565b95989497509550505050565b803563ffffffff8116811461055d57600080fd5b919050565b73ffffffffffffffffffffffffffffffffffffffff8116811461058457600080fd5b50565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126105c757600080fd5b813567ffffffffffffffff808211156105e2576105e2610587565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561062857610628610587565b8160405283815286602085880101111561064157600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600080600060a0868803121561067957600080fd5b61068286610549565b9450602086013561069281610562565b935060408601356106a281610562565b925060608601359150608086013567ffffffffffffffff8111156106c557600080fd5b6106d1888289016105b6565b9150509295509295909350565b6000815180845260005b81811015610704576020818501810151868301820152016106e8565b5060006020828601015260207fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f83011685010191505092915050565b60208152600061075560208301846106de565b9392505050565b60008060008060006080868803121561077457600080fd5b61077d86610549565b94506020860135935060408601359250606086013567ffffffffffffffff8111156107a757600080fd5b6107b388828901610494565b969995985093965092949392505050565b6000826107fa577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500690565b600080600080600060a0868803121561081757600080fd5b61082086610549565b94506020860135935060408601356106a281610562565b63ffffffff8416815282602082015260606040820152600061085c60608301846106de565b95945050505050565b60006020828403121561087757600080fd5b8151801515811461075557600080fd5b60208152816020820152818360408301376000818301604090810191909152601f9092017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0160101919050565b63ffffffff86168152600073ffffffffffffffffffffffffffffffffffffffff808716602084015280861660408401525083606083015260a0608083015261091f60a08301846106de565b979650505050505050565b67ffffffffffffffff818116838216019080821115610972577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b509291505056fea26469706673582212207c37228c4ae7cd15c4835c68e07402b56b73d3dab056c5e4d7ff06bdb231368464736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nabstract contract MessageTransmitterEvents {\n    /**\n     * @notice Emitted when a new message is dispatched\n     * @param message Raw bytes of message\n     */\n    event MessageSent(bytes message);\n\n    /**\n     * @notice Emitted when a new message is received\n     * @param caller Caller (msg.sender) on destination domain\n     * @param sourceDomain The source domain this message originated from\n     * @param nonce The nonce unique to this message\n     * @param sender The sender of this message\n     * @param messageBody message body bytes\n     */\n    event MessageReceived(\n        address indexed caller,\n        uint32 sourceDomain,\n        uint64 indexed nonce,\n        bytes32 sender,\n        bytes messageBody\n    );\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// Very simplified version of CCTP's MessageTransmitter for testing purposes.\ncontract MockMessageTransmitter is MessageTransmitterEvents, IMessageTransmitter {\n    uint32 public override localDomain;\n    uint64 public override nextAvailableNonce;\n\n    event SignatureReceived(bytes signature);\n\n    constructor(uint32 localDomain_) {\n        localDomain = localDomain_;\n        nextAvailableNonce = 1;\n    }\n\n    function sendMessageWithCaller(\n        uint32,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64 reservedNonce) {\n        reservedNonce = nextAvailableNonce;\n        nextAvailableNonce = reservedNonce + 1;\n        emit MessageSent(\n            formatMessage({\n                remoteDomain: localDomain,\n                sender: msg.sender,\n                recipient: address(uint160(uint256(recipient))),\n                destinationCaller: destinationCaller,\n                messageBody: messageBody\n            })\n        );\n    }\n\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success) {\n        // This is added to test if SynapseCCTP could handle MessageTransmitter returning false.\n        if (signature.length == 1) return false;\n        require(signature.length % 65 == 0, \"Invalid attestation length\");\n        (\n            uint32 remoteDomain,\n            bytes32 sender,\n            address recipient,\n            bytes32 destinationCaller,\n            bytes memory messageBody\n        ) = abi.decode(message, (uint32, bytes32, address, bytes32, bytes));\n        if (destinationCaller != 0) {\n            require(destinationCaller == bytes32(uint256(uint160(msg.sender))), \"Invalid caller for message\");\n        }\n        require(\n            ITokenMessenger(recipient).handleReceiveMessage(remoteDomain, sender, messageBody),\n            \"handleReceiveMessage() failed\"\n        );\n        emit SignatureReceived(signature);\n        return true;\n    }\n\n    function formatMessage(\n        uint32 remoteDomain,\n        address sender,\n        address recipient,\n        bytes32 destinationCaller,\n        bytes memory messageBody\n    ) public pure returns (bytes memory message) {\n        message = abi.encode(remoteDomain, sender, recipient, destinationCaller, messageBody);\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"6062:2262:0:-:0;;;6284:108;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;6327:11;:26;;-1:-1:-1;;;;;;6363:22:0;6327:26;;;;6363:22;;;;;;;;6062:2262;;14:280:1;83:6;136:2;124:9;115:7;111:23;107:32;104:52;;;152:1;149;142:12;104:52;184:9;178:16;234:10;227:5;223:22;216:5;213:33;203:61;;260:1;257;250:12;203:61;283:5;14:280;-1:-1:-1;;;14:280:1:o;:::-;6062:2262:0;;;;;;","srcMapRuntime":"6062:2262:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;7013:980;;;;;;:::i;:::-;;:::i;:::-;;;1253:14:1;;1246:22;1228:41;;1216:2;1201:18;7013:980:0;;;;;;;;6189:41;;;;;;;;;;;;;;;1454:18:1;1442:31;;;1424:50;;1412:2;1397:18;6189:41:0;1280:200:1;6149:34:0;;;;;;;;;;;;1659:10:1;1647:23;;;1629:42;;1617:2;1602:18;6149:34:0;1485:192:1;7999:323:0;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;6398:609::-;;;;;;:::i;:::-;;:::i;7013:980::-;7105:12;7250:1;7230:21;;;7226:39;;-1:-1:-1;7260:5:0;7253:12;;7226:39;7283:21;7302:2;7283:9;:21;:::i;:::-;:26;7275:65;;;;;;;5527:2:1;7275:65:0;;;5509:21:1;5566:2;5546:18;;;5539:30;5605:28;5585:18;;;5578:56;5651:18;;7275:65:0;;;;;;;;;7364:19;;;;;7532:63;;;;7543:7;7532:63;:::i;:::-;7350:245;;-1:-1:-1;7350:245:0;;-1:-1:-1;7350:245:0;-1:-1:-1;7350:245:0;-1:-1:-1;7350:245:0;-1:-1:-1;7609:22:0;;7605:150;;7700:10;7655:58;;7647:97;;;;;;;6560:2:1;7647:97:0;;;6542:21:1;6599:2;6579:18;;;6572:30;6638:28;6618:18;;;6611:56;6684:18;;7647:97:0;6358:350:1;7647:97:0;7785:82;;;;;:47;;;;;;:82;;7833:12;;7847:6;;7855:11;;7785:82;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;7764:158;;;;;;;7576:2:1;7764:158:0;;;7558:21:1;7615:2;7595:18;;;7588:30;7654:31;7634:18;;;7627:59;7703:18;;7764:158:0;7374:353:1;7764:158:0;7937:28;7955:9;;7937:28;;;;;;;:::i;:::-;;;;;;;;7982:4;7975:11;;;;;;;7013:980;;;;;;;:::o;7999:323::-;8198:20;8251:12;8265:6;8273:9;8284:17;8303:11;8240:75;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;8230:85;;7999:323;;;;;;;:::o;6398:609::-;6567:20;6615:18;;;;;;6664:17;6615:18;6680:1;6664:17;:::i;:::-;6643:18;;:38;;;;;;;;;;;;;;;;;;6696:304;6721:269;6767:11;;;;;;;;;;6804:10;6867:9;6859:18;;6916:17;6964:11;;6721:269;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;6721:13:0;;-1:-1:-1;;;6721:269:0:i;:::-;6696:304;;;;;;:::i;:::-;;;;;;;;6398:609;;;;;;;:::o;14:347:1:-;65:8;75:6;129:3;122:4;114:6;110:17;106:27;96:55;;147:1;144;137:12;96:55;-1:-1:-1;170:20:1;;213:18;202:30;;199:50;;;245:1;242;235:12;199:50;282:4;274:6;270:17;258:29;;334:3;327:4;318:6;310;306:19;302:30;299:39;296:59;;;351:1;348;341:12;296:59;14:347;;;;;:::o;366:717::-;456:6;464;472;480;533:2;521:9;512:7;508:23;504:32;501:52;;;549:1;546;539:12;501:52;589:9;576:23;618:18;659:2;651:6;648:14;645:34;;;675:1;672;665:12;645:34;714:58;764:7;755:6;744:9;740:22;714:58;:::i;:::-;791:8;;-1:-1:-1;688:84:1;-1:-1:-1;879:2:1;864:18;;851:32;;-1:-1:-1;895:16:1;;;892:36;;;924:1;921;914:12;892:36;;963:60;1015:7;1004:8;993:9;989:24;963:60;:::i;:::-;366:717;;;;-1:-1:-1;1042:8:1;-1:-1:-1;;;;366:717:1:o;1682:163::-;1749:20;;1809:10;1798:22;;1788:33;;1778:61;;1835:1;1832;1825:12;1778:61;1682:163;;;:::o;1850:154::-;1936:42;1929:5;1925:54;1918:5;1915:65;1905:93;;1994:1;1991;1984:12;1905:93;1850:154;:::o;2009:184::-;2061:77;2058:1;2051:88;2158:4;2155:1;2148:15;2182:4;2179:1;2172:15;2198:777;2240:5;2293:3;2286:4;2278:6;2274:17;2270:27;2260:55;;2311:1;2308;2301:12;2260:55;2347:6;2334:20;2373:18;2410:2;2406;2403:10;2400:36;;;2416:18;;:::i;:::-;2550:2;2544:9;2612:4;2604:13;;2455:66;2600:22;;;2624:2;2596:31;2592:40;2580:53;;;2648:18;;;2668:22;;;2645:46;2642:72;;;2694:18;;:::i;:::-;2734:10;2730:2;2723:22;2769:2;2761:6;2754:18;2815:3;2808:4;2803:2;2795:6;2791:15;2787:26;2784:35;2781:55;;;2832:1;2829;2822:12;2781:55;2896:2;2889:4;2881:6;2877:17;2870:4;2862:6;2858:17;2845:54;2943:1;2936:4;2931:2;2923:6;2919:15;2915:26;2908:37;2963:6;2954:15;;;;;;2198:777;;;;:::o;2980:738::-;3083:6;3091;3099;3107;3115;3168:3;3156:9;3147:7;3143:23;3139:33;3136:53;;;3185:1;3182;3175:12;3136:53;3208:28;3226:9;3208:28;:::i;:::-;3198:38;;3286:2;3275:9;3271:18;3258:32;3299:31;3324:5;3299:31;:::i;:::-;3349:5;-1:-1:-1;3406:2:1;3391:18;;3378:32;3419:33;3378:32;3419:33;:::i;:::-;3471:7;-1:-1:-1;3525:2:1;3510:18;;3497:32;;-1:-1:-1;3580:3:1;3565:19;;3552:33;3608:18;3597:30;;3594:50;;;3640:1;3637;3630:12;3594:50;3663:49;3704:7;3695:6;3684:9;3680:22;3663:49;:::i;:::-;3653:59;;;2980:738;;;;;;;;:::o;3723:481::-;3764:3;3802:5;3796:12;3829:6;3824:3;3817:19;3854:1;3864:162;3878:6;3875:1;3872:13;3864:162;;;3940:4;3996:13;;;3992:22;;3986:29;3968:11;;;3964:20;;3957:59;3893:12;3864:162;;;3868:3;4071:1;4064:4;4055:6;4050:3;4046:16;4042:27;4035:38;4193:4;4123:66;4118:2;4110:6;4106:15;4102:88;4097:3;4093:98;4089:109;4082:116;;;3723:481;;;;:::o;4209:217::-;4356:2;4345:9;4338:21;4319:4;4376:44;4416:2;4405:9;4401:18;4393:6;4376:44;:::i;:::-;4368:52;4209:217;-1:-1:-1;;;4209:217:1:o;4431:618::-;4527:6;4535;4543;4551;4559;4612:3;4600:9;4591:7;4587:23;4583:33;4580:53;;;4629:1;4626;4619:12;4580:53;4652:28;4670:9;4652:28;:::i;:::-;4642:38;;4727:2;4716:9;4712:18;4699:32;4689:42;;4778:2;4767:9;4763:18;4750:32;4740:42;;4833:2;4822:9;4818:18;4805:32;4860:18;4852:6;4849:30;4846:50;;;4892:1;4889;4882:12;4846:50;4931:58;4981:7;4972:6;4961:9;4957:22;4931:58;:::i;:::-;4431:618;;;;-1:-1:-1;4431:618:1;;-1:-1:-1;5008:8:1;;4905:84;4431:618;-1:-1:-1;;;4431:618:1:o;5054:266::-;5086:1;5112;5102:189;;5147:77;5144:1;5137:88;5248:4;5245:1;5238:15;5276:4;5273:1;5266:15;5102:189;-1:-1:-1;5305:9:1;;5054:266::o;5680:673::-;5791:6;5799;5807;5815;5823;5876:3;5864:9;5855:7;5851:23;5847:33;5844:53;;;5893:1;5890;5883:12;5844:53;5916:28;5934:9;5916:28;:::i;:::-;5906:38;;5991:2;5980:9;5976:18;5963:32;5953:42;;6045:2;6034:9;6030:18;6017:32;6058:31;6083:5;6058:31;:::i;6713:374::-;6926:10;6918:6;6914:23;6903:9;6896:42;6974:6;6969:2;6958:9;6954:18;6947:34;7017:2;7012;7001:9;6997:18;6990:30;6877:4;7037:44;7077:2;7066:9;7062:18;7054:6;7037:44;:::i;:::-;7029:52;6713:374;-1:-1:-1;;;;;6713:374:1:o;7092:277::-;7159:6;7212:2;7200:9;7191:7;7187:23;7183:32;7180:52;;;7228:1;7225;7218:12;7180:52;7260:9;7254:16;7313:5;7306:13;7299:21;7292:5;7289:32;7279:60;;7335:1;7332;7325:12;7732:447;7889:2;7878:9;7871:21;7928:6;7923:2;7912:9;7908:18;7901:34;7985:6;7977;7972:2;7961:9;7957:18;7944:48;8041:1;8012:22;;;8036:2;8008:31;;;8001:42;;;;8095:2;8083:15;;;8100:66;8079:88;8064:104;8060:113;;7732:447;-1:-1:-1;7732:447:1:o;8184:598::-;8453:10;8445:6;8441:23;8430:9;8423:42;8404:4;8484:42;8574:2;8566:6;8562:15;8557:2;8546:9;8542:18;8535:43;8626:2;8618:6;8614:15;8609:2;8598:9;8594:18;8587:43;;8666:6;8661:2;8650:9;8646:18;8639:34;8710:3;8704;8693:9;8689:19;8682:32;8731:45;8771:3;8760:9;8756:19;8748:6;8731:45;:::i;:::-;8723:53;8184:598;-1:-1:-1;;;;;;;8184:598:1:o;8787:334::-;8854:18;8892:10;;;8904;;;8888:27;;8927:11;;;8924:191;;;8971:77;8968:1;8961:88;9072:4;9069:1;9062:15;9100:4;9097:1;9090:15;8924:191;;8787:334;;;;:::o","abiDefinition":[{"inputs":[{"internalType":"uint32","name":"localDomain_","type":"uint32"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"caller","type":"address"},{"indexed":false,"internalType":"uint32","name":"sourceDomain","type":"uint32"},{"indexed":true,"internalType":"uint64","name":"nonce","type":"uint64"},{"indexed":false,"internalType":"bytes32","name":"sender","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"MessageReceived","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes","name":"message","type":"bytes"}],"name":"MessageSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"bytes","name":"signature","type":"bytes"}],"name":"SignatureReceived","type":"event"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"address","name":"sender","type":"address"},{"internalType":"address","name":"recipient","type":"address"},{"internalType":"bytes32","name":"destinationCaller","type":"bytes32"},{"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"message","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"localDomain","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextAvailableNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"receiveMessage","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"","type":"uint32"},{"internalType":"bytes32","name":"recipient","type":"bytes32"},{"internalType":"bytes32","name":"destinationCaller","type":"bytes32"},{"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"sendMessageWithCaller","outputs":[{"internalType":"uint64","name":"reservedNonce","type":"uint64"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"events":{"MessageReceived(address,uint32,uint64,bytes32,bytes)":{"notice":"Emitted when a new message is received"},"MessageSent(bytes)":{"notice":"Emitted when a new message is dispatched"}},"kind":"user","methods":{"receiveMessage(bytes,bytes)":{"notice":"Receives an incoming message, validating the header and passing the body to application-specific handler."}},"notice":"Very simplified version of CCTP's MessageTransmitter for testing purposes.","version":1},"developerDoc":{"kind":"dev","methods":{"receiveMessage(bytes,bytes)":{"params":{"message":"The message raw bytes","signature":"The message signature"},"returns":{"success":"bool, true if successful"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"localDomain_\",\"type\":\"uint32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"caller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"sourceDomain\",\"type\":\"uint32\"},{\"indexed\":true,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"messageBody\",\"type\":\"bytes\"}],\"name\":\"MessageReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"MessageSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"SignatureReceived\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"sender\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCaller\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageBody\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextAvailableNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCaller\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageBody\",\"type\":\"bytes\"}],\"name\":\"sendMessageWithCaller\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"reservedNonce\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveMessage(bytes,bytes)\":{\"params\":{\"message\":\"The message raw bytes\",\"signature\":\"The message signature\"},\"returns\":{\"success\":\"bool, true if successful\"}}},\"version\":1},\"userdoc\":{\"events\":{\"MessageReceived(address,uint32,uint64,bytes32,bytes)\":{\"notice\":\"Emitted when a new message is received\"},\"MessageSent(bytes)\":{\"notice\":\"Emitted when a new message is dispatched\"}},\"kind\":\"user\",\"methods\":{\"receiveMessage(bytes,bytes)\":{\"notice\":\"Receives an incoming message, validating the header and passing the body to application-specific handler.\"}},\"notice\":\"Very simplified version of CCTP's MessageTransmitter for testing purposes.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MockMessageTransmitter.sol\":\"MockMessageTransmitter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MockMessageTransmitter.sol\":{\"keccak256\":\"0x85d7708f952fd505cccca33bbc9c910d511461d01f96969a6b8e7656ee8677c8\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://72bfa66545d9ddde1dc34863555a44aaf30d9661ecec7afbf3cc62e1d8d412de\",\"dweb:/ipfs/QmTpVWa2FbRk1sbKMq9CYFNphQ377WpFCvWJEeHce6FyB1\"]}},\"version\":1}"},"hashes":{"formatMessage(uint32,address,address,bytes32,bytes)":"d81bbe02","localDomain()":"8d3638f4","nextAvailableNonce()":"8371744e","receiveMessage(bytes,bytes)":"57ecfd28","sendMessageWithCaller(uint32,bytes32,bytes32,bytes)":"f7259a75"}}}