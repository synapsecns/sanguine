{"solidity/SynapseCCTP.sol:Address":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f513e71c895a2e88002ba865fcd08bdc1683d190179a3dbdf578f0704ebe302d64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220f513e71c895a2e88002ba865fcd08bdc1683d190179a3dbdf578f0704ebe302d64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"53415:8061:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;53415:8061:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"53415:8061:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Collection of functions related to the address type","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Collection of functions related to the address type\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"Address\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"Context\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:EnumerableSet":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122093b9221c2da55e21f79ebfeb2182f61d5dac75991538e0a599332cfb950c96a364736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122093b9221c2da55e21f79ebfeb2182f61d5dac75991538e0a599332cfb950c96a364736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"9155:11368:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;9155:11368:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"9155:11368:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Library for managing https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive types. Sets have the following properties: - Elements are added, removed, and checked for existence in constant time (O(1)). - Elements are enumerated in O(n). No guarantees are made on the ordering. ``` contract Example {     // Add the library methods     using EnumerableSet for EnumerableSet.AddressSet;     // Declare a set state variable     EnumerableSet.AddressSet private mySet; } ``` As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`) and `uint256` (`UintSet`) are supported.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"EnumerableSet\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:IDefaultPool":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint8","name":"tokenIndexFrom","type":"uint8"},{"internalType":"uint8","name":"tokenIndexTo","type":"uint8"},{"internalType":"uint256","name":"dx","type":"uint256"}],"name":"calculateSwap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"index","type":"uint8"}],"name":"getToken","outputs":[{"internalType":"address","name":"token","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint8","name":"tokenIndexFrom","type":"uint8"},{"internalType":"uint8","name":"tokenIndexTo","type":"uint8"},{"internalType":"uint256","name":"dx","type":"uint256"},{"internalType":"uint256","name":"minDy","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"}],"name":"swap","outputs":[{"internalType":"uint256","name":"amountOut","type":"uint256"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"}],\"name\":\"calculateSwap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"getToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint8\",\"name\":\"tokenIndexFrom\",\"type\":\"uint8\"},{\"internalType\":\"uint8\",\"name\":\"tokenIndexTo\",\"type\":\"uint8\"},{\"internalType\":\"uint256\",\"name\":\"dx\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minDy\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"}],\"name\":\"swap\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"IDefaultPool\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{"calculateSwap(uint8,uint8,uint256)":"a95b089f","getToken(uint8)":"82b86600","swap(uint8,uint8,uint256,uint256,uint256)":"91695586"}},"solidity/SynapseCCTP.sol:IERC20":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Interface of the ERC20 standard as defined in the EIP.","events":{"Approval(address,address,uint256)":{"details":"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{"details":"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},"kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{"details":"Returns the amount of tokens owned by `account`."},"totalSupply()":{"details":"Returns the amount of tokens in existence."},"transfer(address,uint256)":{"details":"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{"details":"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC20 standard as defined in the EIP.\",\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"}},\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the amount of tokens owned by `account`.\"},\"totalSupply()\":{\"details\":\"Returns the amount of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"IERC20\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{"allowance(address,address)":"dd62ed3e","approve(address,uint256)":"095ea7b3","balanceOf(address)":"70a08231","totalSupply()":"18160ddd","transfer(address,uint256)":"a9059cbb","transferFrom(address,address,uint256)":"23b872dd"}},"solidity/SynapseCCTP.sol:IMessageTransmitter":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"localDomain","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"nextAvailableNonce","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"}],"name":"receiveMessage","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"recipient","type":"bytes32"},{"internalType":"bytes32","name":"destinationCaller","type":"bytes32"},{"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"sendMessageWithCaller","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"receiveMessage(bytes,bytes)":{"notice":"Receives an incoming message, validating the header and passing the body to application-specific handler."},"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)":{"notice":"Sends an outgoing message from the source domain, with a specified caller on the destination domain."}},"version":1},"developerDoc":{"kind":"dev","methods":{"receiveMessage(bytes,bytes)":{"params":{"message":"The message raw bytes","signature":"The message signature"},"returns":{"success":"bool, true if successful"}},"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)":{"details":"Increment nonce, format the message, and emit `MessageSent` event with message information. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard sendMessage() should be preferred for use cases where a specific destination caller is not required.","params":{"destinationCaller":"caller on the destination domain, as bytes32","destinationDomain":"Domain of destination chain","messageBody":"Raw bytes content of message","recipient":"Address of message recipient on destination domain as bytes32"},"returns":{"_0":"nonce reserved by message"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"localDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"nextAvailableNonce\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"receiveMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"recipient\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCaller\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageBody\",\"type\":\"bytes\"}],\"name\":\"sendMessageWithCaller\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveMessage(bytes,bytes)\":{\"params\":{\"message\":\"The message raw bytes\",\"signature\":\"The message signature\"},\"returns\":{\"success\":\"bool, true if successful\"}},\"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)\":{\"details\":\"Increment nonce, format the message, and emit `MessageSent` event with message information. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard sendMessage() should be preferred for use cases where a specific destination caller is not required.\",\"params\":{\"destinationCaller\":\"caller on the destination domain, as bytes32\",\"destinationDomain\":\"Domain of destination chain\",\"messageBody\":\"Raw bytes content of message\",\"recipient\":\"Address of message recipient on destination domain as bytes32\"},\"returns\":{\"_0\":\"nonce reserved by message\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"receiveMessage(bytes,bytes)\":{\"notice\":\"Receives an incoming message, validating the header and passing the body to application-specific handler.\"},\"sendMessageWithCaller(uint32,bytes32,bytes32,bytes)\":{\"notice\":\"Sends an outgoing message from the source domain, with a specified caller on the destination domain.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"IMessageTransmitter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{"localDomain()":"8d3638f4","nextAvailableNonce()":"8371744e","receiveMessage(bytes,bytes)":"57ecfd28","sendMessageWithCaller(uint32,bytes32,bytes32,bytes)":"f7259a75"}},"solidity/SynapseCCTP.sol:ISynapseCCTP":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint32","name":"requestVersion","type":"uint32"},{"internalType":"bytes","name":"formattedRequest","type":"bytes"}],"name":"receiveCircleToken","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint32","name":"requestVersion","type":"uint32"},{"internalType":"bytes","name":"swapParams","type":"bytes"}],"name":"sendCircleToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"receiveCircleToken(bytes,bytes,uint32,bytes)":{"notice":"Receive  Circle token supported by CCTP with the request for the action to take."},"sendCircleToken(address,uint256,address,uint256,uint32,bytes)":{"notice":"Send a Circle token supported by CCTP to a given chain with the request for the action to take on the destination chain."}},"version":1},"developerDoc":{"kind":"dev","methods":{"receiveCircleToken(bytes,bytes,uint32,bytes)":{"details":"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on this chain.The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function, or the call will revert.","params":{"formattedRequest":"Formatted request for the action to take on this chain","message":"Message raw bytes emitted by CCTP MessageTransmitter on origin chain","requestVersion":"Version of the request format","signature":"Circle's attestation for the message obtained from Circle's API"}},"sendCircleToken(address,uint256,address,uint256,uint32,bytes)":{"details":"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on the destination chain. `chainId` refers to value from EIP-155 (block.chainid).","params":{"amount":"Amount of tokens to burn","burnToken":"Address of Circle token to burn","chainId":"Chain ID of the destination chain","recipient":"Recipient of the tokens on destination chain","requestVersion":"Version of the request format","swapParams":"Swap parameters for the action to take on the destination chain (could be empty)"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"formattedRequest\",\"type\":\"bytes\"}],\"name\":\"receiveCircleToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"swapParams\",\"type\":\"bytes\"}],\"name\":\"sendCircleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveCircleToken(bytes,bytes,uint32,bytes)\":{\"details\":\"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on this chain.The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function, or the call will revert.\",\"params\":{\"formattedRequest\":\"Formatted request for the action to take on this chain\",\"message\":\"Message raw bytes emitted by CCTP MessageTransmitter on origin chain\",\"requestVersion\":\"Version of the request format\",\"signature\":\"Circle's attestation for the message obtained from Circle's API\"}},\"sendCircleToken(address,uint256,address,uint256,uint32,bytes)\":{\"details\":\"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on the destination chain. `chainId` refers to value from EIP-155 (block.chainid).\",\"params\":{\"amount\":\"Amount of tokens to burn\",\"burnToken\":\"Address of Circle token to burn\",\"chainId\":\"Chain ID of the destination chain\",\"recipient\":\"Recipient of the tokens on destination chain\",\"requestVersion\":\"Version of the request format\",\"swapParams\":\"Swap parameters for the action to take on the destination chain (could be empty)\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"receiveCircleToken(bytes,bytes,uint32,bytes)\":{\"notice\":\"Receive  Circle token supported by CCTP with the request for the action to take.\"},\"sendCircleToken(address,uint256,address,uint256,uint32,bytes)\":{\"notice\":\"Send a Circle token supported by CCTP to a given chain with the request for the action to take on the destination chain.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"ISynapseCCTP\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{"receiveCircleToken(bytes,bytes,uint32,bytes)":"4a5ae51d","sendCircleToken(address,uint256,address,uint256,uint32,bytes)":"304ddb4c"}},"solidity/SynapseCCTP.sol:ITokenMessenger":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint32","name":"destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"mintRecipient","type":"bytes32"},{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"bytes32","name":"destinationCaller","type":"bytes32"}],"name":"depositForBurnWithCaller","outputs":[{"internalType":"uint64","name":"nonce","type":"uint64"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"bytes32","name":"sender","type":"bytes32"},{"internalType":"bytes","name":"messageBody","type":"bytes"}],"name":"handleReceiveMessage","outputs":[{"internalType":"bool","name":"success","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"localMessageTransmitter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"localMinter","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)":{"notice":"Deposits and burns tokens from sender to be minted on destination domain. The mint on the destination domain must be called by `destinationCaller`. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard depositForBurn() should be preferred for use cases where a specific destination caller is not required. Emits a `DepositForBurn` event."},"handleReceiveMessage(uint32,bytes32,bytes)":{"notice":"Handles an incoming message received by the local MessageTransmitter, and takes the appropriate action. For a burn message, mints the associated token to the requested recipient on the local domain."}},"version":1},"developerDoc":{"kind":"dev","methods":{"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)":{"details":"reverts if: - given destinationCaller is zero address - given burnToken is not supported - given destinationDomain has no TokenMessenger registered - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance to this contract is less than `amount`. - burn() reverts. For example, if `amount` is 0. - MessageTransmitter returns false or reverts.","params":{"amount":"amount of tokens to burn","burnToken":"address of contract to burn deposited tokens, on local domain","destinationCaller":"caller on the destination domain, as bytes32","destinationDomain":"destination domain","mintRecipient":"address of mint recipient on destination domain"},"returns":{"nonce":"unique nonce reserved by message"}},"handleReceiveMessage(uint32,bytes32,bytes)":{"details":"Validates the local sender is the local MessageTransmitter, and the remote sender is a registered remote TokenMessenger for `remoteDomain`.","params":{"messageBody":"The message body bytes.","remoteDomain":"The domain where the message originated from.","sender":"The sender of the message (remote TokenMessenger)."},"returns":{"success":"Bool, true if successful."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"mintRecipient\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"bytes32\",\"name\":\"destinationCaller\",\"type\":\"bytes32\"}],\"name\":\"depositForBurnWithCaller\",\"outputs\":[{\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"messageBody\",\"type\":\"bytes\"}],\"name\":\"handleReceiveMessage\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"success\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localMessageTransmitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localMinter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)\":{\"details\":\"reverts if: - given destinationCaller is zero address - given burnToken is not supported - given destinationDomain has no TokenMessenger registered - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance to this contract is less than `amount`. - burn() reverts. For example, if `amount` is 0. - MessageTransmitter returns false or reverts.\",\"params\":{\"amount\":\"amount of tokens to burn\",\"burnToken\":\"address of contract to burn deposited tokens, on local domain\",\"destinationCaller\":\"caller on the destination domain, as bytes32\",\"destinationDomain\":\"destination domain\",\"mintRecipient\":\"address of mint recipient on destination domain\"},\"returns\":{\"nonce\":\"unique nonce reserved by message\"}},\"handleReceiveMessage(uint32,bytes32,bytes)\":{\"details\":\"Validates the local sender is the local MessageTransmitter, and the remote sender is a registered remote TokenMessenger for `remoteDomain`.\",\"params\":{\"messageBody\":\"The message body bytes.\",\"remoteDomain\":\"The domain where the message originated from.\",\"sender\":\"The sender of the message (remote TokenMessenger).\"},\"returns\":{\"success\":\"Bool, true if successful.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)\":{\"notice\":\"Deposits and burns tokens from sender to be minted on destination domain. The mint on the destination domain must be called by `destinationCaller`. WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible to broadcast the message on the destination domain. This is an advanced feature, and the standard depositForBurn() should be preferred for use cases where a specific destination caller is not required. Emits a `DepositForBurn` event.\"},\"handleReceiveMessage(uint32,bytes32,bytes)\":{\"notice\":\"Handles an incoming message received by the local MessageTransmitter, and takes the appropriate action. For a burn message, mints the associated token to the requested recipient on the local domain.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"ITokenMessenger\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{"depositForBurnWithCaller(uint256,uint32,bytes32,address,bytes32)":"f856ddb6","handleReceiveMessage(uint32,bytes32,bytes)":"96abeb70","localMessageTransmitter()":"2c121921","localMinter()":"cb75c11c"}},"solidity/SynapseCCTP.sol:ITokenMinter":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"bytes32","name":"remoteToken","type":"bytes32"}],"name":"getLocalToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"sourceDomain","type":"uint32"},{"internalType":"bytes32","name":"burnToken","type":"bytes32"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"address","name":"mintToken","type":"address"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"burn(address,uint256)":{"notice":"Burn tokens owned by this ITokenMinter."},"getLocalToken(uint32,bytes32)":{"notice":"Get the local token associated with the given remote domain and token."},"mint(uint32,bytes32,address,uint256)":{"notice":"Mints `amount` of local tokens corresponding to the given (`sourceDomain`, `burnToken`) pair, to `to` address."}},"version":1},"developerDoc":{"kind":"dev","methods":{"burn(address,uint256)":{"params":{"amount":"amount of tokens to burn. Must be less than or equal to this ITokenMinter's account balance of the given `_burnToken`.","burnToken":"burnable token."}},"getLocalToken(uint32,bytes32)":{"params":{"remoteDomain":"Remote domain","remoteToken":"Remote token"},"returns":{"_0":"local token address"}},"mint(uint32,bytes32,address,uint256)":{"details":"reverts if the (`sourceDomain`, `burnToken`) pair does not map to a nonzero local token address. This mapping can be queried using getLocalToken().","params":{"amount":"Amount of tokens to mint. Must be less than or equal to the minterAllowance of this TokenMinter for given `_mintToken`.","burnToken":"Burned token address as bytes32.","sourceDomain":"Source domain where `burnToken` was burned.","to":"Address to receive minted tokens, corresponding to `burnToken`, on this domain."},"returns":{"mintToken":"token minted."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"remoteToken\",\"type\":\"bytes32\"}],\"name\":\"getLocalToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"sourceDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"burnToken\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"mintToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"burn(address,uint256)\":{\"params\":{\"amount\":\"amount of tokens to burn. Must be less than or equal to this ITokenMinter's account balance of the given `_burnToken`.\",\"burnToken\":\"burnable token.\"}},\"getLocalToken(uint32,bytes32)\":{\"params\":{\"remoteDomain\":\"Remote domain\",\"remoteToken\":\"Remote token\"},\"returns\":{\"_0\":\"local token address\"}},\"mint(uint32,bytes32,address,uint256)\":{\"details\":\"reverts if the (`sourceDomain`, `burnToken`) pair does not map to a nonzero local token address. This mapping can be queried using getLocalToken().\",\"params\":{\"amount\":\"Amount of tokens to mint. Must be less than or equal to the minterAllowance of this TokenMinter for given `_mintToken`.\",\"burnToken\":\"Burned token address as bytes32.\",\"sourceDomain\":\"Source domain where `burnToken` was burned.\",\"to\":\"Address to receive minted tokens, corresponding to `burnToken`, on this domain.\"},\"returns\":{\"mintToken\":\"token minted.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"burn(address,uint256)\":{\"notice\":\"Burn tokens owned by this ITokenMinter.\"},\"getLocalToken(uint32,bytes32)\":{\"notice\":\"Get the local token associated with the given remote domain and token.\"},\"mint(uint32,bytes32,address,uint256)\":{\"notice\":\"Mints `amount` of local tokens corresponding to the given (`sourceDomain`, `burnToken`) pair, to `to` address.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"ITokenMinter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{"burn(address,uint256)":"9dc29fac","getLocalToken(uint32,bytes32)":"78a0565e","mint(uint32,bytes32,address,uint256)":"d54de06f"}},"solidity/SynapseCCTP.sol:MinimalForwarderLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208a7557a298d61bb6606e084d3bc413296bda71d21d4f335273138bc6ae1b133464736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208a7557a298d61bb6606e084d3bc413296bda71d21d4f335273138bc6ae1b133464736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"71765:4120:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;71765:4120:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"71765:4120:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that forwards all calls to a any target address with any payload. Unlike EIP-1167, delegates calls are not used, so the forwarder contract is `msg.sender` as far as the target contract is concerned. # Minimal Forwarder Bytecode Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167). Following changes were made: - Target address is not saved in the deployed contract code, but is passed as a part of the payload. - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload. - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes. - The target address is derived using CALLDATALOAD. - CALLVALUE is used to pass the msg.value to the target contract. - `call()` is used instead of `delegatecall()`. ## Bytecode Table | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     | | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ | | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     | | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     | | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 | | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 | | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 | | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 | | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 | | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 | | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 | | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 | | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      | | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      | | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      | | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      | | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      | | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      | | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      | | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      | | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      | | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      | | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      | | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    | | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    | | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    | | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    | | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    | | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        | | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    | | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        | \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any). \u003e - Stack View (S7..S0) is shown after the execution of the opcode. \u003e - The stack elements are shown from top to bottom. \u003e Opcodes are typically dealing with the top stack elements, so they are shown first. \u003e - `cds` refers to the calldata size. \u003e - `rds` refers to the returndata size (which is zero before the first external call). \u003e - `val` refers to the provided `msg.value`. \u003e - `addr` refers to the target address loaded from calldata. \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left. \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success. ## Bytecode Explanation - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address). \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack. - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\". \u003e - `dup1` duplicates the top stack item. - `0x05..0x08` - Copy the target call payload to memory. \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements: \u003e memory offset to write to, calldata offset to read from, and length of the data to copy. - `0x09..0x11` - Prepare the stack for the `call` opcode. \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero \u003e after we perform the first external call. \u003e - `swap3` swaps the top stack item with the fourth stack item. \u003e - `callvalue` pushes `msg.value` onto the stack. \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack. \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address. \u003e - `gas` pushes the remaining gas onto the stack. - `0x12..0x12` - Call the target contract. \u003e - `call` issues an external call to a target address. \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length, \u003e memory offset to write return data to, and length of return data to write to memory. \u003e - Pushes on stack: 0 on failure, 1 on success. - `0x13..0x16` - Copy the return data to memory. \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack. \u003e - `dup3` duplicates the third stack item. \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements: \u003e memory offset to write to, return data offset to read from, and length of the data to copy. - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size. \u003e - `swap1` swaps the top stack item with the second stack item. \u003e - `swap2` swaps the top stack item with the third stack item. \u003e - `0x1e` refers to the position of the `jumpdest` opcode. \u003e  It is used to jump to the `return` opcode, if call was successful. - `0x1c..0x1c` - Jump to 0x1e position, if call was successful. \u003e - `jumpi` pops two top stack items: jump destination and jump condition. \u003e If jump condition is nonzero, jumps to the jump destination. - `0x1d..0x1d` - Revert if call was unsuccessful. \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message. \u003e - This allows us to bubble the revert message from the external call. - `0x1e..0x1e` - Jump destination for successful call. \u003e - `jumpdest` is a no-op that marks a valid jump destination. - `0x1f..0x1f` - Return if call was successful. \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data. \u003e - This allows us to reuse the return data from the external call. # Minimal Forwarder Init Code Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol). Following changes were made: - Adjusted bytecode length to 32 bytes. - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack. \u003e `bytecode` refers to the bytecode specified in the above table. ## Init Code Table | Pos  | OP   | OP + Args | Description     | S1  | S0       | | ---- | ---- | --------- | --------------- | --- | -------- | | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode | | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode | | 0x1c | 0x52 | 0x52      | mstore          |     |          | | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       | | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       | | 0x20 | 0xf3 | 0xf3      | return          |     |          | \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code. \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode. ## Init Code Explanation - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack. \u003e - `push32` pushes 32 bytes as a single stack item onto the stack. - `0x1b..0x1b` - Push 0 onto the stack. \u003e No external calls were made, so the return data size is 0. - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory. \u003e - `mstore` pops two top stack items: memory offset to write to and value to write. \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory. - `0x1d..0x1f` - Prepare stack for `return` opcode. \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory. - `0x20..0x20` - Return the Minimal Forwarder bytecode. \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data. \u003e - This allows us to return the Minimal Forwarder bytecode.","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that forwards all calls to a any target address with any payload. Unlike EIP-1167, delegates calls are not used, so the forwarder contract is `msg.sender` as far as the target contract is concerned. # Minimal Forwarder Bytecode Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167). Following changes were made: - Target address is not saved in the deployed contract code, but is passed as a part of the payload. - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload. - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes. - The target address is derived using CALLDATALOAD. - CALLVALUE is used to pass the msg.value to the target contract. - `call()` is used instead of `delegatecall()`. ## Bytecode Table | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     | | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ | | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     | | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     | | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 | | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 | | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 | | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 | | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 | | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 | | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 | | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 | | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      | | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      | | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      | | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      | | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      | | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      | | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      | | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      | | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      | | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      | | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      | | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    | | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    | | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    | | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    | | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    | | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        | | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    | | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        | \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any). \u003e - Stack View (S7..S0) is shown after the execution of the opcode. \u003e - The stack elements are shown from top to bottom. \u003e Opcodes are typically dealing with the top stack elements, so they are shown first. \u003e - `cds` refers to the calldata size. \u003e - `rds` refers to the returndata size (which is zero before the first external call). \u003e - `val` refers to the provided `msg.value`. \u003e - `addr` refers to the target address loaded from calldata. \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left. \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success. ## Bytecode Explanation - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address). \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack. - `0x04..0x04` - Duplicate the offset to use it later as \\\"payload length\\\". \u003e - `dup1` duplicates the top stack item. - `0x05..0x08` - Copy the target call payload to memory. \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements: \u003e memory offset to write to, calldata offset to read from, and length of the data to copy. - `0x09..0x11` - Prepare the stack for the `call` opcode. \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero \u003e after we perform the first external call. \u003e - `swap3` swaps the top stack item with the fourth stack item. \u003e - `callvalue` pushes `msg.value` onto the stack. \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack. \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address. \u003e - `gas` pushes the remaining gas onto the stack. - `0x12..0x12` - Call the target contract. \u003e - `call` issues an external call to a target address. \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length, \u003e memory offset to write return data to, and length of return data to write to memory. \u003e - Pushes on stack: 0 on failure, 1 on success. - `0x13..0x16` - Copy the return data to memory. \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack. \u003e - `dup3` duplicates the third stack item. \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements: \u003e memory offset to write to, return data offset to read from, and length of the data to copy. - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size. \u003e - `swap1` swaps the top stack item with the second stack item. \u003e - `swap2` swaps the top stack item with the third stack item. \u003e - `0x1e` refers to the position of the `jumpdest` opcode. \u003e  It is used to jump to the `return` opcode, if call was successful. - `0x1c..0x1c` - Jump to 0x1e position, if call was successful. \u003e - `jumpi` pops two top stack items: jump destination and jump condition. \u003e If jump condition is nonzero, jumps to the jump destination. - `0x1d..0x1d` - Revert if call was unsuccessful. \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message. \u003e - This allows us to bubble the revert message from the external call. - `0x1e..0x1e` - Jump destination for successful call. \u003e - `jumpdest` is a no-op that marks a valid jump destination. - `0x1f..0x1f` - Return if call was successful. \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data. \u003e - This allows us to reuse the return data from the external call. # Minimal Forwarder Init Code Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol). Following changes were made: - Adjusted bytecode length to 32 bytes. - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack. \u003e `bytecode` refers to the bytecode specified in the above table. ## Init Code Table | Pos  | OP   | OP + Args | Description     | S1  | S0       | | ---- | ---- | --------- | --------------- | --- | -------- | | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode | | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode | | 0x1c | 0x52 | 0x52      | mstore          |     |          | | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       | | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       | | 0x20 | 0xf3 | 0xf3      | return          |     |          | \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code. \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode. ## Init Code Explanation - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack. \u003e - `push32` pushes 32 bytes as a single stack item onto the stack. - `0x1b..0x1b` - Push 0 onto the stack. \u003e No external calls were made, so the return data size is 0. - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory. \u003e - `mstore` pops two top stack items: memory offset to write to and value to write. \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory. - `0x1d..0x1f` - Prepare stack for `return` opcode. \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory. - `0x20..0x20` - Return the Minimal Forwarder bytecode. \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data. \u003e - This allows us to return the Minimal Forwarder bytecode.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"MinimalForwarderLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:Ownable":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"Ownable\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{"owner()":"8da5cb5b","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}},"solidity/SynapseCCTP.sol:RequestLib":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201d1e2b1667b8adee951b7a9647847f78a24148eb7bbd9323c6e07fcc1af0250c64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212201d1e2b1667b8adee951b7a9647847f78a24148eb7bbd9323c6e07fcc1af0250c64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"45966:7310:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;45966:7310:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"45966:7310:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"notice":"# Base Request layout | Field           | Type    | Description                                    | | --------------- | ------- | ---------------------------------------------- | | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP | | nonce           | uint64  | Nonce of the CCTP message on origin chain      | | originBurnToken | address | Circle token that was burned on origin chain   | | amount          | uint256 | Amount of tokens burned on origin chain        | | recipient       | address | Recipient of the tokens on destination chain   | # Swap Params layout | Field          | Type    | Description                                                   | | -------------- | ------- | ------------------------------------------------------------- | | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  | | tokenIndexTo   | uint8   | Index of the final token in the pool                          | | deadline       | uint256 | Latest timestamp to execute the swap                          | | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"# Base Request layout | Field           | Type    | Description                                    | | --------------- | ------- | ---------------------------------------------- | | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP | | nonce           | uint64  | Nonce of the CCTP message on origin chain      | | originBurnToken | address | Circle token that was burned on origin chain   | | amount          | uint256 | Amount of tokens burned on origin chain        | | recipient       | address | Recipient of the tokens on destination chain   | # Swap Params layout | Field          | Type    | Description                                                   | | -------------- | ------- | ------------------------------------------------------------- | | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  | | tokenIndexTo   | uint8   | Index of the final token in the pool                          | | deadline       | uint256 | Latest timestamp to execute the swap                          | | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"RequestLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:SafeERC20":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122016b5a44a555ecbab80eea29ba347354ef2cb8b4af5219a8369fa0dceafc2e64364736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122016b5a44a555ecbab80eea29ba347354ef2cb8b4af5219a8369fa0dceafc2e64364736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"79124:3270:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;79124:3270:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"79124:3270:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, which allows you to call the safe operations as `token.safeTransfer(...)`, etc.","kind":"dev","methods":{},"title":"SafeERC20","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\",\"kind\":\"dev\",\"methods\":{},\"title\":\"SafeERC20\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"SafeERC20\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:SynapseCCTP":{"code":"0x60e06040523480156200001157600080fd5b506040516200459338038062004593833981016040819052620000349162000199565b6200003f3362000130565b6001600160a01b03811660c081905260408051632c12192160e01b81529051632c121921916004808201926020929091908290030181865afa1580156200008a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620000b0919062000199565b6001600160a01b031660a08190526040805163234d8e3d60e21b81529051638d3638f4916004808201926020929091908290030181865afa158015620000fa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190620001209190620001c0565b63ffffffff1660805250620001e8565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6001600160a01b03811681146200019657600080fd5b50565b600060208284031215620001ac57600080fd5b8151620001b98162000180565b9392505050565b600060208284031215620001d357600080fd5b815163ffffffff81168114620001b957600080fd5b60805160a05160c051614343620002506000396000818161032301528181610c8001528181610caf015261233b0152600081816103ff01528181610ad101526122bb01526000818161043301528181610b5c01528181610f2401526118c001526143436000f3fe6080604052600436106101e35760003560e01c80638da5cb5b11610102578063d4a67c6d11610095578063e9bbb36d11610064578063e9bbb36d14610716578063f2fde38b14610736578063f7265b3a14610756578063f879a41a1461077657600080fd5b8063d4a67c6d146105a7578063dc72495b146105df578063e00a83e014610696578063e9259ab9146106ac57600080fd5b8063a4b1d034116100d1578063a4b1d034146104fa578063a5bc29c214610530578063b0e21e8a14610571578063b250fe6b1461058757600080fd5b80638da5cb5b1461046a57806392a442ea146104885780639c1d060e146104b8578063a42dce80146104da57600080fd5b80634a5ae51d1161017a578063715018a611610149578063715018a6146103b8578063787dce3d146103cd5780637b04c181146103ed5780638d3638f41461042157600080fd5b80634a5ae51d146103455780634a85178d146103585780634bdb4eed146103785780635fa7b5841461039857600080fd5b8063304ddb4c116101b6578063304ddb4c1461028e57806340432d51146102ae57806341f355ee146102c3578063461178301461031157600080fd5b80630ba36121146101e85780630d25aafe1461021e5780632cc9e7e51461024c5780632d80caa51461026e575b600080fd5b3480156101f457600080fd5b50610208610203366004613792565b610796565b60405161021591906137ff565b60405180910390f35b34801561022a57600080fd5b5061023e610239366004613820565b610830565b604051908152602001610215565b34801561025857600080fd5b5061026c610267366004613862565b610847565b005b34801561027a57600080fd5b5061026c610289366004613792565b61096d565b34801561029a57600080fd5b5061026c6102a936600461398b565b610a80565b3480156102ba57600080fd5b5061026c610dd6565b3480156102cf57600080fd5b506102f96102de366004613792565b6005602052600090815260409020546001600160a01b031681565b6040516001600160a01b039091168152602001610215565b34801561031d57600080fd5b506102f97f000000000000000000000000000000000000000000000000000000000000000081565b61026c610353366004613a54565b610eb5565b34801561036457600080fd5b5061026c610373366004613aee565b61102f565b34801561038457600080fd5b5061026c610393366004613b60565b6111a3565b3480156103a457600080fd5b5061026c6103b3366004613792565b611252565b3480156103c457600080fd5b5061026c61141a565b3480156103d957600080fd5b5061026c6103e8366004613ba4565b611480565b3480156103f957600080fd5b506102f97f000000000000000000000000000000000000000000000000000000000000000081565b34801561042d57600080fd5b506104557f000000000000000000000000000000000000000000000000000000000000000081565b60405163ffffffff9091168152602001610215565b34801561047657600080fd5b506000546001600160a01b03166102f9565b34801561049457600080fd5b506104a86104a3366004613ba4565b61155f565b6040519015158152602001610215565b3480156104c457600080fd5b506104cd61157d565b6040516102159190613bbd565b3480156104e657600080fd5b5061026c6104f5366004613792565b61170a565b34801561050657600080fd5b506102f9610515366004613792565b600b602052600090815260409020546001600160a01b031681565b34801561053c57600080fd5b506102f961054b366004613c5a565b80516020818301810180516002825292820191909301209152546001600160a01b031681565b34801561057d57600080fd5b5061023e60065481565b34801561059357600080fd5b5061026c6105a2366004613ba4565b611792565b3480156105b357600080fd5b5061023e6105c2366004613862565b600460209081526000928352604080842090915290825290205481565b3480156105eb57600080fd5b5061065d6105fa366004613792565b60036020526000908152604090205464ffffffffff81169068ffffffffffffffffff6501000000000082048116916e0100000000000000000000000000008104821691770100000000000000000000000000000000000000000000009091041684565b6040805164ffffffffff909516855268ffffffffffffffffff938416602086015291831691840191909152166060820152608001610215565b3480156106a257600080fd5b5061023e60075481565b3480156106b857600080fd5b506106f26106c7366004613ba4565b600a6020526000908152604090205463ffffffff81169064010000000090046001600160a01b031682565b6040805163ffffffff90931683526001600160a01b03909116602083015201610215565b34801561072257600080fd5b5061026c610731366004613c8f565b611821565b34801561074257600080fd5b5061026c610751366004613792565b611a24565b34801561076257600080fd5b5061026c610771366004613792565b611b03565b34801561078257600080fd5b506102f9610791366004613cc6565b611b92565b600160205260009081526040902080546107af90613ce4565b80601f01602080910402602001604051908101604052809291908181526020018280546107db90613ce4565b80156108285780601f106107fd57610100808354040283529160200191610828565b820191906000526020600020905b81548152906001019060200180831161080b57829003601f168201915b505050505081565b600061083d848484611ba7565b90505b9392505050565b6000546001600160a01b031633146108a65760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b6001600160a01b0382166108e6576040517f24305eca00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6108f1600883611cb1565b610927576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b039182166000908152600b6020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001691909216179055565b6000546001600160a01b031633146109c75760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b6001600160a01b03811660009081527f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3ec602052604081205490819003610a39576040517f30b93f1d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b03821660008181527f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3ec6020526040812055610a7c903383611cd3565b5050565b610a8b600885611cb1565b610ac1576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610acb8484611d81565b925060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638371744e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b2d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b519190613d4e565b6040805163ffffffff7f000000000000000000000000000000000000000000000000000000000000000016602082015267ffffffffffffffff8316818301526001600160a01b038089166060830152608082018890528a1660a0808301919091528251808303909101815260c0909101909152909150600090610bd690859085611eb3565b6000888152600a6020908152604080832081518083019092525463ffffffff8116825264010000000090046001600160a01b031691810182905292935090819003610c4d576040517fa86a3b0e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8151835160208086019190912067ffffffff0000000083831b1663ffffffff8a16176000908152915260409020610ca58a7f00000000000000000000000000000000000000000000000000000000000000008b611fe0565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001663f856ddb68a84868e610ce282886120ae565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e088901b168152600481019590955263ffffffff93909316602485015260448401919091526001600160a01b03166064830152608482015260a4016020604051808303816000875af1158015610d61573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d859190613d4e565b50807f4ce96273f442a9bc593fea917ea7e8c2a009befc78ba3e334008948c7addf22a8c888d8d8d8b604051610dc096959493929190613d69565b60405180910390a2505050505050505050505050565b6000546001600160a01b03163314610e305760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b604051600090339047908381818185875af1925050503d8060008114610e72576040519150601f19603f3d011682016040523d82523d6000602084013e610e77565b606091505b5050905080610eb2576040517f4e5610fa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b6007543414610ef0576040517fc561806500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080610efd84846120d2565b91509150600080600080610f10866121b2565b8b516020808e019190912063ffffffff8f167f0000000000000000000000000000000000000000000000000000000000000000831b67ffffffff000000001617600090815291526040812095995092975090955093509190509050610f788d8d8d8d8561221b565b6000610f848686612336565b90506000610f9c828663ffffffff8e166001146124b2565b9095509050600080610fb08685898d612702565b90925090503415610fc457610fc48661281b565b604080516001600160a01b038681168252602082018690528481168284015260608201849052915187928916917feaf2537b3a5c10387b14e2c0e57b1e11b46ff39b0f4ead5dac98cb0f4fd2118f919081900360800190a35050505050505050505050505050505050565b6000546001600160a01b031633146110895760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b6001600160a01b0385166110c9576040517f76998feb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6110d46008866128b5565b61110a576040517f1191732500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611113866128ca565b6001600160a01b03851660009081526001602052604090206111358782613e05565b50846002876040516111479190613ec5565b90815260405190819003602001902080546001600160a01b03929092167fffffffffffffffffffffffff000000000000000000000000000000000000000090921691909117905561119b8585858585612a6a565b505050505050565b6000546001600160a01b031633146111fd5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b611208600886611cb1565b61123e576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61124b8585858585612a6a565b5050505050565b6000546001600160a01b031633146112ac5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b6112b7600882612c60565b6112ed576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b0381166000908152600160205260408120805461131090613ce4565b80601f016020809104026020016040519081016040528092919081815260200182805461133c90613ce4565b80156113895780601f1061135e57610100808354040283529160200191611389565b820191906000526020600020905b81548152906001019060200180831161136c57829003601f168201915b505050506001600160a01b03841660009081526001602052604081209293506113b3929150613733565b6002816040516113c39190613ec5565b908152604080516020928190038301902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001690556001600160a01b0393909316600090815260039091529182209190915550565b6000546001600160a01b031633146114745760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b61147e6000612c75565b565b6000546001600160a01b031633146114da5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b6114ea60026402540be400613f10565b811115611523576040517f28562c4700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60068190556040518181527fd10d75876659a287a59a6ccfa2e3fff42f84d94b542837acd30bc184d562de40906020015b60405180910390a150565b60008061156c3084612cdd565b6001600160a01b03163b1192915050565b6060600061158b6008612dc9565b90508067ffffffffffffffff8111156115a6576115a66138ad565b6040519080825280602002602001820160405280156115ec57816020015b6040805180820190915260608152600060208201528152602001906001900390816115c45790505b50915060005b81811015611705576000611607600883612dd3565b9050604051806040016040528060016000846001600160a01b03166001600160a01b03168152602001908152602001600020805461164490613ce4565b80601f016020809104026020016040519081016040528092919081815260200182805461167090613ce4565b80156116bd5780601f10611692576101008083540402835291602001916116bd565b820191906000526020600020905b8154815290600101906020018083116116a057829003601f168201915b50505050508152602001826001600160a01b03168152508483815181106116e6576116e6613f4b565b60200260200101819052505080806116fd90613f7a565b9150506115f2565b505090565b3360008181526005602090815260409182902080547fffffffffffffffffffffffff000000000000000000000000000000000000000081166001600160a01b03878116918217909355845192909116808352928201529092917f9dfcadd14a1ddfb19c51e84b87452ca32a43c5559e9750d1575c77105cdeac1e910160405180910390a25050565b6000546001600160a01b031633146117ec5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b60078190556040518181527f5e8bad84cb22c143a6757c7f1252a7d53493816880330977cc99bb7c15aaf6b490602001611554565b6000546001600160a01b0316331461187b5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b82158061188757504683145b156118be576040517f3f8f40a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000063ffffffff168263ffffffff1603611923576040517f93c970c800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82600114806119325750826005145b151563ffffffff83161514611973576040517f93c970c800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b0381166119b3576040517f24305eca00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60408051808201825263ffffffff93841681526001600160a01b0392831660208083019182526000968752600a905291909420935184549151909216640100000000027fffffffffffffffff0000000000000000000000000000000000000000000000009091169190921617179055565b6000546001600160a01b03163314611a7e5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b6001600160a01b038116611afa5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161089d565b610eb281612c75565b3360009081526004602090815260408083206001600160a01b038516845290915281205490819003611b61576040517f30b93f1d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3360008181526004602090815260408083206001600160a01b0387168085529252822091909155610a7c9183611cd3565b6000611b9e8383612336565b90505b92915050565b6001600160a01b03831660009081526003602090815260408083208151608081018352905464ffffffffff811680835268ffffffffffffffffff6501000000000083048116958401959095526e010000000000000000000000000000820485169383019390935277010000000000000000000000000000000000000000000000900490921660608301526402540be40090611c429086613f94565b611c4c9190613f10565b9150600083611c5f578160200151611c65565b81604001515b68ffffffffffffffffff16905080831015611c7e578092505b816060015168ffffffffffffffffff16831115611ca857816060015168ffffffffffffffffff1692505b50509392505050565b6001600160a01b03811660009081526001830160205260408120541515611b9e565b6040516001600160a01b038316602482015260448101829052611d7c9084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152612ddf565b505050565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009081906001600160a01b038516906370a0823190602401602060405180830381865afa158015611de3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e079190613fab565b9050611e1e6001600160a01b038516333086612ec4565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015281906001600160a01b038616906370a0823190602401602060405180830381865afa158015611e7d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea19190613fab565b611eab9190613fc4565b949350505050565b606060a0835114611ef0576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff8416611f3b57815115611f34576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5081610840565b60001963ffffffff851601611fae576080825114611f85576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8282604051602001611f98929190613fd7565b6040516020818303038152906040529050610840565b6040517f523fa8d500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b0383811660248301526000919085169063dd62ed3e90604401602060405180830381865afa158015612049573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061206d9190613fab565b9050818110156120a8578015612092576120926001600160a01b038516846000612f15565b6120a86001600160a01b03851684600019612f15565b50505050565b6000611b9e6120c66001600160a01b03851684612cdd565b6001600160a01b031690565b60608063ffffffff84166121335760a083511461211b576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505060408051602081019091526000815281906121ab565b60001963ffffffff851601611fae57608061214f60a082613ffc565b6121599190613ffc565b835114612192576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b828060200190518101906121a69190614054565b915091505b9250929050565b600080600080600060a08651146121f5576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8580602001905181019061220991906140b8565b939a9299509097509550909350915050565b600061222682613063565b905060006357ecfd2860e01b87878787604051602401612249949392919061414a565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152905060006122e06001600160a01b0384167f00000000000000000000000000000000000000000000000000000000000000008461310f565b9050808060200190518101906122f69190614171565b61232c576040517f182f34eb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050505050505050565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663cb75c11c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612397573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123bb919061418e565b9050806001600160a01b03166378a0565e856123e6866001600160a01b03166001600160a01b031690565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815263ffffffff9290921660048301526024820152604401602060405180830381865afa158015612445573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612469919061418e565b91506001600160a01b0382166124ab576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5092915050565b6000806124c0600886611cb1565b6124f6576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612501858585611ba7565b905083811061253c576040517f3eae42e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3360009081526005602052604090205481850392506001600160a01b0316806125f1576001600160a01b03861660009081527f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3ec6020526040812080548492906125a6908490613ffc565b909155505060408051600080825260208201529081018390527f108516ddcf5ba43cea6bb2cd5ff6d59ac196c1c86ccb9178332b9dd72d1ca5619060600160405180910390a16126f9565b60006402540be400600654846126079190613f94565b6126119190613f10565b9050600061261f8285613fc4565b6001600160a01b03891660009081527f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3ec602052604081208054929350849290919061266b908490613ffc565b90915550506001600160a01b038084166000908152600460209081526040808320938c16835292905290812080548392906126a7908490613ffc565b9091555050604080516001600160a01b0385168152602081018390529081018390527f108516ddcf5ba43cea6bb2cd5ff6d59ac196c1c86ccb9178332b9dd72d1ca5619060600160405180910390a150505b50935093915050565b600080825160000361272c576127226001600160a01b0386168786611cd3565b5083905082612812565b6001600160a01b038086166000908152600b6020526040902054168061276c576127606001600160a01b0387168887611cd3565b85859250925050612812565b60008060008061277b8861311e565b935093509350935061278d8584613182565b96506001600160a01b0387166127c1576127b16001600160a01b038b168c8b611cd3565b8989965096505050505050612812565b6127cc8a868b611fe0565b6127da8585858c8686613285565b9550856000036127f8576127b16001600160a01b038b168c8b611cd3565b61280c6001600160a01b0388168c88611cd3565b50505050505b94509492505050565b6000816001600160a01b03163460405160006040518083038185875af1925050503d8060008114612868576040519150601f19603f3d011682016040523d82523d6000602084013e61286d565b606091505b505090507ff9b0951a3a6282341e1ba9414555d42d04e99076337702ee6dc484a706bfd6838161289e5760006128a0565b345b60405190815260200160405180910390a15050565b6000611b9e836001600160a01b03841661333c565b60006001600160a01b03166002826040516128e59190613ec5565b908152604051908190036020019020546001600160a01b031614612935576040517f82ca3adf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80518190600510612972576040517f3f8fe5a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b6005811015611d7c576040518060400160405280600581526020017f434354502e00000000000000000000000000000000000000000000000000000081525081815181106129c5576129c5613f4b565b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916828281518110612a0457612a04613f4b565b01602001517fff000000000000000000000000000000000000000000000000000000000000001614612a62576040517f3f8fe5a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600101612975565b62989680841115612aa7576040517f76998feb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81831115612ae1576040517f76998feb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80821115612b1b576040517f76998feb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040518060800160405280612b2f8661338b565b64ffffffffff168152602001612b44856133d0565b68ffffffffffffffffff168152602001612b5d846133d0565b68ffffffffffffffffff168152602001612b76836133d0565b68ffffffffffffffffff9081169091526001600160a01b039096166000908152600360209081526040918290208351815492850151938501516060909501518a16770100000000000000000000000000000000000000000000000276ffffffffffffffffffffffffffffffffffffffffffffff958b166e01000000000000000000000000000002959095166dffffffffffffffffffffffffffff94909a1665010000000000027fffffffffffffffffffffffffffffffffffff000000000000000000000000000090931664ffffffffff909116179190911791909116969096171790945550505050565b6000611b9e836001600160a01b038416613415565b600080546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000611b9e83836040518060400160405280602081526020017f602036038060203d373d3d3d923d343d355af13d82803e903d91601e57fd5bf3815250604051602001612d2a91906141ab565b60405160208183030381529060405280519060200120604051602001612db0939291907fff00000000000000000000000000000000000000000000000000000000000000815260609390931b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660018401526015830191909152603582015260550190565b6040516020818303038152906040528051906020012090565b6000611ba1825490565b6000611b9e8383613508565b6000612e34826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166135329092919063ffffffff16565b805190915015611d7c5780806020019051810190612e529190614171565b611d7c5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f74207375636365656400000000000000000000000000000000000000000000606482015260840161089d565b6040516001600160a01b03808516602483015283166044820152606481018290526120a89085907f23b872dd0000000000000000000000000000000000000000000000000000000090608401611d18565b801580612fa857506040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015612f82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612fa69190613fab565b155b61301a5760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527f20746f206e6f6e2d7a65726f20616c6c6f77616e636500000000000000000000606482015260840161089d565b6040516001600160a01b038316602482015260448101829052611d7c9084907f095ea7b30000000000000000000000000000000000000000000000000000000090606401611d18565b6000806040518060400160405280602081526020017f602036038060203d373d3d3d923d343d355af13d82803e903d91601e57fd5bf38152506040516020016130ac91906141ab565b6040516020818303038152906040529050828151602083016000f591506001600160a01b038216613109576040517f27afa9fc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b606061083d8484846000613541565b600080600080608085511461315f576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b848060200190518101906131739190614228565b93509350935093509193509193565b6040805160ff831660248083019190915282518083039091018152604490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f82b86600000000000000000000000000000000000000000000000000000000001790529051600091829182916001600160a01b0387169161320a9190613ec5565b600060405180830381855afa9150503d8060008114613245576040519150601f19603f3d011682016040523d82523d6000602084013e61324a565b606091505b509150915081801561325d575080516020145b156132785761327161326e8261426b565b90565b925061327d565b600092505b505092915050565b6040517f9169558600000000000000000000000000000000000000000000000000000000815260ff8087166004830152851660248201526044810184905260648101829052608481018390526000906001600160a01b0388169063916955869060a4016020604051808303816000875af1925050508015613323575060408051601f3d908101601f1916820190925261332091810190613fab565b60015b61332f57506000613332565b90505b9695505050505050565b600081815260018301602052604081205461338357508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155611ba1565b506000611ba1565b600064ffffffffff8211156133cc576040517fe58d471800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5090565b600068ffffffffffffffffff8211156133cc576040517fe58d471800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600081815260018301602052604081205480156134fe576000613439600183613fc4565b855490915060009061344d90600190613fc4565b90508181146134b257600086600001828154811061346d5761346d613f4b565b906000526020600020015490508087600001848154811061349057613490613f4b565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806134c3576134c361428f565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050611ba1565b6000915050611ba1565b600082600001828154811061351f5761351f613f4b565b9060005260206000200154905092915050565b606061083d848460008561358c565b60606135836001600160a01b038516846040516020016135629291906142be565b60408051601f198184030181529190526001600160a01b03871690846136d4565b95945050505050565b6060824710156136045760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c0000000000000000000000000000000000000000000000000000606482015260840161089d565b6001600160a01b0385163b61365b5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161089d565b600080866001600160a01b031685876040516136779190613ec5565b60006040518083038185875af1925050503d80600081146136b4576040519150601f19603f3d011682016040523d82523d6000602084013e6136b9565b606091505b50915091506136c98282866136fa565b979650505050505050565b606061083d8484846040518060600160405280602981526020016142e56029913961358c565b60608315613709575081610840565b8251156137195782518084602001fd5b8160405162461bcd60e51b815260040161089d91906137ff565b50805461373f90613ce4565b6000825580601f1061374f575050565b601f016020900490600052602060002090810190610eb291905b808211156133cc5760008155600101613769565b6001600160a01b0381168114610eb257600080fd5b6000602082840312156137a457600080fd5b81356108408161377d565b60005b838110156137ca5781810151838201526020016137b2565b50506000910152565b600081518084526137eb8160208601602086016137af565b601f01601f19169290920160200192915050565b602081526000611b9e60208301846137d3565b8015158114610eb257600080fd5b60008060006060848603121561383557600080fd5b83356138408161377d565b925060208401359150604084013561385781613812565b809150509250925092565b6000806040838503121561387557600080fd5b82356138808161377d565b915060208301356138908161377d565b809150509250929050565b63ffffffff81168114610eb257600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715613905576139056138ad565b604052919050565b600067ffffffffffffffff821115613927576139276138ad565b50601f01601f191660200190565b600082601f83011261394657600080fd5b81356139596139548261390d565b6138dc565b81815284602083860101111561396e57600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060008060c087890312156139a457600080fd5b86356139af8161377d565b95506020870135945060408701356139c68161377d565b93506060870135925060808701356139dd8161389b565b915060a087013567ffffffffffffffff8111156139f957600080fd5b613a0589828a01613935565b9150509295509295509295565b60008083601f840112613a2457600080fd5b50813567ffffffffffffffff811115613a3c57600080fd5b6020830191508360208285010111156121ab57600080fd5b60008060008060008060808789031215613a6d57600080fd5b863567ffffffffffffffff80821115613a8557600080fd5b613a918a838b01613a12565b90985096506020890135915080821115613aaa57600080fd5b613ab68a838b01613a12565b909650945060408901359150613acb8261389b565b90925060608801359080821115613ae157600080fd5b50613a0589828a01613935565b60008060008060008060c08789031215613b0757600080fd5b863567ffffffffffffffff811115613b1e57600080fd5b613b2a89828a01613935565b9650506020870135613b3b8161377d565b95989597505050506040840135936060810135936080820135935060a0909101359150565b600080600080600060a08688031215613b7857600080fd5b8535613b838161377d565b97602087013597506040870135966060810135965060800135945092505050565b600060208284031215613bb657600080fd5b5035919050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b83811015613c4c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc089840301855281518051878552613c26888601826137d3565b918901516001600160a01b03169489019490945294870194925090860190600101613be4565b509098975050505050505050565b600060208284031215613c6c57600080fd5b813567ffffffffffffffff811115613c8357600080fd5b611eab84828501613935565b600080600060608486031215613ca457600080fd5b833592506020840135613cb68161389b565b915060408401356138578161377d565b60008060408385031215613cd957600080fd5b82356138808161389b565b600181811c90821680613cf857607f821691505b602082108103613109577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b805167ffffffffffffffff81168114613d4957600080fd5b919050565b600060208284031215613d6057600080fd5b611b9e82613d31565b86815267ffffffffffffffff861660208201526001600160a01b038516604082015283606082015263ffffffff8316608082015260c060a08201526000613db360c08301846137d3565b98975050505050505050565b601f821115611d7c57600081815260208120601f850160051c81016020861015613de65750805b601f850160051c820191505b8181101561119b57828155600101613df2565b815167ffffffffffffffff811115613e1f57613e1f6138ad565b613e3381613e2d8454613ce4565b84613dbf565b602080601f831160018114613e685760008415613e505750858301515b600019600386901b1c1916600185901b17855561119b565b600085815260208120601f198616915b82811015613e9757888601518255948401946001909101908401613e78565b5085821015613eb55787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60008251613ed78184602087016137af565b9190910192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082613f46577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006000198203613f8d57613f8d613ee1565b5060010190565b8082028115828204841417611ba157611ba1613ee1565b600060208284031215613fbd57600080fd5b5051919050565b81810381811115611ba157611ba1613ee1565b604081526000613fea60408301856137d3565b828103602084015261358381856137d3565b80820180821115611ba157611ba1613ee1565b600082601f83011261402057600080fd5b815161402e6139548261390d565b81815284602083860101111561404357600080fd5b611eab8260208301602087016137af565b6000806040838503121561406757600080fd5b825167ffffffffffffffff8082111561407f57600080fd5b61408b8683870161400f565b935060208501519150808211156140a157600080fd5b506140ae8582860161400f565b9150509250929050565b600080600080600060a086880312156140d057600080fd5b85516140db8161389b565b94506140e960208701613d31565b935060408601516140f98161377d565b6060870151608088015191945092506141118161377d565b809150509295509295909350565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b60408152600061415e60408301868861411f565b82810360208401526136c981858761411f565b60006020828403121561418357600080fd5b815161084081613812565b6000602082840312156141a057600080fd5b81516108408161377d565b7f7f000000000000000000000000000000000000000000000000000000000000008152600082516141e38160018501602087016137af565b7f3d5260203df300000000000000000000000000000000000000000000000000006001939091019283015250600701919050565b805160ff81168114613d4957600080fd5b6000806000806080858703121561423e57600080fd5b61424785614217565b935061425560208601614217565b6040860151606090960151949790965092505050565b805160208083015191908110156131095760001960209190910360031b1b16919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b828152600082516142d68160208501602087016137af565b91909101602001939250505056fe416464726573733a206c6f772d6c6576656c2063616c6c20776974682076616c7565206661696c6564a264697066735822122010cbf8acfd7a86db3b773feadbdaa0765a56dca3035a91660a708a20d369f0e164736f6c63430008110033","runtime-code":"0x6080604052600436106101e35760003560e01c80638da5cb5b11610102578063d4a67c6d11610095578063e9bbb36d11610064578063e9bbb36d14610716578063f2fde38b14610736578063f7265b3a14610756578063f879a41a1461077657600080fd5b8063d4a67c6d146105a7578063dc72495b146105df578063e00a83e014610696578063e9259ab9146106ac57600080fd5b8063a4b1d034116100d1578063a4b1d034146104fa578063a5bc29c214610530578063b0e21e8a14610571578063b250fe6b1461058757600080fd5b80638da5cb5b1461046a57806392a442ea146104885780639c1d060e146104b8578063a42dce80146104da57600080fd5b80634a5ae51d1161017a578063715018a611610149578063715018a6146103b8578063787dce3d146103cd5780637b04c181146103ed5780638d3638f41461042157600080fd5b80634a5ae51d146103455780634a85178d146103585780634bdb4eed146103785780635fa7b5841461039857600080fd5b8063304ddb4c116101b6578063304ddb4c1461028e57806340432d51146102ae57806341f355ee146102c3578063461178301461031157600080fd5b80630ba36121146101e85780630d25aafe1461021e5780632cc9e7e51461024c5780632d80caa51461026e575b600080fd5b3480156101f457600080fd5b50610208610203366004613792565b610796565b60405161021591906137ff565b60405180910390f35b34801561022a57600080fd5b5061023e610239366004613820565b610830565b604051908152602001610215565b34801561025857600080fd5b5061026c610267366004613862565b610847565b005b34801561027a57600080fd5b5061026c610289366004613792565b61096d565b34801561029a57600080fd5b5061026c6102a936600461398b565b610a80565b3480156102ba57600080fd5b5061026c610dd6565b3480156102cf57600080fd5b506102f96102de366004613792565b6005602052600090815260409020546001600160a01b031681565b6040516001600160a01b039091168152602001610215565b34801561031d57600080fd5b506102f97f000000000000000000000000000000000000000000000000000000000000000081565b61026c610353366004613a54565b610eb5565b34801561036457600080fd5b5061026c610373366004613aee565b61102f565b34801561038457600080fd5b5061026c610393366004613b60565b6111a3565b3480156103a457600080fd5b5061026c6103b3366004613792565b611252565b3480156103c457600080fd5b5061026c61141a565b3480156103d957600080fd5b5061026c6103e8366004613ba4565b611480565b3480156103f957600080fd5b506102f97f000000000000000000000000000000000000000000000000000000000000000081565b34801561042d57600080fd5b506104557f000000000000000000000000000000000000000000000000000000000000000081565b60405163ffffffff9091168152602001610215565b34801561047657600080fd5b506000546001600160a01b03166102f9565b34801561049457600080fd5b506104a86104a3366004613ba4565b61155f565b6040519015158152602001610215565b3480156104c457600080fd5b506104cd61157d565b6040516102159190613bbd565b3480156104e657600080fd5b5061026c6104f5366004613792565b61170a565b34801561050657600080fd5b506102f9610515366004613792565b600b602052600090815260409020546001600160a01b031681565b34801561053c57600080fd5b506102f961054b366004613c5a565b80516020818301810180516002825292820191909301209152546001600160a01b031681565b34801561057d57600080fd5b5061023e60065481565b34801561059357600080fd5b5061026c6105a2366004613ba4565b611792565b3480156105b357600080fd5b5061023e6105c2366004613862565b600460209081526000928352604080842090915290825290205481565b3480156105eb57600080fd5b5061065d6105fa366004613792565b60036020526000908152604090205464ffffffffff81169068ffffffffffffffffff6501000000000082048116916e0100000000000000000000000000008104821691770100000000000000000000000000000000000000000000009091041684565b6040805164ffffffffff909516855268ffffffffffffffffff938416602086015291831691840191909152166060820152608001610215565b3480156106a257600080fd5b5061023e60075481565b3480156106b857600080fd5b506106f26106c7366004613ba4565b600a6020526000908152604090205463ffffffff81169064010000000090046001600160a01b031682565b6040805163ffffffff90931683526001600160a01b03909116602083015201610215565b34801561072257600080fd5b5061026c610731366004613c8f565b611821565b34801561074257600080fd5b5061026c610751366004613792565b611a24565b34801561076257600080fd5b5061026c610771366004613792565b611b03565b34801561078257600080fd5b506102f9610791366004613cc6565b611b92565b600160205260009081526040902080546107af90613ce4565b80601f01602080910402602001604051908101604052809291908181526020018280546107db90613ce4565b80156108285780601f106107fd57610100808354040283529160200191610828565b820191906000526020600020905b81548152906001019060200180831161080b57829003601f168201915b505050505081565b600061083d848484611ba7565b90505b9392505050565b6000546001600160a01b031633146108a65760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b6001600160a01b0382166108e6576040517f24305eca00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6108f1600883611cb1565b610927576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b039182166000908152600b6020526040902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001691909216179055565b6000546001600160a01b031633146109c75760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b6001600160a01b03811660009081527f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3ec602052604081205490819003610a39576040517f30b93f1d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b03821660008181527f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3ec6020526040812055610a7c903383611cd3565b5050565b610a8b600885611cb1565b610ac1576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b610acb8484611d81565b925060007f00000000000000000000000000000000000000000000000000000000000000006001600160a01b0316638371744e6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b2d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b519190613d4e565b6040805163ffffffff7f000000000000000000000000000000000000000000000000000000000000000016602082015267ffffffffffffffff8316818301526001600160a01b038089166060830152608082018890528a1660a0808301919091528251808303909101815260c0909101909152909150600090610bd690859085611eb3565b6000888152600a6020908152604080832081518083019092525463ffffffff8116825264010000000090046001600160a01b031691810182905292935090819003610c4d576040517fa86a3b0e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8151835160208086019190912067ffffffff0000000083831b1663ffffffff8a16176000908152915260409020610ca58a7f00000000000000000000000000000000000000000000000000000000000000008b611fe0565b6001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001663f856ddb68a84868e610ce282886120ae565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e088901b168152600481019590955263ffffffff93909316602485015260448401919091526001600160a01b03166064830152608482015260a4016020604051808303816000875af1158015610d61573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d859190613d4e565b50807f4ce96273f442a9bc593fea917ea7e8c2a009befc78ba3e334008948c7addf22a8c888d8d8d8b604051610dc096959493929190613d69565b60405180910390a2505050505050505050505050565b6000546001600160a01b03163314610e305760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b604051600090339047908381818185875af1925050503d8060008114610e72576040519150601f19603f3d011682016040523d82523d6000602084013e610e77565b606091505b5050905080610eb2576040517f4e5610fa00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50565b6007543414610ef0576040517fc561806500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080610efd84846120d2565b91509150600080600080610f10866121b2565b8b516020808e019190912063ffffffff8f167f0000000000000000000000000000000000000000000000000000000000000000831b67ffffffff000000001617600090815291526040812095995092975090955093509190509050610f788d8d8d8d8561221b565b6000610f848686612336565b90506000610f9c828663ffffffff8e166001146124b2565b9095509050600080610fb08685898d612702565b90925090503415610fc457610fc48661281b565b604080516001600160a01b038681168252602082018690528481168284015260608201849052915187928916917feaf2537b3a5c10387b14e2c0e57b1e11b46ff39b0f4ead5dac98cb0f4fd2118f919081900360800190a35050505050505050505050505050505050565b6000546001600160a01b031633146110895760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b6001600160a01b0385166110c9576040517f76998feb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6110d46008866128b5565b61110a576040517f1191732500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b611113866128ca565b6001600160a01b03851660009081526001602052604090206111358782613e05565b50846002876040516111479190613ec5565b90815260405190819003602001902080546001600160a01b03929092167fffffffffffffffffffffffff000000000000000000000000000000000000000090921691909117905561119b8585858585612a6a565b505050505050565b6000546001600160a01b031633146111fd5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b611208600886611cb1565b61123e576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b61124b8585858585612a6a565b5050505050565b6000546001600160a01b031633146112ac5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b6112b7600882612c60565b6112ed576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b0381166000908152600160205260408120805461131090613ce4565b80601f016020809104026020016040519081016040528092919081815260200182805461133c90613ce4565b80156113895780601f1061135e57610100808354040283529160200191611389565b820191906000526020600020905b81548152906001019060200180831161136c57829003601f168201915b505050506001600160a01b03841660009081526001602052604081209293506113b3929150613733565b6002816040516113c39190613ec5565b908152604080516020928190038301902080547fffffffffffffffffffffffff00000000000000000000000000000000000000001690556001600160a01b0393909316600090815260039091529182209190915550565b6000546001600160a01b031633146114745760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b61147e6000612c75565b565b6000546001600160a01b031633146114da5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b6114ea60026402540be400613f10565b811115611523576040517f28562c4700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60068190556040518181527fd10d75876659a287a59a6ccfa2e3fff42f84d94b542837acd30bc184d562de40906020015b60405180910390a150565b60008061156c3084612cdd565b6001600160a01b03163b1192915050565b6060600061158b6008612dc9565b90508067ffffffffffffffff8111156115a6576115a66138ad565b6040519080825280602002602001820160405280156115ec57816020015b6040805180820190915260608152600060208201528152602001906001900390816115c45790505b50915060005b81811015611705576000611607600883612dd3565b9050604051806040016040528060016000846001600160a01b03166001600160a01b03168152602001908152602001600020805461164490613ce4565b80601f016020809104026020016040519081016040528092919081815260200182805461167090613ce4565b80156116bd5780601f10611692576101008083540402835291602001916116bd565b820191906000526020600020905b8154815290600101906020018083116116a057829003601f168201915b50505050508152602001826001600160a01b03168152508483815181106116e6576116e6613f4b565b60200260200101819052505080806116fd90613f7a565b9150506115f2565b505090565b3360008181526005602090815260409182902080547fffffffffffffffffffffffff000000000000000000000000000000000000000081166001600160a01b03878116918217909355845192909116808352928201529092917f9dfcadd14a1ddfb19c51e84b87452ca32a43c5559e9750d1575c77105cdeac1e910160405180910390a25050565b6000546001600160a01b031633146117ec5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b60078190556040518181527f5e8bad84cb22c143a6757c7f1252a7d53493816880330977cc99bb7c15aaf6b490602001611554565b6000546001600160a01b0316331461187b5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b82158061188757504683145b156118be576040517f3f8f40a900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7f000000000000000000000000000000000000000000000000000000000000000063ffffffff168263ffffffff1603611923576040517f93c970c800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82600114806119325750826005145b151563ffffffff83161514611973576040517f93c970c800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6001600160a01b0381166119b3576040517f24305eca00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60408051808201825263ffffffff93841681526001600160a01b0392831660208083019182526000968752600a905291909420935184549151909216640100000000027fffffffffffffffff0000000000000000000000000000000000000000000000009091169190921617179055565b6000546001600160a01b03163314611a7e5760405162461bcd60e51b815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572604482015260640161089d565b6001600160a01b038116611afa5760405162461bcd60e51b815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f6464726573730000000000000000000000000000000000000000000000000000606482015260840161089d565b610eb281612c75565b3360009081526004602090815260408083206001600160a01b038516845290915281205490819003611b61576040517f30b93f1d00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3360008181526004602090815260408083206001600160a01b0387168085529252822091909155610a7c9183611cd3565b6000611b9e8383612336565b90505b92915050565b6001600160a01b03831660009081526003602090815260408083208151608081018352905464ffffffffff811680835268ffffffffffffffffff6501000000000083048116958401959095526e010000000000000000000000000000820485169383019390935277010000000000000000000000000000000000000000000000900490921660608301526402540be40090611c429086613f94565b611c4c9190613f10565b9150600083611c5f578160200151611c65565b81604001515b68ffffffffffffffffff16905080831015611c7e578092505b816060015168ffffffffffffffffff16831115611ca857816060015168ffffffffffffffffff1692505b50509392505050565b6001600160a01b03811660009081526001830160205260408120541515611b9e565b6040516001600160a01b038316602482015260448101829052611d7c9084907fa9059cbb00000000000000000000000000000000000000000000000000000000906064015b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152612ddf565b505050565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015260009081906001600160a01b038516906370a0823190602401602060405180830381865afa158015611de3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e079190613fab565b9050611e1e6001600160a01b038516333086612ec4565b6040517f70a0823100000000000000000000000000000000000000000000000000000000815230600482015281906001600160a01b038616906370a0823190602401602060405180830381865afa158015611e7d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ea19190613fab565b611eab9190613fc4565b949350505050565b606060a0835114611ef0576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b63ffffffff8416611f3b57815115611f34576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5081610840565b60001963ffffffff851601611fae576080825114611f85576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8282604051602001611f98929190613fd7565b6040516020818303038152906040529050610840565b6040517f523fa8d500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b0383811660248301526000919085169063dd62ed3e90604401602060405180830381865afa158015612049573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061206d9190613fab565b9050818110156120a8578015612092576120926001600160a01b038516846000612f15565b6120a86001600160a01b03851684600019612f15565b50505050565b6000611b9e6120c66001600160a01b03851684612cdd565b6001600160a01b031690565b60608063ffffffff84166121335760a083511461211b576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b505060408051602081019091526000815281906121ab565b60001963ffffffff851601611fae57608061214f60a082613ffc565b6121599190613ffc565b835114612192576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b828060200190518101906121a69190614054565b915091505b9250929050565b600080600080600060a08651146121f5576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8580602001905181019061220991906140b8565b939a9299509097509550909350915050565b600061222682613063565b905060006357ecfd2860e01b87878787604051602401612249949392919061414a565b60408051601f198184030181529190526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167fffffffff0000000000000000000000000000000000000000000000000000000090931692909217909152905060006122e06001600160a01b0384167f00000000000000000000000000000000000000000000000000000000000000008461310f565b9050808060200190518101906122f69190614171565b61232c576040517f182f34eb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5050505050505050565b6000807f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663cb75c11c6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612397573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123bb919061418e565b9050806001600160a01b03166378a0565e856123e6866001600160a01b03166001600160a01b031690565b6040517fffffffff0000000000000000000000000000000000000000000000000000000060e085901b16815263ffffffff9290921660048301526024820152604401602060405180830381865afa158015612445573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612469919061418e565b91506001600160a01b0382166124ab576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5092915050565b6000806124c0600886611cb1565b6124f6576040517f53b5a66c00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612501858585611ba7565b905083811061253c576040517f3eae42e400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b3360009081526005602052604090205481850392506001600160a01b0316806125f1576001600160a01b03861660009081527f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3ec6020526040812080548492906125a6908490613ffc565b909155505060408051600080825260208201529081018390527f108516ddcf5ba43cea6bb2cd5ff6d59ac196c1c86ccb9178332b9dd72d1ca5619060600160405180910390a16126f9565b60006402540be400600654846126079190613f94565b6126119190613f10565b9050600061261f8285613fc4565b6001600160a01b03891660009081527f17ef568e3e12ab5b9c7254a8d58478811de00f9e6eb34345acd53bf8fd09d3ec602052604081208054929350849290919061266b908490613ffc565b90915550506001600160a01b038084166000908152600460209081526040808320938c16835292905290812080548392906126a7908490613ffc565b9091555050604080516001600160a01b0385168152602081018390529081018390527f108516ddcf5ba43cea6bb2cd5ff6d59ac196c1c86ccb9178332b9dd72d1ca5619060600160405180910390a150505b50935093915050565b600080825160000361272c576127226001600160a01b0386168786611cd3565b5083905082612812565b6001600160a01b038086166000908152600b6020526040902054168061276c576127606001600160a01b0387168887611cd3565b85859250925050612812565b60008060008061277b8861311e565b935093509350935061278d8584613182565b96506001600160a01b0387166127c1576127b16001600160a01b038b168c8b611cd3565b8989965096505050505050612812565b6127cc8a868b611fe0565b6127da8585858c8686613285565b9550856000036127f8576127b16001600160a01b038b168c8b611cd3565b61280c6001600160a01b0388168c88611cd3565b50505050505b94509492505050565b6000816001600160a01b03163460405160006040518083038185875af1925050503d8060008114612868576040519150601f19603f3d011682016040523d82523d6000602084013e61286d565b606091505b505090507ff9b0951a3a6282341e1ba9414555d42d04e99076337702ee6dc484a706bfd6838161289e5760006128a0565b345b60405190815260200160405180910390a15050565b6000611b9e836001600160a01b03841661333c565b60006001600160a01b03166002826040516128e59190613ec5565b908152604051908190036020019020546001600160a01b031614612935576040517f82ca3adf00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80518190600510612972576040517f3f8fe5a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60005b6005811015611d7c576040518060400160405280600581526020017f434354502e00000000000000000000000000000000000000000000000000000081525081815181106129c5576129c5613f4b565b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916828281518110612a0457612a04613f4b565b01602001517fff000000000000000000000000000000000000000000000000000000000000001614612a62576040517f3f8fe5a800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600101612975565b62989680841115612aa7576040517f76998feb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81831115612ae1576040517f76998feb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b80821115612b1b576040517f76998feb00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6040518060800160405280612b2f8661338b565b64ffffffffff168152602001612b44856133d0565b68ffffffffffffffffff168152602001612b5d846133d0565b68ffffffffffffffffff168152602001612b76836133d0565b68ffffffffffffffffff9081169091526001600160a01b039096166000908152600360209081526040918290208351815492850151938501516060909501518a16770100000000000000000000000000000000000000000000000276ffffffffffffffffffffffffffffffffffffffffffffff958b166e01000000000000000000000000000002959095166dffffffffffffffffffffffffffff94909a1665010000000000027fffffffffffffffffffffffffffffffffffff000000000000000000000000000090931664ffffffffff909116179190911791909116969096171790945550505050565b6000611b9e836001600160a01b038416613415565b600080546001600160a01b038381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b6000611b9e83836040518060400160405280602081526020017f602036038060203d373d3d3d923d343d355af13d82803e903d91601e57fd5bf3815250604051602001612d2a91906141ab565b60405160208183030381529060405280519060200120604051602001612db0939291907fff00000000000000000000000000000000000000000000000000000000000000815260609390931b7fffffffffffffffffffffffffffffffffffffffff0000000000000000000000001660018401526015830191909152603582015260550190565b6040516020818303038152906040528051906020012090565b6000611ba1825490565b6000611b9e8383613508565b6000612e34826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166135329092919063ffffffff16565b805190915015611d7c5780806020019051810190612e529190614171565b611d7c5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e60448201527f6f74207375636365656400000000000000000000000000000000000000000000606482015260840161089d565b6040516001600160a01b03808516602483015283166044820152606481018290526120a89085907f23b872dd0000000000000000000000000000000000000000000000000000000090608401611d18565b801580612fa857506040517fdd62ed3e0000000000000000000000000000000000000000000000000000000081523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015612f82573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612fa69190613fab565b155b61301a5760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527f20746f206e6f6e2d7a65726f20616c6c6f77616e636500000000000000000000606482015260840161089d565b6040516001600160a01b038316602482015260448101829052611d7c9084907f095ea7b30000000000000000000000000000000000000000000000000000000090606401611d18565b6000806040518060400160405280602081526020017f602036038060203d373d3d3d923d343d355af13d82803e903d91601e57fd5bf38152506040516020016130ac91906141ab565b6040516020818303038152906040529050828151602083016000f591506001600160a01b038216613109576040517f27afa9fc00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b50919050565b606061083d8484846000613541565b600080600080608085511461315f576040517f74593f8700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b848060200190518101906131739190614228565b93509350935093509193509193565b6040805160ff831660248083019190915282518083039091018152604490910182526020810180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167f82b86600000000000000000000000000000000000000000000000000000000001790529051600091829182916001600160a01b0387169161320a9190613ec5565b600060405180830381855afa9150503d8060008114613245576040519150601f19603f3d011682016040523d82523d6000602084013e61324a565b606091505b509150915081801561325d575080516020145b156132785761327161326e8261426b565b90565b925061327d565b600092505b505092915050565b6040517f9169558600000000000000000000000000000000000000000000000000000000815260ff8087166004830152851660248201526044810184905260648101829052608481018390526000906001600160a01b0388169063916955869060a4016020604051808303816000875af1925050508015613323575060408051601f3d908101601f1916820190925261332091810190613fab565b60015b61332f57506000613332565b90505b9695505050505050565b600081815260018301602052604081205461338357508154600181810184556000848152602080822090930184905584548482528286019093526040902091909155611ba1565b506000611ba1565b600064ffffffffff8211156133cc576040517fe58d471800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b5090565b600068ffffffffffffffffff8211156133cc576040517fe58d471800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600081815260018301602052604081205480156134fe576000613439600183613fc4565b855490915060009061344d90600190613fc4565b90508181146134b257600086600001828154811061346d5761346d613f4b565b906000526020600020015490508087600001848154811061349057613490613f4b565b6000918252602080832090910192909255918252600188019052604090208390555b85548690806134c3576134c361428f565b600190038181906000526020600020016000905590558560010160008681526020019081526020016000206000905560019350505050611ba1565b6000915050611ba1565b600082600001828154811061351f5761351f613f4b565b9060005260206000200154905092915050565b606061083d848460008561358c565b60606135836001600160a01b038516846040516020016135629291906142be565b60408051601f198184030181529190526001600160a01b03871690846136d4565b95945050505050565b6060824710156136045760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f60448201527f722063616c6c0000000000000000000000000000000000000000000000000000606482015260840161089d565b6001600160a01b0385163b61365b5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161089d565b600080866001600160a01b031685876040516136779190613ec5565b60006040518083038185875af1925050503d80600081146136b4576040519150601f19603f3d011682016040523d82523d6000602084013e6136b9565b606091505b50915091506136c98282866136fa565b979650505050505050565b606061083d8484846040518060600160405280602981526020016142e56029913961358c565b60608315613709575081610840565b8251156137195782518084602001fd5b8160405162461bcd60e51b815260040161089d91906137ff565b50805461373f90613ce4565b6000825580601f1061374f575050565b601f016020900490600052602060002090810190610eb291905b808211156133cc5760008155600101613769565b6001600160a01b0381168114610eb257600080fd5b6000602082840312156137a457600080fd5b81356108408161377d565b60005b838110156137ca5781810151838201526020016137b2565b50506000910152565b600081518084526137eb8160208601602086016137af565b601f01601f19169290920160200192915050565b602081526000611b9e60208301846137d3565b8015158114610eb257600080fd5b60008060006060848603121561383557600080fd5b83356138408161377d565b925060208401359150604084013561385781613812565b809150509250925092565b6000806040838503121561387557600080fd5b82356138808161377d565b915060208301356138908161377d565b809150509250929050565b63ffffffff81168114610eb257600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715613905576139056138ad565b604052919050565b600067ffffffffffffffff821115613927576139276138ad565b50601f01601f191660200190565b600082601f83011261394657600080fd5b81356139596139548261390d565b6138dc565b81815284602083860101111561396e57600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060008060c087890312156139a457600080fd5b86356139af8161377d565b95506020870135945060408701356139c68161377d565b93506060870135925060808701356139dd8161389b565b915060a087013567ffffffffffffffff8111156139f957600080fd5b613a0589828a01613935565b9150509295509295509295565b60008083601f840112613a2457600080fd5b50813567ffffffffffffffff811115613a3c57600080fd5b6020830191508360208285010111156121ab57600080fd5b60008060008060008060808789031215613a6d57600080fd5b863567ffffffffffffffff80821115613a8557600080fd5b613a918a838b01613a12565b90985096506020890135915080821115613aaa57600080fd5b613ab68a838b01613a12565b909650945060408901359150613acb8261389b565b90925060608801359080821115613ae157600080fd5b50613a0589828a01613935565b60008060008060008060c08789031215613b0757600080fd5b863567ffffffffffffffff811115613b1e57600080fd5b613b2a89828a01613935565b9650506020870135613b3b8161377d565b95989597505050506040840135936060810135936080820135935060a0909101359150565b600080600080600060a08688031215613b7857600080fd5b8535613b838161377d565b97602087013597506040870135966060810135965060800135945092505050565b600060208284031215613bb657600080fd5b5035919050565b60006020808301818452808551808352604092508286019150828160051b87010184880160005b83811015613c4c577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc089840301855281518051878552613c26888601826137d3565b918901516001600160a01b03169489019490945294870194925090860190600101613be4565b509098975050505050505050565b600060208284031215613c6c57600080fd5b813567ffffffffffffffff811115613c8357600080fd5b611eab84828501613935565b600080600060608486031215613ca457600080fd5b833592506020840135613cb68161389b565b915060408401356138578161377d565b60008060408385031215613cd957600080fd5b82356138808161389b565b600181811c90821680613cf857607f821691505b602082108103613109577f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b805167ffffffffffffffff81168114613d4957600080fd5b919050565b600060208284031215613d6057600080fd5b611b9e82613d31565b86815267ffffffffffffffff861660208201526001600160a01b038516604082015283606082015263ffffffff8316608082015260c060a08201526000613db360c08301846137d3565b98975050505050505050565b601f821115611d7c57600081815260208120601f850160051c81016020861015613de65750805b601f850160051c820191505b8181101561119b57828155600101613df2565b815167ffffffffffffffff811115613e1f57613e1f6138ad565b613e3381613e2d8454613ce4565b84613dbf565b602080601f831160018114613e685760008415613e505750858301515b600019600386901b1c1916600185901b17855561119b565b600085815260208120601f198616915b82811015613e9757888601518255948401946001909101908401613e78565b5085821015613eb55787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60008251613ed78184602087016137af565b9190910192915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082613f46577f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b500490565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60006000198203613f8d57613f8d613ee1565b5060010190565b8082028115828204841417611ba157611ba1613ee1565b600060208284031215613fbd57600080fd5b5051919050565b81810381811115611ba157611ba1613ee1565b604081526000613fea60408301856137d3565b828103602084015261358381856137d3565b80820180821115611ba157611ba1613ee1565b600082601f83011261402057600080fd5b815161402e6139548261390d565b81815284602083860101111561404357600080fd5b611eab8260208301602087016137af565b6000806040838503121561406757600080fd5b825167ffffffffffffffff8082111561407f57600080fd5b61408b8683870161400f565b935060208501519150808211156140a157600080fd5b506140ae8582860161400f565b9150509250929050565b600080600080600060a086880312156140d057600080fd5b85516140db8161389b565b94506140e960208701613d31565b935060408601516140f98161377d565b6060870151608088015191945092506141118161377d565b809150509295509295909350565b818352818160208501375060006020828401015260006020601f19601f840116840101905092915050565b60408152600061415e60408301868861411f565b82810360208401526136c981858761411f565b60006020828403121561418357600080fd5b815161084081613812565b6000602082840312156141a057600080fd5b81516108408161377d565b7f7f000000000000000000000000000000000000000000000000000000000000008152600082516141e38160018501602087016137af565b7f3d5260203df300000000000000000000000000000000000000000000000000006001939091019283015250600701919050565b805160ff81168114613d4957600080fd5b6000806000806080858703121561423e57600080fd5b61424785614217565b935061425560208601614217565b6040860151606090960151949790965092505050565b805160208083015191908110156131095760001960209190910360031b1b16919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b828152600082516142d68160208501602087016137af565b91909101602001939250505056fe416464726573733a206c6f772d6c6576656c2063616c6c20776974682076616c7565206661696c6564a264697066735822122010cbf8acfd7a86db3b773feadbdaa0765a56dca3035a91660a708a20d369f0e164736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"82396:17707:0:-:0;;;83673:243;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;6860:32;5957:10;6860:18;:32::i;:::-;-1:-1:-1;;;;;83728:32:0;;;;;;83811:41;;;-1:-1:-1;;;83811:41:0;;;;:39;;:41;;;;;;;;;;;;;;;83728:32;83811:41;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;;;;;83770:83:0;;;;;83877:32;;;-1:-1:-1;;;83877:32:0;;;;:30;;:32;;;;;;;;;;;;;;;83770:83;83877:32;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;83863:46;;;;-1:-1:-1;82396:17707:0;;8209:187;8282:16;8301:6;;-1:-1:-1;;;;;8317:17:0;;;-1:-1:-1;;;;;;8317:17:0;;;;;;8349:40;;8301:6;;;;;;;8349:40;;8282:16;8349:40;8272:124;8209:187;:::o;14:148:1:-;-1:-1:-1;;;;;106:31:1;;96:42;;86:70;;152:1;149;142:12;86:70;14:148;:::o;167:292::-;261:6;314:2;302:9;293:7;289:23;285:32;282:52;;;330:1;327;320:12;282:52;362:9;356:16;381:48;423:5;381:48;:::i;:::-;448:5;167:292;-1:-1:-1;;;167:292:1:o;737:280::-;806:6;859:2;847:9;838:7;834:23;830:32;827:52;;;875:1;872;865:12;827:52;907:9;901:16;957:10;950:5;946:22;939:5;936:33;926:61;;983:1;980;973:12;737:280;82396:17707:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"82396:17707:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;22486:47;;;;;;;;;;-1:-1:-1;22486:47:0;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;29768:204;;;;;;;;;;-1:-1:-1;29768:204:0;;;;;:::i;:::-;;:::i;:::-;;;1964:25:1;;;1952:2;1937:18;29768:204:0;1818:177:1;85367:361:0;;;;;;;;;;-1:-1:-1;85367:361:0;;;;;:::i;:::-;;:::i;:::-;;86118:289;;;;;;;;;;-1:-1:-1;86118:289:0;;;;;:::i;:::-;;:::i;87143:2078::-;;;;;;;;;;-1:-1:-1;87143:2078:0;;;;;:::i;:::-;;:::i;26195:177::-;;;;;;;;;;;;;:::i;23273:55::-;;;;;;;;;;-1:-1:-1;23273:55:0;;;;;:::i;:::-;;;;;;;;;;;;-1:-1:-1;;;;;23273:55:0;;;;;;-1:-1:-1;;;;;4807:55:1;;;4789:74;;4777:2;4762:18;23273:55:0;4643:226:1;83389:47:0;;;;;;;;;;;;;;;89323:1762;;;;;;:::i;:::-;;:::i;24751:772::-;;;;;;;;;;-1:-1:-1;24751:772:0;;;;;:::i;:::-;;:::i;27222:329::-;;;;;;;;;;-1:-1:-1;27222:329:0;;;;;:::i;:::-;;:::i;25652:475::-;;;;;;;;;;-1:-1:-1;25652:475:0;;;;;:::i;:::-;;:::i;7607:101::-;;;;;;;;;;;;;:::i;27780:243::-;;;;;;;;;;-1:-1:-1;27780:243:0;;;;;:::i;:::-;;:::i;83328:55::-;;;;;;;;;;;;;;;83287:35;;;;;;;;;;;;;;;;;;8415:10:1;8403:23;;;8385:42;;8373:2;8358:18;83287:35:0;8241:192:1;6975:85:0;;;;;;;;;;-1:-1:-1;7021:7:0;7047:6;-1:-1:-1;;;;;7047:6:0;6975:85;;91746:285;;;;;;;;;;-1:-1:-1;91746:285:0;;;;;:::i;:::-;;:::i;:::-;;;8788:14:1;;8781:22;8763:41;;8751:2;8736:18;91746:285:0;8623:187:1;30061:386:0;;;;;;;;;;;;;:::i;:::-;;;;;;;:::i;28723:265::-;;;;;;;;;;-1:-1:-1;28723:265:0;;;;;:::i;:::-;;:::i;83616:50::-;;;;;;;;;;-1:-1:-1;83616:50:0;;;;;:::i;:::-;;;;;;;;;;;;-1:-1:-1;;;;;83616:50:0;;;22606:47;;;;;;;;;;-1:-1:-1;22606:47:0;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;22606:47:0;;;23522:26;;;;;;;;;;;;;;;;26491:179;;;;;;;;;;-1:-1:-1;26491:179:0;;;;;:::i;:::-;;:::i;23001:70::-;;;;;;;;;;-1:-1:-1;23001:70:0;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;22725:48;;;;;;;;;;-1:-1:-1;22725:48:0;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;10573:12:1;10561:25;;;10543:44;;10606:20;10662:15;;;10657:2;10642:18;;10635:43;10714:15;;;10694:18;;;10687:43;;;;10766:15;10761:2;10746:18;;10739:43;10530:3;10515:19;22725:48:0;10320:468:1;23666:29:0;;;;;;;;;;;;;;;;83497:58;;;;;;;;;;-1:-1:-1;83497:58:0;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;83497:58:0;;;;;;;10995:10:1;10983:23;;;10965:42;;-1:-1:-1;;;;;11043:55:1;;;11038:2;11023:18;;11016:83;10938:18;83497:58:0;10793:312:1;84333:960:0;;;;;;;;;;-1:-1:-1;84333:960:0;;;;;:::i;:::-;;:::i;7857:198::-;;;;;;;;;;-1:-1:-1;7857:198:0;;;;;:::i;:::-;;:::i;86502:278::-;;;;;;;;;;-1:-1:-1;86502:278:0;;;;;:::i;:::-;;:::i;91512:162::-;;;;;;;;;;-1:-1:-1;91512:162:0;;;;;:::i;:::-;;:::i;22486:47::-;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::o;29768:204::-;29893:11;29923:42;29943:5;29950:6;29958;29923:19;:42::i;:::-;29916:49;;29768:204;;;;;;:::o;85367:361::-;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;;;;;;;;;-1:-1:-1;;;;;85463:25:0;::::1;85459:55;;85497:17;;;;;;;;;;;;;;85459:55;85529:35;:13;85552:11:::0;85529:22:::1;:35::i;:::-;85524:68;;85573:19;;;;;;;;;;;;;;85524:68;-1:-1:-1::0;;;;;85686:28:0;;::::1;;::::0;;;:15:::1;:28;::::0;;;;:35;;;::::1;::::0;;;::::1;;::::0;;85367:361::o;86118:289::-;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;12402:356:1;7179:68:0;-1:-1:-1;;;;;86210:34:0;::::1;86192:15;86210:34:::0;;;:27;::::1;:34:::0;:27;:34;;;;86258:12;;;86254:41:::1;;86279:16;;;;;;;;;;;;;;86254:41;-1:-1:-1::0;;;;;86305:34:0;::::1;86342:1;86305:34:::0;;;:27;::::1;:34:::0;:27;:34;;:38;86353:47:::1;::::0;86380:10:::1;86392:7:::0;86353:26:::1;:47::i;:::-;86182:225;86118:289:::0;:::o;87143:2078::-;87432:33;:13;87455:9;87432:22;:33::i;:::-;87427:66;;87474:19;;;;;;;;;;;;;;87427:66;87591:29;87602:9;87613:6;87591:10;:29::i;:::-;87582:38;;87630:12;87645:18;-1:-1:-1;;;;;87645:37:0;;:39;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;47642:67;;;20395:10:1;87933:11:0;20383:23:1;47642:67:0;;;20365:42:1;20455:18;20443:31;;20423:18;;;20416:59;-1:-1:-1;;;;;20572:15:1;;;47594:29:0;20552:18:1;;20545:43;20604:18;;;20597:34;;;20668:15;;20647:19;;;;20640:44;;;;47642:67:0;;;;;;;;;;20337:19:1;;;;47642:67:0;;;87630:54;;-1:-1:-1;87806:29:0;;87838:178;;87876:14;;87996:10;87838:24;:178::i;:::-;88026:26;88055:27;;;:18;:27;;;;;;;;88026:56;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;88026:56:0;;;;;;;87806:210;;-1:-1:-1;88026:56:0;88168:19;;;88164:60;;88196:28;;;;;;;;;;;;;;88164:60;88261:13;;99599:27;;99547:2;99599:27;;;;;;;99517:32;;;;;99516:51;;;;88234:24;99934:17;;;99964:23;;100082:2;100069:16;;88806:57;88820:9;88839:14;88856:6;88806:13;:57::i;:::-;-1:-1:-1;;;;;88873:14:0;:39;;88926:6;88946:17;88977:14;89005:9;89028:64;88977:14;89082:9;89028:18;:64::i;:::-;88873:229;;;;;;;;;;;;;13411:25:1;;;;88873:229:0;13472:23:1;;;;13452:18;;;13445:51;13512:18;;;13505:34;;;;-1:-1:-1;;;;;13575:55:1;13555:18;;;13548:83;13647:19;;;13640:35;13383:19;;88873:229:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;89204:9;89117:97;89135:7;89144:5;89151:9;89162:6;89170:14;89186:16;89117:97;;;;;;;;;;;:::i;:::-;;;;;;;;87350:1871;;;;;;87143:2078;;;;;;:::o;26195:177::-;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;12402:356:1;7179:68:0;26264:49:::1;::::0;26246:12:::1;::::0;26264:10:::1;::::0;26287:21:::1;::::0;26246:12;26264:49;26246:12;26264:49;26287:21;26264:10;:49:::1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;26245:68;;;26328:7;26323:42;;26344:21;;;;;;;;;;;;;;26323:42;26235:137;26195:177::o:0;89323:1762::-;89600:14;;89587:9;:27;89583:64;;89623:24;;;;;;;;;;;;;;89583:64;89658:24;89684:23;89711:92;89749:14;89777:16;89711:24;:92::i;:::-;89657:146;;;;89814:19;89837:23;89862:14;89878:17;89899:54;89941:11;89899:41;:54::i;:::-;99599:27;;99547:2;99599:27;;;;;;;99516:51;;;90205:11;99517:32;;;;99516:51;90174:17;99934;;;99964:23;;100082:2;100069:16;;89813:140;;-1:-1:-1;89813:140:0;;-1:-1:-1;89813:140:0;;-1:-1:-1;89813:140:0;-1:-1:-1;90174:17:0;100069:16;-1:-1:-1;90174:77:0;;90328:47;90345:7;;90354:9;;90365;90328:16;:47::i;:::-;90385:13;90401:45;90416:12;90430:15;90401:14;:45::i;:::-;90385:61;-1:-1:-1;90456:11:0;90563:74;90385:61;90587:6;90595:41;;;46078:1;90595:41;90563:16;:74::i;:::-;90547:90;;-1:-1:-1;90547:90:0;-1:-1:-1;90747:16:0;;90786:53;90802:9;90813:5;90547:90;90828:10;90786:15;:53::i;:::-;90746:93;;-1:-1:-1;90746:93:0;-1:-1:-1;90943:9:0;:13;90939:47;;90958:28;90976:9;90958:17;:28::i;:::-;91001:77;;;-1:-1:-1;;;;;14875:15:1;;;14857:34;;14922:2;14907:18;;14900:34;;;14970:15;;;14950:18;;;14943:43;15017:2;15002:18;;14995:34;;;91001:77:0;;91068:9;;91001:77;;;;;;;;;14783:3:1;91001:77:0;;;89510:1575;;;;;;;;;;;89323:1762;;;;;;:::o;24751:772::-;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;12402:356:1;7179:68:0;-1:-1:-1;;;;;24969:19:0;::::1;24965:53;;24997:21;;;;;;;;;;;;;;24965:53;25136:24;:13;25154:5:::0;25136:17:::1;:24::i;:::-;25131:61;;25169:23;;;;;;;;;;;;;;25131:61;25277:27;25297:6;25277:19;:27::i;:::-;-1:-1:-1::0;;;;;25350:20:0;::::1;;::::0;;;:13:::1;:20;::::0;;;;:29:::1;25373:6:::0;25350:20;:29:::1;:::i;:::-;;25413:5;25389:13;25403:6;25389:21;;;;;;:::i;:::-;::::0;;;::::1;::::0;;;;;::::1;::::0;;;:29;;-1:-1:-1;;;;;25389:29:0;;;::::1;::::0;;;::::1;::::0;;;::::1;::::0;;25453:63:::1;25466:5:::0;25473:10;25485;25497;25509:6;25453:12:::1;:63::i;:::-;24751:772:::0;;;;;;:::o;27222:329::-;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;12402:356:1;7179:68:0;27414:29:::1;:13;27437:5:::0;27414:22:::1;:29::i;:::-;27409:62;;27452:19;;;;;;;;;;;;;;27409:62;27481:63;27494:5;27501:10;27513;27525;27537:6;27481:12;:63::i;:::-;27222:329:::0;;;;;:::o;25652:475::-;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;12402:356:1;7179:68:0;25823:27:::1;:13;25844:5:::0;25823:20:::1;:27::i;:::-;25818:60;;25859:19;;;;;;;;;;;;;;25818:60;-1:-1:-1::0;;;;;25950:20:0;::::1;25927;25950::::0;;;:13:::1;:20;::::0;;;;25927:43;;::::1;::::0;::::1;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1::0;;;;;;;;;25987:20:0;::::1;;::::0;;;:13:::1;:20;::::0;;;;25927:43;;-1:-1:-1;25980:27:0::1;::::0;25987:20;-1:-1:-1;25980:27:0::1;:::i;:::-;26024:13;26038:6;26024:21;;;;;;:::i;:::-;::::0;;;::::1;::::0;;::::1;::::0;;;;;;;;26017:28;;;::::1;::::0;;-1:-1:-1;;;;;26100:20:0;;;::::1;-1:-1:-1::0;26100:20:0;;;:13:::1;:20:::0;;;;;;26093:27;;;;-1:-1:-1;25652:475:0:o;7607:101::-;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;12402:356:1;7179:68:0;7671:30:::1;7698:1;7671:18;:30::i;:::-;7607:101::o:0;27780:243::-;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;12402:356:1;7179:68:0;21780:19:::1;21798:1;21558:6;21780:19;:::i;:::-;27861:14;:33;27857:72;;;27903:26;;;;;;;;;;;;;;27857:72;27939:11;:28:::0;;;27982:34:::1;::::0;1964:25:1;;;27982:34:0::1;::::0;1952:2:1;1937:18;27982:34:0::1;;;;;;;;27780:243:::0;:::o;91746:285::-;91816:4;92023:1;91948:60;91991:4;91998:9;91948:34;:60::i;:::-;-1:-1:-1;;;;;91948:72:0;;:76;;91746:285;-1:-1:-1;;91746:285:0:o;30061:386::-;30111:33;30156:14;30173:22;:13;:20;:22::i;:::-;30156:39;;30238:6;30220:25;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;;;;;;;;;;;;;;30220:25:0;;;;;;;;;;;;;;;;30205:40;;30260:9;30255:186;30279:6;30275:1;:10;30255:186;;;30306:13;30322:19;:13;30339:1;30322:16;:19::i;:::-;30306:35;;30373:57;;;;;;;;30394:13;:20;30408:5;-1:-1:-1;;;;;30394:20:0;-1:-1:-1;;;;;30394:20:0;;;;;;;;;;;;30373:57;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;30423:5;-1:-1:-1;;;;;30373:57:0;;;;30355:12;30368:1;30355:15;;;;;;;;:::i;:::-;;;;;;:75;;;;30292:149;30287:3;;;;;:::i;:::-;;;;30255:186;;;;30146:301;30061:386;:::o;28723:265::-;28836:10;28789:23;28815:32;;;:20;:32;;;;;;;;;;;28857:47;;;-1:-1:-1;;;;;28857:47:0;;;;;;;;;28919:62;;28815:32;;;;18809:34:1;;;18859:18;;;18852:43;28815:32:0;;28836:10;28919:62;;18721:18:1;28919:62:0;;;;;;;28779:209;28723:265;:::o;26491:179::-;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;12402:356:1;7179:68:0;26574:14:::1;:34:::0;;;26623:40:::1;::::0;1964:25:1;;;26623:40:0::1;::::0;1952:2:1;1937:18;26623:40:0::1;1818:177:1::0;84333:960:0;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;12402:356:1;7179:68:0;84575:18;;;:52:::1;;;84614:13;84597;:30;84575:52;84571:87;;;84636:22;;;;;;;;;;;;;;84571:87;84750:11;84734:27;;:12;:27;;::::0;84730:61:::1;;84770:21;;;;;;;;;;;;;;84730:61;85003:13;85020:1;85003:18;:40;;;;85025:13;85042:1;85025:18;85003:40;84979:65;;84980:17;::::0;::::1;::::0;84979:65:::1;84975:99;;85053:21;;;;;;;;;;;;;;84975:99;-1:-1:-1::0;;;;;85138:31:0;::::1;85134:61;;85178:17;;;;;;;;;;;;;;85134:61;85241:45;::::0;;;;::::1;::::0;;::::1;::::0;;::::1;::::0;;-1:-1:-1;;;;;85241:45:0;;::::1;;::::0;;::::1;::::0;;;-1:-1:-1;85205:33:0;;;:18:::1;:33:::0;;;;;;:81;;;;;;;;::::1;::::0;::::1;::::0;;;;;;;::::1;::::0;::::1;::::0;;84333:960::o;7857:198::-;7021:7;7047:6;-1:-1:-1;;;;;7047:6:0;5957:10;7187:23;7179:68;;;;-1:-1:-1;;;7179:68:0;;12604:2:1;7179:68:0;;;12586:21:1;;;12623:18;;;12616:30;12682:34;12662:18;;;12655:62;12734:18;;7179:68:0;12402:356:1;7179:68:0;-1:-1:-1;;;;;7945:22:0;::::1;7937:73;;;::::0;-1:-1:-1;;;7937:73:0;;19108:2:1;7937:73:0::1;::::0;::::1;19090:21:1::0;19147:2;19127:18;;;19120:30;19186:34;19166:18;;;19159:62;19257:8;19237:18;;;19230:36;19283:19;;7937:73:0::1;18906:402:1::0;7937:73:0::1;8020:28;8039:8;8020:18;:28::i;86502:278::-:0;86599:10;86565:15;86583:27;;;:15;:27;;;;;;;;-1:-1:-1;;;;;86583:34:0;;;;;;;;;;;86631:12;;;86627:41;;86652:16;;;;;;;;;;;;;;86627:41;86694:10;86715:1;86678:27;;;:15;:27;;;;;;;;-1:-1:-1;;;;;86678:34:0;;;;;;;;;:38;;;;86726:47;;86765:7;86726:26;:47::i;91512:162::-;91600:7;91626:41;91641:12;91655:11;91626:14;:41::i;:::-;91619:48;;91512:162;;;;;:::o;34854:559::-;-1:-1:-1;;;;;35033:20:0;;34980:11;35033:20;;;:13;:20;;;;;;;;35003:50;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;21558:6;;35106:32;;:6;:32;:::i;:::-;35105:52;;;;:::i;:::-;35099:58;;35196:14;35213:6;:58;;35248:12;:23;;;35213:58;;;35222:12;:23;;;35213:58;35196:75;;;;35291:6;35285:3;:12;35281:30;;;35305:6;35299:12;;35281:30;35360:12;:19;;;35354:25;;:3;:25;35350:56;;;35387:12;:19;;;35381:25;;;;35350:56;34993:420;;34854:559;;;;;:::o;16510:165::-;-1:-1:-1;;;;;16643:23:0;;16590:4;12177:19;;;:12;;;:19;;;;;;:24;;16613:55;12081:127;79180:205;79319:58;;-1:-1:-1;;;;;19678:55:1;;79319:58:0;;;19660:74:1;19750:18;;;19743:34;;;79292:86:0;;79312:5;;79342:23;;19633:18:1;;79319:58:0;;;;-1:-1:-1;;79319:58:0;;;;;;;;;;;;;;;;;;;;;;;;;;;79292:19;:86::i;:::-;79180:205;;;:::o;93043:324::-;93168:38;;;;;93200:4;93168:38;;;4789:74:1;93112:20:0;;;;-1:-1:-1;;;;;93168:23:0;;;;;4762:18:1;;93168:38:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;93144:62;-1:-1:-1;93216:65:0;-1:-1:-1;;;;;93216:30:0;;93247:10;93267:4;93274:6;93216:30;:65::i;:::-;93306:38;;;;;93338:4;93306:38;;;4789:74:1;93347:13:0;;-1:-1:-1;;;;;93306:23:0;;;;;4762:18:1;;93306:38:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:54;;;;:::i;:::-;93291:69;93043:324;-1:-1:-1;;;;93043:324:0:o;49057:840::-;49207:29;46186:6;49252:11;:18;:41;49248:78;;49302:24;;;;;;;;;;;;;;49248:78;49340:30;;;49336:555;;49390:17;;:22;49386:59;;49421:24;;;;;;;;;;;;;;49386:59;-1:-1:-1;49541:11:0;49534:18;;49336:555;-1:-1:-1;;49573:30:0;;;;49569:322;;46300:6;49623:10;:17;:39;49619:76;;49671:24;;;;;;;;;;;;;;49619:76;49795:11;49808:10;49784:35;;;;;;;;;:::i;:::-;;;;;;;;;;;;;49777:42;;;;49569:322;49857:23;;;;;;;;;;;;;;92543:448;92683:47;;;;;92715:4;92683:47;;;18809:34:1;-1:-1:-1;;;;;18879:15:1;;;18859:18;;;18852:43;92663:17:0;;92683:23;;;;;;18721:18:1;;92683:47:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;92663:67;;92756:6;92744:9;:18;92740:245;;;92854:14;;92850:57;;92870:37;-1:-1:-1;;;;;92870:25:0;;92896:7;92905:1;92870:25;:37::i;:::-;92921:53;-1:-1:-1;;;;;92921:25:0;;92947:7;-1:-1:-1;;92921:25:0;:53::i;:::-;92653:338;92543:448;;;:::o;98820:342::-;98911:7;99099:56;:37;-1:-1:-1;;;;;99099:26:0;;99126:9;99099:26;:37::i;:::-;-1:-1:-1;;;;;99099:54:0;;4429:127;52616:658;52740:24;;52809:30;;;52805:463;;46186:6;52859:16;:23;:46;52855:83;;52914:24;;;;;;;;;;;;;;52855:83;-1:-1:-1;;52952:29:0;;;;;;;;;-1:-1:-1;52952:29:0;;52960:16;;52952:29;;52805:463;-1:-1:-1;;53002:30:0;;;;52998:270;;46300:6;46515:28;46186:6;46300;46515:28;:::i;:::-;:49;;;;:::i;:::-;53052:16;:23;:46;53048:83;;53107:24;;;;;;;;;;;;;;53048:83;53163:16;53152:44;;;;;;;;;;;;:::i;:::-;53145:51;;;;52998:270;52616:658;;;;;:::o;50785:449::-;50898:19;50931:12;50957:23;50994:14;51022:17;46186:6;51068:11;:18;:41;51064:78;;51118:24;;;;;;;;;;;;;;51064:78;51170:11;51159:68;;;;;;;;;;;;:::i;:::-;51152:75;;;;-1:-1:-1;51152:75:0;;-1:-1:-1;51152:75:0;-1:-1:-1;51152:75:0;;-1:-1:-1;50785:449:0;-1:-1:-1;;50785:449:0:o;93468:981::-;93719:17;93739:37;93766:9;93739:26;:37::i;:::-;93719:57;;93837:20;93883:43;;;93928:7;;93937:9;;93860:87;;;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;93860:87:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;94204:59:0;-1:-1:-1;;;;;94204:21:0;;94234:18;93860:87;94204:21;:59::i;:::-;94178:85;;94390:10;94379:30;;;;;;;;;;;;:::i;:::-;94374:68;;94418:24;;;;;;;;;;;;;;94374:68;93602:847;;;93468:981;;;;;:::o;97428:398::-;97517:13;97542:19;97577:14;-1:-1:-1;;;;;97577:26:0;;:28;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;97542:64;;97624:6;-1:-1:-1;;;;;97624:20:0;;97645:12;97659:30;:11;-1:-1:-1;;;;;97659:28:0;-1:-1:-1;;;;;4526:22:0;;4429:127;97659:30;97624:66;;;;;;;;;;;24364:23:1;;;;97624:66:0;;;24346:42:1;24404:18;;;24397:34;24319:18;;97624:66:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;97616:74;-1:-1:-1;;;;;;97772:19:0;;97768:51;;97800:19;;;;;;;;;;;;;;97768:51;97532:294;97428:398;;;;:::o;30944:1335::-;31062:22;;31114:29;:13;31137:5;31114:22;:29::i;:::-;31109:62;;31152:19;;;;;;;;;;;;;;31109:62;31187:42;31207:5;31214:6;31222;31187:19;:42::i;:::-;31181:48;;31250:6;31243:3;:13;31239:50;;31265:24;;;;;;;;;;;;;;31239:50;31559:10;31515:20;31538:32;;;:20;:32;;;;;;31421:12;;;;-1:-1:-1;;;;;;31538:32:0;;31580:693;;-1:-1:-1;;;;;31714:34:0;;:27;:34;;;:27;;:34;:27;:34;;:41;;31752:3;;31714:27;:41;;31752:3;;31714:41;:::i;:::-;;;;-1:-1:-1;;31774:32:0;;;31795:1;24652:74:1;;;24757:2;24742:18;;24735:34;24785:18;;;24778:34;;;31774:32:0;;24640:2:1;24625:18;31774:32:0;;;;;;;31580:693;;;31912:25;21558:6;31947:11;;31941:3;:17;;;;:::i;:::-;31940:37;;;;:::i;:::-;31912:65;-1:-1:-1;31991:24:0;32018:23;31912:65;32018:3;:23;:::i;:::-;-1:-1:-1;;;;;32055:34:0;;:27;:34;;;:27;;:34;:27;:34;;:55;;31991:50;;-1:-1:-1;32093:17:0;;32055:34;;:27;:55;;32093:17;;32055:55;:::i;:::-;;;;-1:-1:-1;;;;;;;32124:29:0;;;;;;;:15;:29;;;;;;;;:36;;;;;;;;;;;:56;;32164:16;;32124:29;:56;;32164:16;;32124:56;:::i;:::-;;;;-1:-1:-1;;32199:63:0;;;-1:-1:-1;;;;;24670:55:1;;24652:74;;24757:2;24742:18;;24735:34;;;24785:18;;;24778:34;;;32199:63:0;;24640:2:1;24625:18;32199:63:0;;;;;;;31823:450;;31580:693;31099:1180;30944:1335;;;;;;:::o;94645:1721::-;94801:16;94819:17;94919:10;:17;94940:1;94919:22;94915:134;;94957:45;-1:-1:-1;;;;;94957:26:0;;94984:9;94995:6;94957:26;:45::i;:::-;-1:-1:-1;95024:5:0;;-1:-1:-1;95031:6:0;95016:22;;94915:134;-1:-1:-1;;;;;95221:22:0;;;95206:12;95221:22;;;:15;:22;;;;;;;;95309:130;;95347:45;-1:-1:-1;;;;;95347:26:0;;95374:9;95385:6;95347:26;:45::i;:::-;95414:5;95421:6;95406:22;;;;;;;95309:130;95449:20;95471:18;95491:16;95509:20;95533:52;95574:10;95533:40;:52::i;:::-;95448:137;;;;;;;;95606:32;95619:4;95625:12;95606;:32::i;:::-;95595:43;-1:-1:-1;;;;;;95722:22:0;;95718:134;;95760:45;-1:-1:-1;;;;;95760:26:0;;95787:9;95798:6;95760:26;:45::i;:::-;95827:5;95834:6;95819:22;;;;;;;;;;;95718:134;95920:34;95934:5;95941:4;95947:6;95920:13;:34::i;:::-;95976:76;95985:4;95991:14;96007:12;96021:6;96029:8;96039:12;95976:8;:76::i;:::-;95964:88;;96120:9;96133:1;96120:14;96116:126;;96150:45;-1:-1:-1;;;;;96150:26:0;;96177:9;96188:6;96150:26;:45::i;96116:126::-;96308:51;-1:-1:-1;;;;;96308:29:0;;96338:9;96349;96308:29;:51::i;:::-;94838:1528;;;;;94645:1721;;;;;;;;:::o;33260:304::-;33382:12;33400:9;-1:-1:-1;;;;;33400:14:0;33422:9;33400:36;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;33381:55;;;33514:43;33533:7;:23;;33555:1;33533:23;;;33543:9;33533:23;33514:43;;1964:25:1;;;1952:2;1937:18;33514:43:0;;;;;;;33315:249;33260:304;:::o;15955:150::-;16025:4;16048:50;16053:3;-1:-1:-1;;;;;16073:23:0;;16048:4;:50::i;33968:693::-;34134:1;-1:-1:-1;;;;;34101:35:0;:13;34115:6;34101:21;;;;;;:::i;:::-;;;;;;;;;;;;;;;-1:-1:-1;;;;;34101:21:0;:35;34097:72;;34145:24;;;;;;;;;;;;;;34097:72;34373:18;;34257:6;;22081:1;-1:-1:-1;34369:76:0;;34424:21;;;;;;;;;;;;;;34369:76;34460:9;34455:200;22081:1;34475;:24;34455:200;;;34539:13;;;;;;;;;;;;;;;;;34553:1;34539:16;;;;;;;;:::i;:::-;;;;;;;;;34521:34;;;:11;34533:1;34521:14;;;;;;;;:::i;:::-;;;;;;;:34;34517:68;;34564:21;;;;;;;;;;;;;;34517:68;34627:3;;34455:200;;32351:792;21670:5;32583:10;:28;32579:62;;;32620:21;;;;;;;;;;;;;;32579:62;32721:10;32708;:23;32704:57;;;32740:21;;;;;;;;;;;;;;32704:57;32836:6;32823:10;:19;32819:53;;;32851:21;;;;;;;;;;;;;;32819:53;32905:231;;;;;;;;32939:29;:10;:27;:29::i;:::-;32905:231;;;;;;32994:29;:10;:27;:29::i;:::-;32905:231;;;;;;33049:29;:10;:27;:29::i;:::-;32905:231;;;;;;33100:25;:6;:23;:25::i;:::-;32905:231;;;;;;;-1:-1:-1;;;;;32882:20:0;;;;;;;:13;:20;;;;;;;;;:254;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;;32351:792:0:o;16273:156::-;16346:4;16369:53;16377:3;-1:-1:-1;;;;;16397:23:0;;16369:7;:53::i;8209:187::-;8282:16;8301:6;;-1:-1:-1;;;;;8317:17:0;;;;;;;;;;8349:40;;8301:6;;;;;;;8349:40;;8282:16;8349:40;8272:124;8209:187;:::o;75674:209::-;75753:7;75779:97;75815:8;75825:4;72286:18;;;;;;;;;;;;;;;;;72260:69;;;;;;;;:::i;:::-;;;;;;;;;;;;;72499:30;;;;;;75789:67;;;;;;;;;26208:66:1;26196:79;;26312:2;26308:15;;;;26325:66;26304:88;26300:1;26291:11;;26284:109;26418:2;26409:12;;26402:28;;;;26455:2;26446:12;;26439:28;26492:2;26483:12;;25910:591;75789:67:0;;;;;;;;;;;;;75779:78;;;;;;4707:3;4595:125;16756:115;16819:7;16845:19;16853:3;12371:18;;12289:107;17213:156;17287:7;17337:22;17341:3;17353:5;17337:3;:22::i;81686:706::-;82105:23;82131:69;82159:4;82131:69;;;;;;;;;;;;;;;;;82139:5;-1:-1:-1;;;;;82131:27:0;;;:69;;;;;:::i;:::-;82214:17;;82105:95;;-1:-1:-1;82214:21:0;82210:176;;82309:10;82298:30;;;;;;;;;;;;:::i;:::-;82290:85;;;;-1:-1:-1;;;82290:85:0;;26708:2:1;82290:85:0;;;26690:21:1;26747:2;26727:18;;;26720:30;26786:34;26766:18;;;26759:62;26857:12;26837:18;;;26830:40;26887:19;;82290:85:0;26506:406:1;79391:241:0;79556:68;;-1:-1:-1;;;;;27198:15:1;;;79556:68:0;;;27180:34:1;27250:15;;27230:18;;;27223:43;27282:18;;;27275:34;;;79529:96:0;;79549:5;;79579:27;;27092:18:1;;79556:68:0;26917:398:1;79892:603:0;80247:10;;;80246:62;;-1:-1:-1;80263:39:0;;;;;80287:4;80263:39;;;18809:34:1;-1:-1:-1;;;;;18879:15:1;;;18859:18;;;18852:43;80263:15:0;;;;;18721:18:1;;80263:39:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:44;80246:62;80225:163;;;;-1:-1:-1;;;80225:163:0;;27522:2:1;80225:163:0;;;27504:21:1;27561:2;27541:18;;;27534:30;27600:34;27580:18;;;27573:62;27671:24;27651:18;;;27644:52;27713:19;;80225:163:0;27320:418:1;80225:163:0;80425:62;;-1:-1:-1;;;;;19678:55:1;;80425:62:0;;;19660:74:1;19750:18;;;19743:34;;;80398:90:0;;80418:5;;80448:22;;19633:18:1;;80425:62:0;19486:297:1;72815:799:0;72863:17;73084:21;72286:18;;;;;;;;;;;;;;;;;72260:69;;;;;;;;:::i;:::-;;;;;;;;;;;;;73084:43;;73437:4;73426:8;73420:15;73413:4;73403:8;73399:19;73396:1;73388:54;73375:67;-1:-1:-1;;;;;;73524:23:0;;73520:88;;73570:27;;;;;;;;;;;;;;73520:88;72882:732;72815:799;;;:::o;74047:280::-;74173:23;74269:51;74290:9;74301:6;74309:7;74318:1;74269:20;:51::i;51755:408::-;51866:20;51900:18;51932:16;51962:20;46300:6;52011:10;:17;:39;52007:76;;52059:24;;;;;;;;;;;;;;52007:76;52111:10;52100:56;;;;;;;;;;;;:::i;:::-;52093:63;;;;;;;;51755:408;;;;;:::o;97955:741::-;98260:66;;;28493:4:1;28481:17;;98260:66:0;;;;28463:36:1;;;;98260:66:0;;;;;;;;;;28436:18:1;;;;98260:66:0;;;;;;;;;98283:30;98260:66;;;98231:105;;98032:13;;;;;;-1:-1:-1;;;;;98231:15:0;;;:105;;98260:66;98231:105;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;98189:147;;;;98350:7;:34;;;;;98361:10;:17;98382:2;98361:23;98350:34;98346:344;;;98517:38;:19;98525:10;98517:19;:::i;:::-;4707:3;4595:125;98517:38;98509:46;;98346:344;;;98677:1;98661:18;;98346:344;98047:649;;97955:741;;;;:::o;96504:511::-;96739:85;;;;;29445:4:1;29433:17;;;96739:85:0;;;29415:36:1;29487:17;;29467:18;;;29460:45;29521:18;;;29514:34;;;29564:18;;;29557:34;;;29607:19;;;29600:35;;;96706:17:0;;-1:-1:-1;;;;;96739:23:0;;;;;29387:19:1;;96739:85:0;;;;;;;;;;;;;;;;;;;-1:-1:-1;96739:85:0;;;;;;;;-1:-1:-1;;96739:85:0;;;;;;;;;;;;:::i;:::-;;;96735:274;;-1:-1:-1;96997:1:0;96735:274;;;96902:10;-1:-1:-1;96735:274:0;96504:511;;;;;;;;:::o;10040:404::-;10103:4;12177:19;;;:12;;;:19;;;;;;10119:319;;-1:-1:-1;10161:23:0;;;;;;;;:11;:23;;;;;;;;;;;;;10341:18;;10319:19;;;:12;;;:19;;;;;;:40;;;;10373:11;;10119:319;-1:-1:-1;10422:5:0;10415:12;;4784:194;4848:6;4878:16;4870:24;;4866:76;;;4917:14;;;;;;;;;;;;;;4866:76;-1:-1:-1;4965:5:0;4784:194::o;5042:::-;5106:6;5136:16;5128:24;;5124:76;;;5175:14;;;;;;;;;;;;;;10612:1388;10678:4;10815:19;;;:12;;;:19;;;;;;10849:15;;10845:1149;;11218:21;11242:14;11255:1;11242:10;:14;:::i;:::-;11290:18;;11218:38;;-1:-1:-1;11270:17:0;;11290:22;;11311:1;;11290:22;:::i;:::-;11270:42;;11344:13;11331:9;:26;11327:398;;11377:17;11397:3;:11;;11409:9;11397:22;;;;;;;;:::i;:::-;;;;;;;;;11377:42;;11548:9;11519:3;:11;;11531:13;11519:26;;;;;;;;:::i;:::-;;;;;;;;;;;;:38;;;;11631:23;;;:12;;;:23;;;;;:36;;;11327:398;11803:17;;:3;;:17;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;11895:3;:12;;:19;11908:5;11895:19;;;;;;;;;;;11888:26;;;11936:4;11929:11;;;;;;;10845:1149;11978:5;11971:12;;;;;12738:118;12805:7;12831:3;:11;;12843:5;12831:18;;;;;;;;:::i;:::-;;;;;;;;;12824:25;;12738:118;;;;:::o;57082:223::-;57215:12;57246:52;57268:6;57276:4;57282:1;57285:12;57246:21;:52::i;74855:481::-;75013:23;75237:92;-1:-1:-1;;;;;75286:23:0;;75313:7;75269:52;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;75269:52:0;;;;;;;;;-1:-1:-1;;;;;75237:31:0;;;75323:5;75237:31;:92::i;:::-;75224:105;74855:481;-1:-1:-1;;;;;74855:481:0:o;58169:499::-;58334:12;58391:5;58366:21;:30;;58358:81;;;;-1:-1:-1;;;58358:81:0;;30401:2:1;58358:81:0;;;30383:21:1;30440:2;30420:18;;;30413:30;30479:34;30459:18;;;30452:62;30550:8;30530:18;;;30523:36;30576:19;;58358:81:0;30199:402:1;58358:81:0;-1:-1:-1;;;;;54686:19:0;;;58449:60;;;;-1:-1:-1;;;58449:60:0;;30808:2:1;58449:60:0;;;30790:21:1;30847:2;30827:18;;;30820:30;30886:31;30866:18;;;30859:59;30935:18;;58449:60:0;30606:353:1;58449:60:0;58521:12;58535:23;58562:6;-1:-1:-1;;;;;58562:11:0;58581:5;58588:4;58562:31;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;58520:73;;;;58610:51;58627:7;58636:10;58648:12;58610:16;:51::i;:::-;58603:58;58169:499;-1:-1:-1;;;;;;;58169:499:0:o;57667:254::-;57796:12;57827:87;57849:6;57857:4;57863:5;57827:87;;;;;;;;;;;;;;;;;:21;:87::i;60782:692::-;60928:12;60956:7;60952:516;;;-1:-1:-1;60986:10:0;60979:17;;60952:516;61097:17;;:21;61093:365;;61291:10;61285:17;61351:15;61338:10;61334:2;61330:19;61323:44;61093:365;61430:12;61423:20;;-1:-1:-1;;;61423:20:0;;;;;;;;:::i;-1:-1:-1:-;;;;;;;:::i;:::-;;;;;;;;;;;:::o;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;14:154:1;-1:-1:-1;;;;;93:5:1;89:54;82:5;79:65;69:93;;158:1;155;148:12;173:247;232:6;285:2;273:9;264:7;260:23;256:32;253:52;;;301:1;298;291:12;253:52;340:9;327:23;359:31;384:5;359:31;:::i;425:250::-;510:1;520:113;534:6;531:1;528:13;520:113;;;610:11;;;604:18;591:11;;;584:39;556:2;549:10;520:113;;;-1:-1:-1;;667:1:1;649:16;;642:27;425:250::o;680:330::-;722:3;760:5;754:12;787:6;782:3;775:19;803:76;872:6;865:4;860:3;856:14;849:4;842:5;838:16;803:76;:::i;:::-;924:2;912:15;-1:-1:-1;;908:88:1;899:98;;;;999:4;895:109;;680:330;-1:-1:-1;;680:330:1:o;1015:220::-;1164:2;1153:9;1146:21;1127:4;1184:45;1225:2;1214:9;1210:18;1202:6;1184:45;:::i;1240:118::-;1326:5;1319:13;1312:21;1305:5;1302:32;1292:60;;1348:1;1345;1338:12;1363:450;1437:6;1445;1453;1506:2;1494:9;1485:7;1481:23;1477:32;1474:52;;;1522:1;1519;1512:12;1474:52;1561:9;1548:23;1580:31;1605:5;1580:31;:::i;:::-;1630:5;-1:-1:-1;1682:2:1;1667:18;;1654:32;;-1:-1:-1;1738:2:1;1723:18;;1710:32;1751:30;1710:32;1751:30;:::i;:::-;1800:7;1790:17;;;1363:450;;;;;:::o;2000:388::-;2068:6;2076;2129:2;2117:9;2108:7;2104:23;2100:32;2097:52;;;2145:1;2142;2135:12;2097:52;2184:9;2171:23;2203:31;2228:5;2203:31;:::i;:::-;2253:5;-1:-1:-1;2310:2:1;2295:18;;2282:32;2323:33;2282:32;2323:33;:::i;:::-;2375:7;2365:17;;;2000:388;;;;;:::o;2393:121::-;2478:10;2471:5;2467:22;2460:5;2457:33;2447:61;;2504:1;2501;2494:12;2519:184;2571:77;2568:1;2561:88;2668:4;2665:1;2658:15;2692:4;2689:1;2682:15;2708:334;2779:2;2773:9;2835:2;2825:13;;-1:-1:-1;;2821:86:1;2809:99;;2938:18;2923:34;;2959:22;;;2920:62;2917:88;;;2985:18;;:::i;:::-;3021:2;3014:22;2708:334;;-1:-1:-1;2708:334:1:o;3047:245::-;3095:4;3128:18;3120:6;3117:30;3114:56;;;3150:18;;:::i;:::-;-1:-1:-1;3207:2:1;3195:15;-1:-1:-1;;3191:88:1;3281:4;3187:99;;3047:245::o;3297:462::-;3339:5;3392:3;3385:4;3377:6;3373:17;3369:27;3359:55;;3410:1;3407;3400:12;3359:55;3446:6;3433:20;3477:48;3493:31;3521:2;3493:31;:::i;:::-;3477:48;:::i;:::-;3550:2;3541:7;3534:19;3596:3;3589:4;3584:2;3576:6;3572:15;3568:26;3565:35;3562:55;;;3613:1;3610;3603:12;3562:55;3678:2;3671:4;3663:6;3659:17;3652:4;3643:7;3639:18;3626:55;3726:1;3701:16;;;3719:4;3697:27;3690:38;;;;3705:7;3297:462;-1:-1:-1;;;3297:462:1:o;3764:874::-;3876:6;3884;3892;3900;3908;3916;3969:3;3957:9;3948:7;3944:23;3940:33;3937:53;;;3986:1;3983;3976:12;3937:53;4025:9;4012:23;4044:31;4069:5;4044:31;:::i;:::-;4094:5;-1:-1:-1;4146:2:1;4131:18;;4118:32;;-1:-1:-1;4202:2:1;4187:18;;4174:32;4215:33;4174:32;4215:33;:::i;:::-;4267:7;-1:-1:-1;4321:2:1;4306:18;;4293:32;;-1:-1:-1;4377:3:1;4362:19;;4349:33;4391:32;4349:33;4391:32;:::i;:::-;4442:7;-1:-1:-1;4500:3:1;4485:19;;4472:33;4528:18;4517:30;;4514:50;;;4560:1;4557;4550:12;4514:50;4583:49;4624:7;4615:6;4604:9;4600:22;4583:49;:::i;:::-;4573:59;;;3764:874;;;;;;;;:::o;5129:347::-;5180:8;5190:6;5244:3;5237:4;5229:6;5225:17;5221:27;5211:55;;5262:1;5259;5252:12;5211:55;-1:-1:-1;5285:20:1;;5328:18;5317:30;;5314:50;;;5360:1;5357;5350:12;5314:50;5397:4;5389:6;5385:17;5373:29;;5449:3;5442:4;5433:6;5425;5421:19;5417:30;5414:39;5411:59;;;5466:1;5463;5456:12;5481:1049;5597:6;5605;5613;5621;5629;5637;5690:3;5678:9;5669:7;5665:23;5661:33;5658:53;;;5707:1;5704;5697:12;5658:53;5747:9;5734:23;5776:18;5817:2;5809:6;5806:14;5803:34;;;5833:1;5830;5823:12;5803:34;5872:58;5922:7;5913:6;5902:9;5898:22;5872:58;:::i;:::-;5949:8;;-1:-1:-1;5846:84:1;-1:-1:-1;6037:2:1;6022:18;;6009:32;;-1:-1:-1;6053:16:1;;;6050:36;;;6082:1;6079;6072:12;6050:36;6121:60;6173:7;6162:8;6151:9;6147:24;6121:60;:::i;:::-;6200:8;;-1:-1:-1;6095:86:1;-1:-1:-1;6285:2:1;6270:18;;6257:32;;-1:-1:-1;6298:30:1;6257:32;6298:30;:::i;:::-;6347:5;;-1:-1:-1;6405:2:1;6390:18;;6377:32;;6421:16;;;6418:36;;;6450:1;6447;6440:12;6418:36;;6473:51;6516:7;6505:8;6494:9;6490:24;6473:51;:::i;6535:731::-;6649:6;6657;6665;6673;6681;6689;6742:3;6730:9;6721:7;6717:23;6713:33;6710:53;;;6759:1;6756;6749:12;6710:53;6799:9;6786:23;6832:18;6824:6;6821:30;6818:50;;;6864:1;6861;6854:12;6818:50;6887:49;6928:7;6919:6;6908:9;6904:22;6887:49;:::i;:::-;6877:59;;;6986:2;6975:9;6971:18;6958:32;6999:31;7024:5;6999:31;:::i;:::-;6535:731;;7049:5;;-1:-1:-1;;;;7101:2:1;7086:18;;7073:32;;7152:2;7137:18;;7124:32;;7203:3;7188:19;;7175:33;;-1:-1:-1;7255:3:1;7240:19;;;7227:33;;-1:-1:-1;6535:731:1:o;7271:521::-;7366:6;7374;7382;7390;7398;7451:3;7439:9;7430:7;7426:23;7422:33;7419:53;;;7468:1;7465;7458:12;7419:53;7507:9;7494:23;7526:31;7551:5;7526:31;:::i;:::-;7576:5;7628:2;7613:18;;7600:32;;-1:-1:-1;7679:2:1;7664:18;;7651:32;;7730:2;7715:18;;7702:32;;-1:-1:-1;7781:3:1;7766:19;7753:33;;-1:-1:-1;7271:521:1;-1:-1:-1;;;7271:521:1:o;7797:180::-;7856:6;7909:2;7897:9;7888:7;7884:23;7880:32;7877:52;;;7925:1;7922;7915:12;7877:52;-1:-1:-1;7948:23:1;;7797:180;-1:-1:-1;7797:180:1:o;8815:1174::-;9013:4;9042:2;9082;9071:9;9067:18;9112:2;9101:9;9094:21;9135:6;9170;9164:13;9201:6;9193;9186:22;9227:2;9217:12;;9260:2;9249:9;9245:18;9238:25;;9322:2;9312:6;9309:1;9305:14;9294:9;9290:30;9286:39;9360:2;9352:6;9348:15;9381:1;9391:569;9405:6;9402:1;9399:13;9391:569;;;9494:66;9482:9;9474:6;9470:22;9466:95;9461:3;9454:108;9591:6;9585:13;9637:2;9631:9;9668:2;9660:6;9653:18;9698:48;9742:2;9734:6;9730:15;9716:12;9698:48;:::i;:::-;9793:11;;;9787:18;-1:-1:-1;;;;;9783:67:1;9766:15;;;9759:92;;;;9938:12;;;;9684:62;-1:-1:-1;9903:15:1;;;;9427:1;9420:9;9391:569;;;-1:-1:-1;9977:6:1;;8815:1174;-1:-1:-1;;;;;;;;8815:1174:1:o;9994:321::-;10063:6;10116:2;10104:9;10095:7;10091:23;10087:32;10084:52;;;10132:1;10129;10122:12;10084:52;10172:9;10159:23;10205:18;10197:6;10194:30;10191:50;;;10237:1;10234;10227:12;10191:50;10260:49;10301:7;10292:6;10281:9;10277:22;10260:49;:::i;11110:454::-;11186:6;11194;11202;11255:2;11243:9;11234:7;11230:23;11226:32;11223:52;;;11271:1;11268;11261:12;11223:52;11307:9;11294:23;11284:33;;11367:2;11356:9;11352:18;11339:32;11380:30;11404:5;11380:30;:::i;:::-;11429:5;-1:-1:-1;11486:2:1;11471:18;;11458:32;11499:33;11458:32;11499:33;:::i;11569:386::-;11636:6;11644;11697:2;11685:9;11676:7;11672:23;11668:32;11665:52;;;11713:1;11710;11703:12;11665:52;11752:9;11739:23;11771:30;11795:5;11771:30;:::i;11960:437::-;12039:1;12035:12;;;;12082;;;12103:61;;12157:4;12149:6;12145:17;12135:27;;12103:61;12210:2;12202:6;12199:14;12179:18;12176:38;12173:218;;12247:77;12244:1;12237:88;12348:4;12345:1;12338:15;12376:4;12373:1;12366:15;12763:175;12841:13;;12894:18;12883:30;;12873:41;;12863:69;;12928:1;12925;12918:12;12863:69;12763:175;;;:::o;12943:206::-;13012:6;13065:2;13053:9;13044:7;13040:23;13036:32;13033:52;;;13081:1;13078;13071:12;13033:52;13104:39;13133:9;13104:39;:::i;13686:664::-;13969:6;13958:9;13951:25;14024:18;14016:6;14012:31;14007:2;13996:9;13992:18;13985:59;-1:-1:-1;;;;;14084:6:1;14080:55;14075:2;14064:9;14060:18;14053:83;14172:6;14167:2;14156:9;14152:18;14145:34;14228:10;14220:6;14216:23;14210:3;14199:9;14195:19;14188:52;14277:3;14271;14260:9;14256:19;14249:32;13932:4;14298:46;14339:3;14328:9;14324:19;14316:6;14298:46;:::i;:::-;14290:54;13686:664;-1:-1:-1;;;;;;;;13686:664:1:o;15166:545::-;15268:2;15263:3;15260:11;15257:448;;;15304:1;15329:5;15325:2;15318:17;15374:4;15370:2;15360:19;15444:2;15432:10;15428:19;15425:1;15421:27;15415:4;15411:38;15480:4;15468:10;15465:20;15462:47;;;-1:-1:-1;15503:4:1;15462:47;15558:2;15553:3;15549:12;15546:1;15542:20;15536:4;15532:31;15522:41;;15613:82;15631:2;15624:5;15621:13;15613:82;;;15676:17;;;15657:1;15646:13;15613:82;;15947:1471;16073:3;16067:10;16100:18;16092:6;16089:30;16086:56;;;16122:18;;:::i;:::-;16151:97;16241:6;16201:38;16233:4;16227:11;16201:38;:::i;:::-;16195:4;16151:97;:::i;:::-;16303:4;;16367:2;16356:14;;16384:1;16379:782;;;;17205:1;17222:6;17219:89;;;-1:-1:-1;17274:19:1;;;17268:26;17219:89;-1:-1:-1;;15844:1:1;15840:11;;;15836:84;15832:89;15822:100;15928:1;15924:11;;;15819:117;17321:81;;16349:1063;;16379:782;15113:1;15106:14;;;15150:4;15137:18;;-1:-1:-1;;16415:79:1;;;16592:236;16606:7;16603:1;16600:14;16592:236;;;16695:19;;;16689:26;16674:42;;16787:27;;;;16755:1;16743:14;;;;16622:19;;16592:236;;;16596:3;16856:6;16847:7;16844:19;16841:261;;;16917:19;;;16911:26;-1:-1:-1;;17000:1:1;16996:14;;;17012:3;16992:24;16988:97;16984:102;16969:118;16954:134;;16841:261;-1:-1:-1;;;;;17148:1:1;17132:14;;;17128:22;17115:36;;-1:-1:-1;15947:1471:1:o;17423:289::-;17554:3;17592:6;17586:13;17608:66;17667:6;17662:3;17655:4;17647:6;17643:17;17608:66;:::i;:::-;17690:16;;;;;17423:289;-1:-1:-1;;17423:289:1:o;17717:184::-;17769:77;17766:1;17759:88;17866:4;17863:1;17856:15;17890:4;17887:1;17880:15;17906:274;17946:1;17972;17962:189;;18007:77;18004:1;17997:88;18108:4;18105:1;18098:15;18136:4;18133:1;18126:15;17962:189;-1:-1:-1;18165:9:1;;17906:274::o;18185:184::-;18237:77;18234:1;18227:88;18334:4;18331:1;18324:15;18358:4;18355:1;18348:15;18374:195;18413:3;-1:-1:-1;;18437:5:1;18434:77;18431:103;;18514:18;;:::i;:::-;-1:-1:-1;18561:1:1;18550:13;;18374:195::o;19313:168::-;19386:9;;;19417;;19434:15;;;19428:22;;19414:37;19404:71;;19455:18;;:::i;19788:184::-;19858:6;19911:2;19899:9;19890:7;19886:23;19882:32;19879:52;;;19927:1;19924;19917:12;19879:52;-1:-1:-1;19950:16:1;;19788:184;-1:-1:-1;19788:184:1:o;19977:128::-;20044:9;;;20065:11;;;20062:37;;;20079:18;;:::i;20695:379::-;20888:2;20877:9;20870:21;20851:4;20914:45;20955:2;20944:9;20940:18;20932:6;20914:45;:::i;:::-;21007:9;20999:6;20995:22;20990:2;20979:9;20975:18;20968:50;21035:33;21061:6;21053;21035:33;:::i;21079:125::-;21144:9;;;21165:10;;;21162:36;;;21178:18;;:::i;21209:441::-;21262:5;21315:3;21308:4;21300:6;21296:17;21292:27;21282:55;;21333:1;21330;21323:12;21282:55;21362:6;21356:13;21393:48;21409:31;21437:2;21409:31;:::i;21393:48::-;21466:2;21457:7;21450:19;21512:3;21505:4;21500:2;21492:6;21488:15;21484:26;21481:35;21478:55;;;21529:1;21526;21519:12;21478:55;21542:77;21616:2;21609:4;21600:7;21596:18;21589:4;21581:6;21577:17;21542:77;:::i;21655:558::-;21752:6;21760;21813:2;21801:9;21792:7;21788:23;21784:32;21781:52;;;21829:1;21826;21819:12;21781:52;21862:9;21856:16;21891:18;21932:2;21924:6;21921:14;21918:34;;;21948:1;21945;21938:12;21918:34;21971:60;22023:7;22014:6;22003:9;21999:22;21971:60;:::i;:::-;21961:70;;22077:2;22066:9;22062:18;22056:25;22040:41;;22106:2;22096:8;22093:16;22090:36;;;22122:1;22119;22112:12;22090:36;;22145:62;22199:7;22188:8;22177:9;22173:24;22145:62;:::i;:::-;22135:72;;;21655:558;;;;;:::o;22218:679::-;22338:6;22346;22354;22362;22370;22423:3;22411:9;22402:7;22398:23;22394:33;22391:53;;;22440:1;22437;22430:12;22391:53;22472:9;22466:16;22491:30;22515:5;22491:30;:::i;:::-;22540:5;-1:-1:-1;22564:48:1;22608:2;22593:18;;22564:48;:::i;:::-;22554:58;;22657:2;22646:9;22642:18;22636:25;22670:33;22695:7;22670:33;:::i;:::-;22769:2;22754:18;;22748:25;22818:3;22803:19;;22797:26;22722:7;;-1:-1:-1;22748:25:1;-1:-1:-1;22832:33:1;22797:26;22832:33;:::i;:::-;22884:7;22874:17;;;22218:679;;;;;;;;:::o;22902:325::-;22990:6;22985:3;22978:19;23042:6;23035:5;23028:4;23023:3;23019:14;23006:43;;23094:1;23087:4;23078:6;23073:3;23069:16;23065:27;23058:38;22960:3;23216:4;-1:-1:-1;;23141:2:1;23133:6;23129:15;23125:88;23120:3;23116:98;23112:109;23105:116;;22902:325;;;;:::o;23232:431::-;23445:2;23434:9;23427:21;23408:4;23471:61;23528:2;23517:9;23513:18;23505:6;23497;23471:61;:::i;:::-;23580:9;23572:6;23568:22;23563:2;23552:9;23548:18;23541:50;23608:49;23650:6;23642;23634;23608:49;:::i;23668:245::-;23735:6;23788:2;23776:9;23767:7;23763:23;23759:32;23756:52;;;23804:1;23801;23794:12;23756:52;23836:9;23830:16;23855:28;23877:5;23855:28;:::i;23918:251::-;23988:6;24041:2;24029:9;24020:7;24016:23;24012:32;24009:52;;;24057:1;24054;24047:12;24009:52;24089:9;24083:16;24108:31;24133:5;24108:31;:::i;25196:709::-;25557:66;25552:3;25545:79;25527:3;25653:6;25647:13;25669:74;25736:6;25732:1;25727:3;25723:11;25716:4;25708:6;25704:17;25669:74;:::i;:::-;25806:66;25802:1;25762:16;;;;25794:10;;;25787:86;-1:-1:-1;25897:1:1;25889:10;;25196:709;-1:-1:-1;25196:709:1:o;27743:160::-;27820:13;;27873:4;27862:16;;27852:27;;27842:55;;27893:1;27890;27883:12;27908:408;28001:6;28009;28017;28025;28078:3;28066:9;28057:7;28053:23;28049:33;28046:53;;;28095:1;28092;28085:12;28046:53;28118:38;28146:9;28118:38;:::i;:::-;28108:48;;28175:47;28218:2;28207:9;28203:18;28175:47;:::i;:::-;28262:2;28247:18;;28241:25;28306:2;28291:18;;;28285:25;27908:408;;28165:57;;-1:-1:-1;27908:408:1;-1:-1:-1;;;27908:408:1:o;28802:357::-;28920:12;;28967:4;28956:16;;;28950:23;;28920:12;28985:16;;28982:171;;;-1:-1:-1;;29059:4:1;29055:17;;;;29052:1;29048:25;29044:98;29033:110;;28802:357;-1:-1:-1;28802:357:1:o;29646:184::-;29698:77;29695:1;29688:88;29795:4;29792:1;29785:15;29819:4;29816:1;29809:15;29835:359;30022:6;30017:3;30010:19;29992:3;30058:6;30052:13;30074:73;30140:6;30135:2;30130:3;30126:12;30121:2;30113:6;30109:15;30074:73;:::i;:::-;30167:16;;;;30185:2;30163:25;;29835:359;-1:-1:-1;;;29835:359:1:o","abiDefinition":[{"inputs":[{"internalType":"contract ITokenMessenger","name":"tokenMessenger_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[],"name":"CCTPGasRescueFailed","type":"error"},{"inputs":[],"name":"CCTPIncorrectChainId","type":"error"},{"inputs":[],"name":"CCTPIncorrectConfig","type":"error"},{"inputs":[],"name":"CCTPIncorrectDomain","type":"error"},{"inputs":[],"name":"CCTPIncorrectGasAmount","type":"error"},{"inputs":[],"name":"CCTPIncorrectProtocolFee","type":"error"},{"inputs":[],"name":"CCTPInsufficientAmount","type":"error"},{"inputs":[],"name":"CCTPMessageNotReceived","type":"error"},{"inputs":[],"name":"CCTPSymbolAlreadyAdded","type":"error"},{"inputs":[],"name":"CCTPSymbolIncorrect","type":"error"},{"inputs":[],"name":"CCTPTokenAlreadyAdded","type":"error"},{"inputs":[],"name":"CCTPTokenNotFound","type":"error"},{"inputs":[],"name":"CCTPZeroAddress","type":"error"},{"inputs":[],"name":"CCTPZeroAmount","type":"error"},{"inputs":[],"name":"CastOverflow","type":"error"},{"inputs":[],"name":"ForwarderDeploymentFailed","type":"error"},{"inputs":[],"name":"IncorrectRequestLength","type":"error"},{"inputs":[],"name":"RemoteCCTPDeploymentNotSet","type":"error"},{"inputs":[],"name":"UnknownRequestVersion","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ChainGasAirdropped","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"chainGasAmount","type":"uint256"}],"name":"ChainGasAmountUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"address","name":"mintToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"fee","type":"uint256"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"requestID","type":"bytes32"}],"name":"CircleRequestFulfilled","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":false,"internalType":"uint64","name":"nonce","type":"uint64"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint32","name":"requestVersion","type":"uint32"},{"indexed":false,"internalType":"bytes","name":"formattedRequest","type":"bytes"},{"indexed":true,"internalType":"bytes32","name":"requestID","type":"bytes32"}],"name":"CircleRequestSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"feeCollector","type":"address"},{"indexed":false,"internalType":"uint256","name":"relayerFeeAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"protocolFeeAmount","type":"uint256"}],"name":"FeeCollected","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"address","name":"oldFeeCollector","type":"address"},{"indexed":false,"internalType":"address","name":"newFeeCollector","type":"address"}],"name":"FeeCollectorUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newProtocolFee","type":"uint256"}],"name":"ProtocolFeeUpdated","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"accumulatedFees","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"relayerFee","type":"uint256"},{"internalType":"uint256","name":"minBaseFee","type":"uint256"},{"internalType":"uint256","name":"minSwapFee","type":"uint256"},{"internalType":"uint256","name":"maxFee","type":"uint256"}],"name":"addToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bool","name":"isSwap","type":"bool"}],"name":"calculateFeeAmount","outputs":[{"internalType":"uint256","name":"fee","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"chainGasAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"circleTokenPool","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"feeStructures","outputs":[{"internalType":"uint40","name":"relayerFee","type":"uint40"},{"internalType":"uint72","name":"minBaseFee","type":"uint72"},{"internalType":"uint72","name":"minSwapFee","type":"uint72"},{"internalType":"uint72","name":"maxFee","type":"uint72"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getBridgeTokens","outputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct BridgeToken[]","name":"bridgeTokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"address","name":"remoteToken","type":"address"}],"name":"getLocalToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"requestID","type":"bytes32"}],"name":"isRequestFulfilled","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"localDomain","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"messageTransmitter","outputs":[{"internalType":"contract IMessageTransmitter","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"protocolFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"message","type":"bytes"},{"internalType":"bytes","name":"signature","type":"bytes"},{"internalType":"uint32","name":"requestVersion","type":"uint32"},{"internalType":"bytes","name":"formattedRequest","type":"bytes"}],"name":"receiveCircleToken","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"relayerFeeCollectors","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"remoteDomainConfig","outputs":[{"internalType":"uint32","name":"domain","type":"uint32"},{"internalType":"address","name":"synapseCCTP","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"removeToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"rescueGas","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"recipient","type":"address"},{"internalType":"uint256","name":"chainId","type":"uint256"},{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"uint32","name":"requestVersion","type":"uint32"},{"internalType":"bytes","name":"swapParams","type":"bytes"}],"name":"sendCircleToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"newChainGasAmount","type":"uint256"}],"name":"setChainGasAmount","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"circleToken","type":"address"},{"internalType":"address","name":"pool","type":"address"}],"name":"setCircleTokenPool","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"feeCollector","type":"address"}],"name":"setFeeCollector","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"newProtocolFee","type":"uint256"}],"name":"setProtocolFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"remoteChainId","type":"uint256"},{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"address","name":"remoteSynapseCCTP","type":"address"}],"name":"setRemoteDomainConfig","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"relayerFee","type":"uint256"},{"internalType":"uint256","name":"minBaseFee","type":"uint256"},{"internalType":"uint256","name":"minSwapFee","type":"uint256"},{"internalType":"uint256","name":"maxFee","type":"uint256"}],"name":"setTokenFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"","type":"string"}],"name":"symbolToToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"tokenMessenger","outputs":[{"internalType":"contract ITokenMessenger","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"tokenToSymbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"withdrawProtocolFees","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"withdrawRelayerFees","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"events":{"ChainGasAirdropped(uint256)":{"notice":"Emitted when the native chain gas is airdropped to a recipient"},"ChainGasAmountUpdated(uint256)":{"notice":"Emitted when the amount of native gas airdropped to recipients is updated"},"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)":{"notice":"Emitted when a Circle token is received with an attached action request."},"CircleRequestSent(uint256,uint64,address,uint256,uint32,bytes,bytes32)":{"notice":"Emitted when a Circle token is sent with an attached action request."},"FeeCollected(address,uint256,uint256)":{"notice":"Emitted when the fee for relaying a CCTP message is collected"},"FeeCollectorUpdated(address,address,address)":{"notice":"Emitted when the fee collector is updated for a relayer"},"ProtocolFeeUpdated(uint256)":{"notice":"Emitted when the protocol fee is updated"}},"kind":"user","methods":{"accumulatedFees(address,address)":{"notice":"Maps fee collector address into accumulated fees for a token (feeCollector =\u003e (token =\u003e amount))"},"addToken(string,address,uint256,uint256,uint256,uint256)":{"notice":"Adds a new token to the list of supported tokens, with the given symbol and fee structure."},"calculateFeeAmount(address,uint256,bool)":{"notice":"Calculates the fee amount for bridging a token to this chain using CCTP."},"chainGasAmount()":{"notice":"Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request"},"feeStructures(address)":{"notice":"Maps bridge token address into CCTP fee structure"},"getBridgeTokens()":{"notice":"Returns the list of all supported bridge tokens and their symbols."},"getLocalToken(uint32,address)":{"notice":"Get the local token associated with the given remote domain and token."},"isRequestFulfilled(bytes32)":{"notice":"Checks if the given request is already fulfilled."},"localDomain()":{"notice":"Refers to the local domain number used in CCTP messages."},"protocolFee()":{"notice":"Protocol fee: percentage of the relayer fee that is collected by the Protocol"},"receiveCircleToken(bytes,bytes,uint32,bytes)":{"notice":"Receive  Circle token supported by CCTP with the request for the action to take."},"relayerFeeCollectors(address)":{"notice":"Maps Relayer address into collector address for accumulated Relayer's fees"},"removeToken(address)":{"notice":"Removes a token from the list of supported tokens."},"rescueGas()":{"notice":"Allows to rescue stuck gas from the contract."},"sendCircleToken(address,uint256,address,uint256,uint32,bytes)":{"notice":"Send a Circle token supported by CCTP to a given chain with the request for the action to take on the destination chain."},"setChainGasAmount(uint256)":{"notice":"Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request."},"setCircleTokenPool(address,address)":{"notice":"Sets the liquidity pool for the given Circle token."},"setFeeCollector(address)":{"notice":"Allows the Relayer to set a fee collector for accumulated fees. - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector. - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector."},"setProtocolFee(uint256)":{"notice":"Sets a new protocol fee."},"setRemoteDomainConfig(uint256,uint32,address)":{"notice":"Sets the remote domain and deployment of SynapseCCTP for the given remote chainId."},"setTokenFee(address,uint256,uint256,uint256,uint256)":{"notice":"Updates the fee structure for a supported Circle token."},"symbolToToken(string)":{"notice":"Maps bridge token symbol into bridge token address"},"tokenToSymbol(address)":{"notice":"Maps bridge token address into bridge token symbol"},"withdrawProtocolFees(address)":{"notice":"Allows the owner to withdraw accumulated protocol fees."},"withdrawRelayerFees(address)":{"notice":"Allows the Relayer's fee collector to withdraw accumulated relayer fees."}},"version":1},"developerDoc":{"kind":"dev","methods":{"addToken(string,address,uint256,uint256,uint256,uint256)":{"details":"The symbol must start with \"CCTP.\"","params":{"maxFee":"Maximum fee for bridging a token to this chain","minBaseFee":"Minimum fee for bridging a token to this chain using a base request","minSwapFee":"Minimum fee for bridging a token to this chain using a swap request","relayerFee":"Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`","symbol":"Symbol of the token","token":"Address of the token"}},"calculateFeeAmount(address,uint256,bool)":{"details":"Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.","params":{"amount":"Amount of the Circle tokens to be bridged to this chain","isSwap":"Whether the request is a swap request","token":"Address of the Circle token"},"returns":{"fee":"        Fee amount"}},"owner()":{"details":"Returns the address of the current owner."},"receiveCircleToken(bytes,bytes,uint32,bytes)":{"details":"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on this chain.The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function, or the call will revert.","params":{"formattedRequest":"Formatted request for the action to take on this chain","message":"Message raw bytes emitted by CCTP MessageTransmitter on origin chain","requestVersion":"Version of the request format","signature":"Circle's attestation for the message obtained from Circle's API"}},"removeToken(address)":{"details":"Will revert if the token is not supported."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"sendCircleToken(address,uint256,address,uint256,uint32,bytes)":{"details":"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on the destination chain. `chainId` refers to value from EIP-155 (block.chainid).","params":{"amount":"Amount of tokens to burn","burnToken":"Address of Circle token to burn","chainId":"Chain ID of the destination chain","recipient":"Recipient of the tokens on destination chain","requestVersion":"Version of the request format","swapParams":"Swap parameters for the action to take on the destination chain (could be empty)"}},"setFeeCollector(address)":{"details":"Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol."},"setProtocolFee(uint256)":{"details":"The protocol fee is a percentage of the relayer fee that is collected by the Protocol.","params":{"newProtocolFee":"New protocol fee, multiplied by `FEE_DENOMINATOR`"}},"setTokenFee(address,uint256,uint256,uint256,uint256)":{"details":"Will revert if the token is not supported.","params":{"maxFee":"Maximum fee for bridging a token to this chain","minBaseFee":"Minimum fee for bridging a token to this chain using a base request","minSwapFee":"Minimum fee for bridging a token to this chain using a swap request","relayerFee":"Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`","token":"Address of the token"}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract ITokenMessenger\",\"name\":\"tokenMessenger_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"CCTPGasRescueFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPIncorrectChainId\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPIncorrectConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPIncorrectDomain\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPIncorrectGasAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPIncorrectProtocolFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPInsufficientAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPMessageNotReceived\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPSymbolAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPSymbolIncorrect\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPTokenAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPTokenNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPZeroAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CastOverflow\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ForwarderDeploymentFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"IncorrectRequestLength\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"RemoteCCTPDeploymentNotSet\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnknownRequestVersion\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ChainGasAirdropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainGasAmount\",\"type\":\"uint256\"}],\"name\":\"ChainGasAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestID\",\"type\":\"bytes32\"}],\"name\":\"CircleRequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"formattedRequest\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestID\",\"type\":\"bytes32\"}],\"name\":\"CircleRequestSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"relayerFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"FeeCollectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProtocolFee\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accumulatedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSwap\",\"type\":\"bool\"}],\"name\":\"calculateFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainGasAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"circleTokenPool\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeStructures\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"relayerFee\",\"type\":\"uint40\"},{\"internalType\":\"uint72\",\"name\":\"minBaseFee\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"minSwapFee\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"maxFee\",\"type\":\"uint72\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBridgeTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct BridgeToken[]\",\"name\":\"bridgeTokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"remoteToken\",\"type\":\"address\"}],\"name\":\"getLocalToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestID\",\"type\":\"bytes32\"}],\"name\":\"isRequestFulfilled\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localDomain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageTransmitter\",\"outputs\":[{\"internalType\":\"contract IMessageTransmitter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"signature\",\"type\":\"bytes\"},{\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"formattedRequest\",\"type\":\"bytes\"}],\"name\":\"receiveCircleToken\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"relayerFeeCollectors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"remoteDomainConfig\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"synapseCCTP\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"swapParams\",\"type\":\"bytes\"}],\"name\":\"sendCircleToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newChainGasAmount\",\"type\":\"uint256\"}],\"name\":\"setChainGasAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"circleToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"}],\"name\":\"setCircleTokenPool\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newProtocolFee\",\"type\":\"uint256\"}],\"name\":\"setProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"remoteChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"remoteSynapseCCTP\",\"type\":\"address\"}],\"name\":\"setRemoteDomainConfig\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"}],\"name\":\"setTokenFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"symbolToToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tokenMessenger\",\"outputs\":[{\"internalType\":\"contract ITokenMessenger\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenToSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawProtocolFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"withdrawRelayerFees\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addToken(string,address,uint256,uint256,uint256,uint256)\":{\"details\":\"The symbol must start with \\\"CCTP.\\\"\",\"params\":{\"maxFee\":\"Maximum fee for bridging a token to this chain\",\"minBaseFee\":\"Minimum fee for bridging a token to this chain using a base request\",\"minSwapFee\":\"Minimum fee for bridging a token to this chain using a swap request\",\"relayerFee\":\"Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\",\"symbol\":\"Symbol of the token\",\"token\":\"Address of the token\"}},\"calculateFeeAmount(address,uint256,bool)\":{\"details\":\"Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\",\"params\":{\"amount\":\"Amount of the Circle tokens to be bridged to this chain\",\"isSwap\":\"Whether the request is a swap request\",\"token\":\"Address of the Circle token\"},\"returns\":{\"fee\":\"        Fee amount\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"receiveCircleToken(bytes,bytes,uint32,bytes)\":{\"details\":\"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on this chain.The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function, or the call will revert.\",\"params\":{\"formattedRequest\":\"Formatted request for the action to take on this chain\",\"message\":\"Message raw bytes emitted by CCTP MessageTransmitter on origin chain\",\"requestVersion\":\"Version of the request format\",\"signature\":\"Circle's attestation for the message obtained from Circle's API\"}},\"removeToken(address)\":{\"details\":\"Will revert if the token is not supported.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"sendCircleToken(address,uint256,address,uint256,uint32,bytes)\":{\"details\":\"The request is a bytes array containing information about the end recipient of the tokens, as well as an optional swap action to take on the destination chain. `chainId` refers to value from EIP-155 (block.chainid).\",\"params\":{\"amount\":\"Amount of tokens to burn\",\"burnToken\":\"Address of Circle token to burn\",\"chainId\":\"Chain ID of the destination chain\",\"recipient\":\"Recipient of the tokens on destination chain\",\"requestVersion\":\"Version of the request format\",\"swapParams\":\"Swap parameters for the action to take on the destination chain (could be empty)\"}},\"setFeeCollector(address)\":{\"details\":\"Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\"},\"setProtocolFee(uint256)\":{\"details\":\"The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\",\"params\":{\"newProtocolFee\":\"New protocol fee, multiplied by `FEE_DENOMINATOR`\"}},\"setTokenFee(address,uint256,uint256,uint256,uint256)\":{\"details\":\"Will revert if the token is not supported.\",\"params\":{\"maxFee\":\"Maximum fee for bridging a token to this chain\",\"minBaseFee\":\"Minimum fee for bridging a token to this chain using a base request\",\"minSwapFee\":\"Minimum fee for bridging a token to this chain using a swap request\",\"relayerFee\":\"Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\",\"token\":\"Address of the token\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"events\":{\"ChainGasAirdropped(uint256)\":{\"notice\":\"Emitted when the native chain gas is airdropped to a recipient\"},\"ChainGasAmountUpdated(uint256)\":{\"notice\":\"Emitted when the amount of native gas airdropped to recipients is updated\"},\"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)\":{\"notice\":\"Emitted when a Circle token is received with an attached action request.\"},\"CircleRequestSent(uint256,uint64,address,uint256,uint32,bytes,bytes32)\":{\"notice\":\"Emitted when a Circle token is sent with an attached action request.\"},\"FeeCollected(address,uint256,uint256)\":{\"notice\":\"Emitted when the fee for relaying a CCTP message is collected\"},\"FeeCollectorUpdated(address,address,address)\":{\"notice\":\"Emitted when the fee collector is updated for a relayer\"},\"ProtocolFeeUpdated(uint256)\":{\"notice\":\"Emitted when the protocol fee is updated\"}},\"kind\":\"user\",\"methods\":{\"accumulatedFees(address,address)\":{\"notice\":\"Maps fee collector address into accumulated fees for a token (feeCollector =\u003e (token =\u003e amount))\"},\"addToken(string,address,uint256,uint256,uint256,uint256)\":{\"notice\":\"Adds a new token to the list of supported tokens, with the given symbol and fee structure.\"},\"calculateFeeAmount(address,uint256,bool)\":{\"notice\":\"Calculates the fee amount for bridging a token to this chain using CCTP.\"},\"chainGasAmount()\":{\"notice\":\"Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\"},\"feeStructures(address)\":{\"notice\":\"Maps bridge token address into CCTP fee structure\"},\"getBridgeTokens()\":{\"notice\":\"Returns the list of all supported bridge tokens and their symbols.\"},\"getLocalToken(uint32,address)\":{\"notice\":\"Get the local token associated with the given remote domain and token.\"},\"isRequestFulfilled(bytes32)\":{\"notice\":\"Checks if the given request is already fulfilled.\"},\"localDomain()\":{\"notice\":\"Refers to the local domain number used in CCTP messages.\"},\"protocolFee()\":{\"notice\":\"Protocol fee: percentage of the relayer fee that is collected by the Protocol\"},\"receiveCircleToken(bytes,bytes,uint32,bytes)\":{\"notice\":\"Receive  Circle token supported by CCTP with the request for the action to take.\"},\"relayerFeeCollectors(address)\":{\"notice\":\"Maps Relayer address into collector address for accumulated Relayer's fees\"},\"removeToken(address)\":{\"notice\":\"Removes a token from the list of supported tokens.\"},\"rescueGas()\":{\"notice\":\"Allows to rescue stuck gas from the contract.\"},\"sendCircleToken(address,uint256,address,uint256,uint32,bytes)\":{\"notice\":\"Send a Circle token supported by CCTP to a given chain with the request for the action to take on the destination chain.\"},\"setChainGasAmount(uint256)\":{\"notice\":\"Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\"},\"setCircleTokenPool(address,address)\":{\"notice\":\"Sets the liquidity pool for the given Circle token.\"},\"setFeeCollector(address)\":{\"notice\":\"Allows the Relayer to set a fee collector for accumulated fees. - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector. - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\"},\"setProtocolFee(uint256)\":{\"notice\":\"Sets a new protocol fee.\"},\"setRemoteDomainConfig(uint256,uint32,address)\":{\"notice\":\"Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\"},\"setTokenFee(address,uint256,uint256,uint256,uint256)\":{\"notice\":\"Updates the fee structure for a supported Circle token.\"},\"symbolToToken(string)\":{\"notice\":\"Maps bridge token symbol into bridge token address\"},\"tokenToSymbol(address)\":{\"notice\":\"Maps bridge token address into bridge token symbol\"},\"withdrawProtocolFees(address)\":{\"notice\":\"Allows the owner to withdraw accumulated protocol fees.\"},\"withdrawRelayerFees(address)\":{\"notice\":\"Allows the Relayer's fee collector to withdraw accumulated relayer fees.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"SynapseCCTP\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{"accumulatedFees(address,address)":"d4a67c6d","addToken(string,address,uint256,uint256,uint256,uint256)":"4a85178d","calculateFeeAmount(address,uint256,bool)":"0d25aafe","chainGasAmount()":"e00a83e0","circleTokenPool(address)":"a4b1d034","feeStructures(address)":"dc72495b","getBridgeTokens()":"9c1d060e","getLocalToken(uint32,address)":"f879a41a","isRequestFulfilled(bytes32)":"92a442ea","localDomain()":"8d3638f4","messageTransmitter()":"7b04c181","owner()":"8da5cb5b","protocolFee()":"b0e21e8a","receiveCircleToken(bytes,bytes,uint32,bytes)":"4a5ae51d","relayerFeeCollectors(address)":"41f355ee","remoteDomainConfig(uint256)":"e9259ab9","removeToken(address)":"5fa7b584","renounceOwnership()":"715018a6","rescueGas()":"40432d51","sendCircleToken(address,uint256,address,uint256,uint32,bytes)":"304ddb4c","setChainGasAmount(uint256)":"b250fe6b","setCircleTokenPool(address,address)":"2cc9e7e5","setFeeCollector(address)":"a42dce80","setProtocolFee(uint256)":"787dce3d","setRemoteDomainConfig(uint256,uint32,address)":"e9bbb36d","setTokenFee(address,uint256,uint256,uint256,uint256)":"4bdb4eed","symbolToToken(string)":"a5bc29c2","tokenMessenger()":"46117830","tokenToSymbol(address)":"0ba36121","transferOwnership(address)":"f2fde38b","withdrawProtocolFees(address)":"2d80caa5","withdrawRelayerFees(address)":"f7265b3a"}},"solidity/SynapseCCTP.sol:SynapseCCTPEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"recipient","type":"address"},{"indexed":false,"internalType":"address","name":"mintToken","type":"address"},{"indexed":false,"internalType":"uint256","name":"fee","type":"uint256"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":true,"internalType":"bytes32","name":"requestID","type":"bytes32"}],"name":"CircleRequestFulfilled","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"chainId","type":"uint256"},{"indexed":false,"internalType":"uint64","name":"nonce","type":"uint64"},{"indexed":false,"internalType":"address","name":"token","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint32","name":"requestVersion","type":"uint32"},{"indexed":false,"internalType":"bytes","name":"formattedRequest","type":"bytes"},{"indexed":true,"internalType":"bytes32","name":"requestID","type":"bytes32"}],"name":"CircleRequestSent","type":"event"}],"userDoc":{"events":{"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)":{"notice":"Emitted when a Circle token is received with an attached action request."},"CircleRequestSent(uint256,uint64,address,uint256,uint32,bytes,bytes32)":{"notice":"Emitted when a Circle token is sent with an attached action request."}},"kind":"user","methods":{},"version":1},"developerDoc":{"events":{"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)":{"params":{"amount":"Amount of tokens received by recipient","fee":"Fee paid for fulfilling the request, in minted tokens","mintToken":"Address of the minted Circle token","recipient":"End recipient of the tokens on this chain","requestID":"Unique identifier of the request","token":"Address of token that recipient received"}},"CircleRequestSent(uint256,uint64,address,uint256,uint32,bytes,bytes32)":{"details":"To fulfill the request, the validator needs to fetch `message` from `MessageSent` event emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API. This data will need to be presented to SynapseCCTP on the destination chain, along with `requestVersion` and `formattedRequest` emitted in this event.","params":{"amount":"Amount of Circle tokens burnt","chainId":"Chain ID of the destination chain","formattedRequest":"Formatted request for the action to take on the destination chain","nonce":"Nonce of the CCTP message on origin chain","requestID":"Unique identifier of the request","requestVersion":"Version of the request format","token":"Address of Circle token that was burnt"}}},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"mintToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestID\",\"type\":\"bytes32\"}],\"name\":\"CircleRequestFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint64\",\"name\":\"nonce\",\"type\":\"uint64\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint32\",\"name\":\"requestVersion\",\"type\":\"uint32\"},{\"indexed\":false,\"internalType\":\"bytes\",\"name\":\"formattedRequest\",\"type\":\"bytes\"},{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"requestID\",\"type\":\"bytes32\"}],\"name\":\"CircleRequestSent\",\"type\":\"event\"}],\"devdoc\":{\"events\":{\"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)\":{\"params\":{\"amount\":\"Amount of tokens received by recipient\",\"fee\":\"Fee paid for fulfilling the request, in minted tokens\",\"mintToken\":\"Address of the minted Circle token\",\"recipient\":\"End recipient of the tokens on this chain\",\"requestID\":\"Unique identifier of the request\",\"token\":\"Address of token that recipient received\"}},\"CircleRequestSent(uint256,uint64,address,uint256,uint32,bytes,bytes32)\":{\"details\":\"To fulfill the request, the validator needs to fetch `message` from `MessageSent` event emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API. This data will need to be presented to SynapseCCTP on the destination chain, along with `requestVersion` and `formattedRequest` emitted in this event.\",\"params\":{\"amount\":\"Amount of Circle tokens burnt\",\"chainId\":\"Chain ID of the destination chain\",\"formattedRequest\":\"Formatted request for the action to take on the destination chain\",\"nonce\":\"Nonce of the CCTP message on origin chain\",\"requestID\":\"Unique identifier of the request\",\"requestVersion\":\"Version of the request format\",\"token\":\"Address of Circle token that was burnt\"}}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"events\":{\"CircleRequestFulfilled(address,address,uint256,address,uint256,bytes32)\":{\"notice\":\"Emitted when a Circle token is received with an attached action request.\"},\"CircleRequestSent(uint256,uint64,address,uint256,uint32,bytes,bytes32)\":{\"notice\":\"Emitted when a Circle token is sent with an attached action request.\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"SynapseCCTPEvents\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:SynapseCCTPFees":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[],"name":"CCTPGasRescueFailed","type":"error"},{"inputs":[],"name":"CCTPIncorrectConfig","type":"error"},{"inputs":[],"name":"CCTPIncorrectProtocolFee","type":"error"},{"inputs":[],"name":"CCTPSymbolAlreadyAdded","type":"error"},{"inputs":[],"name":"CCTPSymbolIncorrect","type":"error"},{"inputs":[],"name":"CCTPTokenAlreadyAdded","type":"error"},{"inputs":[],"name":"CCTPTokenNotFound","type":"error"},{"inputs":[],"name":"CastOverflow","type":"error"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ChainGasAirdropped","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"chainGasAmount","type":"uint256"}],"name":"ChainGasAmountUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"feeCollector","type":"address"},{"indexed":false,"internalType":"uint256","name":"relayerFeeAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"protocolFeeAmount","type":"uint256"}],"name":"FeeCollected","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"address","name":"oldFeeCollector","type":"address"},{"indexed":false,"internalType":"address","name":"newFeeCollector","type":"address"}],"name":"FeeCollectorUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newProtocolFee","type":"uint256"}],"name":"ProtocolFeeUpdated","type":"event"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"accumulatedFees","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"relayerFee","type":"uint256"},{"internalType":"uint256","name":"minBaseFee","type":"uint256"},{"internalType":"uint256","name":"minSwapFee","type":"uint256"},{"internalType":"uint256","name":"maxFee","type":"uint256"}],"name":"addToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"},{"internalType":"bool","name":"isSwap","type":"bool"}],"name":"calculateFeeAmount","outputs":[{"internalType":"uint256","name":"fee","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"chainGasAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"feeStructures","outputs":[{"internalType":"uint40","name":"relayerFee","type":"uint40"},{"internalType":"uint72","name":"minBaseFee","type":"uint72"},{"internalType":"uint72","name":"minSwapFee","type":"uint72"},{"internalType":"uint72","name":"maxFee","type":"uint72"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"getBridgeTokens","outputs":[{"components":[{"internalType":"string","name":"symbol","type":"string"},{"internalType":"address","name":"token","type":"address"}],"internalType":"struct BridgeToken[]","name":"bridgeTokens","type":"tuple[]"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"protocolFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"relayerFeeCollectors","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"removeToken","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"rescueGas","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"newChainGasAmount","type":"uint256"}],"name":"setChainGasAmount","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"feeCollector","type":"address"}],"name":"setFeeCollector","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"newProtocolFee","type":"uint256"}],"name":"setProtocolFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"relayerFee","type":"uint256"},{"internalType":"uint256","name":"minBaseFee","type":"uint256"},{"internalType":"uint256","name":"minSwapFee","type":"uint256"},{"internalType":"uint256","name":"maxFee","type":"uint256"}],"name":"setTokenFee","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"string","name":"","type":"string"}],"name":"symbolToToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"tokenToSymbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"events":{"ChainGasAirdropped(uint256)":{"notice":"Emitted when the native chain gas is airdropped to a recipient"},"ChainGasAmountUpdated(uint256)":{"notice":"Emitted when the amount of native gas airdropped to recipients is updated"},"FeeCollected(address,uint256,uint256)":{"notice":"Emitted when the fee for relaying a CCTP message is collected"},"FeeCollectorUpdated(address,address,address)":{"notice":"Emitted when the fee collector is updated for a relayer"},"ProtocolFeeUpdated(uint256)":{"notice":"Emitted when the protocol fee is updated"}},"kind":"user","methods":{"accumulatedFees(address,address)":{"notice":"Maps fee collector address into accumulated fees for a token (feeCollector =\u003e (token =\u003e amount))"},"addToken(string,address,uint256,uint256,uint256,uint256)":{"notice":"Adds a new token to the list of supported tokens, with the given symbol and fee structure."},"calculateFeeAmount(address,uint256,bool)":{"notice":"Calculates the fee amount for bridging a token to this chain using CCTP."},"chainGasAmount()":{"notice":"Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request"},"feeStructures(address)":{"notice":"Maps bridge token address into CCTP fee structure"},"getBridgeTokens()":{"notice":"Returns the list of all supported bridge tokens and their symbols."},"protocolFee()":{"notice":"Protocol fee: percentage of the relayer fee that is collected by the Protocol"},"relayerFeeCollectors(address)":{"notice":"Maps Relayer address into collector address for accumulated Relayer's fees"},"removeToken(address)":{"notice":"Removes a token from the list of supported tokens."},"rescueGas()":{"notice":"Allows to rescue stuck gas from the contract."},"setChainGasAmount(uint256)":{"notice":"Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request."},"setFeeCollector(address)":{"notice":"Allows the Relayer to set a fee collector for accumulated fees. - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector. - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector."},"setProtocolFee(uint256)":{"notice":"Sets a new protocol fee."},"setTokenFee(address,uint256,uint256,uint256,uint256)":{"notice":"Updates the fee structure for a supported Circle token."},"symbolToToken(string)":{"notice":"Maps bridge token symbol into bridge token address"},"tokenToSymbol(address)":{"notice":"Maps bridge token address into bridge token symbol"}},"version":1},"developerDoc":{"kind":"dev","methods":{"addToken(string,address,uint256,uint256,uint256,uint256)":{"details":"The symbol must start with \"CCTP.\"","params":{"maxFee":"Maximum fee for bridging a token to this chain","minBaseFee":"Minimum fee for bridging a token to this chain using a base request","minSwapFee":"Minimum fee for bridging a token to this chain using a swap request","relayerFee":"Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`","symbol":"Symbol of the token","token":"Address of the token"}},"calculateFeeAmount(address,uint256,bool)":{"details":"Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.","params":{"amount":"Amount of the Circle tokens to be bridged to this chain","isSwap":"Whether the request is a swap request","token":"Address of the Circle token"},"returns":{"fee":"        Fee amount"}},"owner()":{"details":"Returns the address of the current owner."},"removeToken(address)":{"details":"Will revert if the token is not supported."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"setFeeCollector(address)":{"details":"Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol."},"setProtocolFee(uint256)":{"details":"The protocol fee is a percentage of the relayer fee that is collected by the Protocol.","params":{"newProtocolFee":"New protocol fee, multiplied by `FEE_DENOMINATOR`"}},"setTokenFee(address,uint256,uint256,uint256,uint256)":{"details":"Will revert if the token is not supported.","params":{"maxFee":"Maximum fee for bridging a token to this chain","minBaseFee":"Minimum fee for bridging a token to this chain using a base request","minSwapFee":"Minimum fee for bridging a token to this chain using a swap request","relayerFee":"Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`","token":"Address of the token"}},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"stateVariables":{"FEE_DENOMINATOR":{"details":"Denominator used to calculate the bridge fee"},"MAX_PROTOCOL_FEE":{"details":"Maximum protocol fee that can be set: 50%"},"MAX_RELAYER_FEE":{"details":"Maximum relayer fee that can be set: 10 bps"},"SYMBOL_PREFIX":{"details":"Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols"},"SYMBOL_PREFIX_LENGTH":{"details":"Length of the mandatory prefix used for CCTP token symbols"},"_bridgeTokens":{"details":"A list of all supported bridge tokens"},"accumulatedFees":{"details":"Fee collector address of address(0) indicates that fees are accumulated by the Protocol"},"protocolFee":{"details":"Protocol collects the full fee amount, if the Relayer hasn't set a fee collector"},"relayerFeeCollectors":{"details":"Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"CCTPGasRescueFailed\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPIncorrectConfig\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPIncorrectProtocolFee\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPSymbolAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPSymbolIncorrect\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPTokenAlreadyAdded\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CCTPTokenNotFound\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"CastOverflow\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ChainGasAirdropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainGasAmount\",\"type\":\"uint256\"}],\"name\":\"ChainGasAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"relayerFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"FeeCollectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProtocolFee\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeUpdated\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"accumulatedFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isSwap\",\"type\":\"bool\"}],\"name\":\"calculateFeeAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"chainGasAmount\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"feeStructures\",\"outputs\":[{\"internalType\":\"uint40\",\"name\":\"relayerFee\",\"type\":\"uint40\"},{\"internalType\":\"uint72\",\"name\":\"minBaseFee\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"minSwapFee\",\"type\":\"uint72\"},{\"internalType\":\"uint72\",\"name\":\"maxFee\",\"type\":\"uint72\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getBridgeTokens\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"symbol\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"internalType\":\"struct BridgeToken[]\",\"name\":\"bridgeTokens\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"protocolFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"relayerFeeCollectors\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"removeToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rescueGas\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newChainGasAmount\",\"type\":\"uint256\"}],\"name\":\"setChainGasAmount\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"}],\"name\":\"setFeeCollector\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"newProtocolFee\",\"type\":\"uint256\"}],\"name\":\"setProtocolFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayerFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minBaseFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minSwapFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"maxFee\",\"type\":\"uint256\"}],\"name\":\"setTokenFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"name\":\"symbolToToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenToSymbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addToken(string,address,uint256,uint256,uint256,uint256)\":{\"details\":\"The symbol must start with \\\"CCTP.\\\"\",\"params\":{\"maxFee\":\"Maximum fee for bridging a token to this chain\",\"minBaseFee\":\"Minimum fee for bridging a token to this chain using a base request\",\"minSwapFee\":\"Minimum fee for bridging a token to this chain using a swap request\",\"relayerFee\":\"Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\",\"symbol\":\"Symbol of the token\",\"token\":\"Address of the token\"}},\"calculateFeeAmount(address,uint256,bool)\":{\"details\":\"Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\",\"params\":{\"amount\":\"Amount of the Circle tokens to be bridged to this chain\",\"isSwap\":\"Whether the request is a swap request\",\"token\":\"Address of the Circle token\"},\"returns\":{\"fee\":\"        Fee amount\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"removeToken(address)\":{\"details\":\"Will revert if the token is not supported.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"setFeeCollector(address)\":{\"details\":\"Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\"},\"setProtocolFee(uint256)\":{\"details\":\"The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\",\"params\":{\"newProtocolFee\":\"New protocol fee, multiplied by `FEE_DENOMINATOR`\"}},\"setTokenFee(address,uint256,uint256,uint256,uint256)\":{\"details\":\"Will revert if the token is not supported.\",\"params\":{\"maxFee\":\"Maximum fee for bridging a token to this chain\",\"minBaseFee\":\"Minimum fee for bridging a token to this chain using a base request\",\"minSwapFee\":\"Minimum fee for bridging a token to this chain using a swap request\",\"relayerFee\":\"Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\",\"token\":\"Address of the token\"}},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"stateVariables\":{\"FEE_DENOMINATOR\":{\"details\":\"Denominator used to calculate the bridge fee\"},\"MAX_PROTOCOL_FEE\":{\"details\":\"Maximum protocol fee that can be set: 50%\"},\"MAX_RELAYER_FEE\":{\"details\":\"Maximum relayer fee that can be set: 10 bps\"},\"SYMBOL_PREFIX\":{\"details\":\"Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\"},\"SYMBOL_PREFIX_LENGTH\":{\"details\":\"Length of the mandatory prefix used for CCTP token symbols\"},\"_bridgeTokens\":{\"details\":\"A list of all supported bridge tokens\"},\"accumulatedFees\":{\"details\":\"Fee collector address of address(0) indicates that fees are accumulated by the Protocol\"},\"protocolFee\":{\"details\":\"Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\"},\"relayerFeeCollectors\":{\"details\":\"Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\"}},\"version\":1},\"userdoc\":{\"events\":{\"ChainGasAirdropped(uint256)\":{\"notice\":\"Emitted when the native chain gas is airdropped to a recipient\"},\"ChainGasAmountUpdated(uint256)\":{\"notice\":\"Emitted when the amount of native gas airdropped to recipients is updated\"},\"FeeCollected(address,uint256,uint256)\":{\"notice\":\"Emitted when the fee for relaying a CCTP message is collected\"},\"FeeCollectorUpdated(address,address,address)\":{\"notice\":\"Emitted when the fee collector is updated for a relayer\"},\"ProtocolFeeUpdated(uint256)\":{\"notice\":\"Emitted when the protocol fee is updated\"}},\"kind\":\"user\",\"methods\":{\"accumulatedFees(address,address)\":{\"notice\":\"Maps fee collector address into accumulated fees for a token (feeCollector =\u003e (token =\u003e amount))\"},\"addToken(string,address,uint256,uint256,uint256,uint256)\":{\"notice\":\"Adds a new token to the list of supported tokens, with the given symbol and fee structure.\"},\"calculateFeeAmount(address,uint256,bool)\":{\"notice\":\"Calculates the fee amount for bridging a token to this chain using CCTP.\"},\"chainGasAmount()\":{\"notice\":\"Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\"},\"feeStructures(address)\":{\"notice\":\"Maps bridge token address into CCTP fee structure\"},\"getBridgeTokens()\":{\"notice\":\"Returns the list of all supported bridge tokens and their symbols.\"},\"protocolFee()\":{\"notice\":\"Protocol fee: percentage of the relayer fee that is collected by the Protocol\"},\"relayerFeeCollectors(address)\":{\"notice\":\"Maps Relayer address into collector address for accumulated Relayer's fees\"},\"removeToken(address)\":{\"notice\":\"Removes a token from the list of supported tokens.\"},\"rescueGas()\":{\"notice\":\"Allows to rescue stuck gas from the contract.\"},\"setChainGasAmount(uint256)\":{\"notice\":\"Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\"},\"setFeeCollector(address)\":{\"notice\":\"Allows the Relayer to set a fee collector for accumulated fees. - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector. - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\"},\"setProtocolFee(uint256)\":{\"notice\":\"Sets a new protocol fee.\"},\"setTokenFee(address,uint256,uint256,uint256,uint256)\":{\"notice\":\"Updates the fee structure for a supported Circle token.\"},\"symbolToToken(string)\":{\"notice\":\"Maps bridge token symbol into bridge token address\"},\"tokenToSymbol(address)\":{\"notice\":\"Maps bridge token address into bridge token symbol\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"SynapseCCTPFees\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{"accumulatedFees(address,address)":"d4a67c6d","addToken(string,address,uint256,uint256,uint256,uint256)":"4a85178d","calculateFeeAmount(address,uint256,bool)":"0d25aafe","chainGasAmount()":"e00a83e0","feeStructures(address)":"dc72495b","getBridgeTokens()":"9c1d060e","owner()":"8da5cb5b","protocolFee()":"b0e21e8a","relayerFeeCollectors(address)":"41f355ee","removeToken(address)":"5fa7b584","renounceOwnership()":"715018a6","rescueGas()":"40432d51","setChainGasAmount(uint256)":"b250fe6b","setFeeCollector(address)":"a42dce80","setProtocolFee(uint256)":"787dce3d","setTokenFee(address,uint256,uint256,uint256,uint256)":"4bdb4eed","symbolToToken(string)":"a5bc29c2","tokenToSymbol(address)":"0ba36121","transferOwnership(address)":"f2fde38b"}},"solidity/SynapseCCTP.sol:SynapseCCTPFeesEvents":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"ChainGasAirdropped","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"chainGasAmount","type":"uint256"}],"name":"ChainGasAmountUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"address","name":"feeCollector","type":"address"},{"indexed":false,"internalType":"uint256","name":"relayerFeeAmount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"protocolFeeAmount","type":"uint256"}],"name":"FeeCollected","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"relayer","type":"address"},{"indexed":false,"internalType":"address","name":"oldFeeCollector","type":"address"},{"indexed":false,"internalType":"address","name":"newFeeCollector","type":"address"}],"name":"FeeCollectorUpdated","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"newProtocolFee","type":"uint256"}],"name":"ProtocolFeeUpdated","type":"event"}],"userDoc":{"events":{"ChainGasAirdropped(uint256)":{"notice":"Emitted when the native chain gas is airdropped to a recipient"},"ChainGasAmountUpdated(uint256)":{"notice":"Emitted when the amount of native gas airdropped to recipients is updated"},"FeeCollected(address,uint256,uint256)":{"notice":"Emitted when the fee for relaying a CCTP message is collected"},"FeeCollectorUpdated(address,address,address)":{"notice":"Emitted when the fee collector is updated for a relayer"},"ProtocolFeeUpdated(uint256)":{"notice":"Emitted when the protocol fee is updated"}},"kind":"user","methods":{},"version":1},"developerDoc":{"events":{"ChainGasAmountUpdated(uint256)":{"params":{"chainGasAmount":"The new amount of native gas airdropped to recipients"}},"FeeCollected(address,uint256,uint256)":{"details":"If fee collector address is not set, the full fee is collected for the protocol","params":{"feeCollector":"The fee collector address","protocolFeeAmount":"The amount of fees collected for the protocol","relayerFeeAmount":"The amount of fees collected for the relayer"}},"FeeCollectorUpdated(address,address,address)":{"params":{"newFeeCollector":"The new fee collector address: will be able to withdraw future fees","oldFeeCollector":"The old fee collector address: will be able to withdraw prior fees","relayer":"The relayer address"}},"ProtocolFeeUpdated(uint256)":{"params":{"newProtocolFee":"The new protocol fee"}}},"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ChainGasAirdropped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainGasAmount\",\"type\":\"uint256\"}],\"name\":\"ChainGasAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"feeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"relayerFeeAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"protocolFeeAmount\",\"type\":\"uint256\"}],\"name\":\"FeeCollected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"relayer\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldFeeCollector\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"newFeeCollector\",\"type\":\"address\"}],\"name\":\"FeeCollectorUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"newProtocolFee\",\"type\":\"uint256\"}],\"name\":\"ProtocolFeeUpdated\",\"type\":\"event\"}],\"devdoc\":{\"events\":{\"ChainGasAmountUpdated(uint256)\":{\"params\":{\"chainGasAmount\":\"The new amount of native gas airdropped to recipients\"}},\"FeeCollected(address,uint256,uint256)\":{\"details\":\"If fee collector address is not set, the full fee is collected for the protocol\",\"params\":{\"feeCollector\":\"The fee collector address\",\"protocolFeeAmount\":\"The amount of fees collected for the protocol\",\"relayerFeeAmount\":\"The amount of fees collected for the relayer\"}},\"FeeCollectorUpdated(address,address,address)\":{\"params\":{\"newFeeCollector\":\"The new fee collector address: will be able to withdraw future fees\",\"oldFeeCollector\":\"The old fee collector address: will be able to withdraw prior fees\",\"relayer\":\"The relayer address\"}},\"ProtocolFeeUpdated(uint256)\":{\"params\":{\"newProtocolFee\":\"The new protocol fee\"}}},\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"events\":{\"ChainGasAirdropped(uint256)\":{\"notice\":\"Emitted when the native chain gas is airdropped to a recipient\"},\"ChainGasAmountUpdated(uint256)\":{\"notice\":\"Emitted when the amount of native gas airdropped to recipients is updated\"},\"FeeCollected(address,uint256,uint256)\":{\"notice\":\"Emitted when the fee for relaying a CCTP message is collected\"},\"FeeCollectorUpdated(address,address,address)\":{\"notice\":\"Emitted when the fee collector is updated for a relayer\"},\"ProtocolFeeUpdated(uint256)\":{\"notice\":\"Emitted when the protocol fee is updated\"}},\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"SynapseCCTPFeesEvents\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{}},"solidity/SynapseCCTP.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ce94f35b9a6cabd8d7508bf3a898555f187d089064fb2b01b80643f0bb65a6bb64736f6c63430008110033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220ce94f35b9a6cabd8d7508bf3a898555f187d089064fb2b01b80643f0bb65a6bb64736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// prettier-ignore\n\nerror CastOverflow();\n\nerror IncorrectRequestLength();\nerror UnknownRequestVersion();\n\nerror CCTPGasRescueFailed();\nerror CCTPIncorrectChainId();\nerror CCTPIncorrectConfig();\nerror CCTPIncorrectDomain();\nerror CCTPIncorrectGasAmount();\nerror CCTPIncorrectProtocolFee();\nerror CCTPInsufficientAmount();\nerror CCTPSymbolAlreadyAdded();\nerror CCTPSymbolIncorrect();\nerror CCTPTokenAlreadyAdded();\nerror CCTPTokenNotFound();\nerror CCTPZeroAddress();\nerror CCTPZeroAmount();\n\nerror CCTPMessageNotReceived();\nerror RemoteCCTPDeploymentNotSet();\nerror RemoteCCTPTokenNotSet();\n\nerror ForwarderDeploymentFailed();\n\nabstract contract SynapseCCTPEvents {\n    // TODO: figure out what we need to emit for the Explorer\n\n    /// @notice Emitted when a Circle token is sent with an attached action request.\n    /// @dev To fulfill the request, the validator needs to fetch `message` from `MessageSent` event\n    /// emitted by Circle's MessageTransmitter in the same tx, then fetch `signature` for the message from Circle API.\n    /// This data will need to be presented to SynapseCCTP on the destination chain,\n    /// along with `requestVersion` and `formattedRequest` emitted in this event.\n    /// @param chainId              Chain ID of the destination chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param token                Address of Circle token that was burnt\n    /// @param amount               Amount of Circle tokens burnt\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on the destination chain\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestSent(\n        uint256 chainId,\n        uint64 nonce,\n        address token,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes formattedRequest,\n        bytes32 indexed requestID\n    );\n\n    /// @notice Emitted when a Circle token is received with an attached action request.\n    /// @param recipient            End recipient of the tokens on this chain\n    /// @param mintToken            Address of the minted Circle token\n    /// @param fee                  Fee paid for fulfilling the request, in minted tokens\n    /// @param token                Address of token that recipient received\n    /// @param amount               Amount of tokens received by recipient\n    /// @param requestID            Unique identifier of the request\n    event CircleRequestFulfilled(\n        address indexed recipient,\n        address mintToken,\n        uint256 fee,\n        address token,\n        uint256 amount,\n        bytes32 indexed requestID\n    );\n}\n\nabstract contract SynapseCCTPFeesEvents {\n    /// @notice Emitted when the fee collector is updated for a relayer\n    /// @param relayer          The relayer address\n    /// @param oldFeeCollector  The old fee collector address: will be able to withdraw prior fees\n    /// @param newFeeCollector  The new fee collector address: will be able to withdraw future fees\n    event FeeCollectorUpdated(address indexed relayer, address oldFeeCollector, address newFeeCollector);\n\n    /// @notice Emitted when the fee for relaying a CCTP message is collected\n    /// @dev If fee collector address is not set, the full fee is collected for the protocol\n    /// @param feeCollector      The fee collector address\n    /// @param relayerFeeAmount  The amount of fees collected for the relayer\n    /// @param protocolFeeAmount The amount of fees collected for the protocol\n    event FeeCollected(address feeCollector, uint256 relayerFeeAmount, uint256 protocolFeeAmount);\n\n    /// @notice Emitted when the amount of native gas airdropped to recipients is updated\n    /// @param chainGasAmount   The new amount of native gas airdropped to recipients\n    event ChainGasAmountUpdated(uint256 chainGasAmount);\n\n    /// @notice Emitted when the native chain gas is airdropped to a recipient\n    event ChainGasAirdropped(uint256 amount);\n\n    /// @notice Emitted when the protocol fee is updated\n    /// @param newProtocolFee  The new protocol fee\n    event ProtocolFeeUpdated(uint256 newProtocolFee);\n}\n\n// prettier-ignore\n\n// TODO: merge with ROuterV2 structs\nstruct BridgeToken {\n    string symbol;\n    address token;\n}\n\nlibrary TypeCasts {\n    // alignment preserving cast\n    function addressToBytes32(address addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 buf) internal pure returns (address) {\n        return address(uint160(uint256(buf)));\n    }\n\n    /// @dev Casts uint256 to uint40, reverts on overflow\n    function safeCastToUint40(uint256 value) internal pure returns (uint40) {\n        if (value \u003e type(uint40).max) {\n            revert CastOverflow();\n        }\n        return uint40(value);\n    }\n\n    /// @dev Casts uint256 to uint72, reverts on overflow\n    function safeCastToUint72(uint256 value) internal pure returns (uint72) {\n        if (value \u003e type(uint72).max) {\n            revert CastOverflow();\n        }\n        return uint72(value);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (utils/structs/EnumerableSet.sol)\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 =\u003e uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastvalue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastvalue;\n                // Update the index for the moved value\n                set._indexes[lastvalue] = valueIndex; // Replace lastvalue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n\nabstract contract SynapseCCTPFees is SynapseCCTPFeesEvents, Ownable {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using TypeCasts for uint256;\n\n    /// @notice CCTP fee structure for a supported Circle token.\n    /// @dev Optimized for storage. 2**72 is 4*10**21, which is enough to represent adequate amounts\n    /// for stable coins with 18 decimals. Circle tokens have 6 decimals, so this is more than enough.\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    struct CCTPFee {\n        uint40 relayerFee;\n        uint72 minBaseFee;\n        uint72 minSwapFee;\n        uint72 maxFee;\n    }\n\n    /// @dev Denominator used to calculate the bridge fee\n    uint256 private constant FEE_DENOMINATOR = 10**10;\n    /// @dev Maximum relayer fee that can be set: 10 bps\n    uint256 private constant MAX_RELAYER_FEE = 10**7;\n    /// @dev Maximum protocol fee that can be set: 50%\n    uint256 private constant MAX_PROTOCOL_FEE = FEE_DENOMINATOR / 2;\n    /// @dev Mandatory prefix used for CCTP token symbols to distinguish them from other bridge symbols\n    bytes private constant SYMBOL_PREFIX = \"CCTP.\";\n    /// @dev Length of the mandatory prefix used for CCTP token symbols\n    uint256 private constant SYMBOL_PREFIX_LENGTH = 5;\n\n    // ══════════════════════════════════════════════════ STORAGE ══════════════════════════════════════════════════════\n\n    /// @notice Maps bridge token address into bridge token symbol\n    mapping(address =\u003e string) public tokenToSymbol;\n    /// @notice Maps bridge token symbol into bridge token address\n    mapping(string =\u003e address) public symbolToToken;\n    /// @notice Maps bridge token address into CCTP fee structure\n    mapping(address =\u003e CCTPFee) public feeStructures;\n    /// @notice Maps fee collector address into accumulated fees for a token\n    /// (feeCollector =\u003e (token =\u003e amount))\n    /// @dev Fee collector address of address(0) indicates that fees are accumulated by the Protocol\n    mapping(address =\u003e mapping(address =\u003e uint256)) public accumulatedFees;\n    /// @notice Maps Relayer address into collector address for accumulated Relayer's fees\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol\n    mapping(address =\u003e address) public relayerFeeCollectors;\n    /// @notice Protocol fee: percentage of the relayer fee that is collected by the Protocol\n    /// @dev Protocol collects the full fee amount, if the Relayer hasn't set a fee collector\n    uint256 public protocolFee;\n    /// @notice Amount of chain's native gas airdropped to the token recipient for every fulfilled CCTP request\n    uint256 public chainGasAmount;\n    /// @dev A list of all supported bridge tokens\n    EnumerableSet.AddressSet internal _bridgeTokens;\n\n    // ════════════════════════════════════════════════ ONLY OWNER ═════════════════════════════════════════════════════\n\n    /// @notice Adds a new token to the list of supported tokens, with the given symbol and fee structure.\n    /// @dev The symbol must start with \"CCTP.\"\n    /// @param symbol       Symbol of the token\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function addToken(\n        string memory symbol,\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (token == address(0)) revert CCTPIncorrectConfig();\n        // Add a new token to the list of supported tokens, and check that it hasn't been added before\n        if (!_bridgeTokens.add(token)) revert CCTPTokenAlreadyAdded();\n        // Check that symbol hasn't been added yet and starts with \"CCTP.\"\n        _assertCanAddSymbol(symbol);\n        // Add token \u003c\u003e symbol link\n        tokenToSymbol[token] = symbol;\n        symbolToToken[symbol] = token;\n        // Set token fee\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Removes a token from the list of supported tokens.\n    /// @dev Will revert if the token is not supported.\n    function removeToken(address token) external onlyOwner {\n        // Remove a token from the list of supported tokens, and check that it has been added before\n        if (!_bridgeTokens.remove(token)) revert CCTPTokenNotFound();\n        // Remove token \u003c\u003e symbol link\n        string memory symbol = tokenToSymbol[token];\n        delete tokenToSymbol[token];\n        delete symbolToToken[symbol];\n        // Remove token fee structure\n        delete feeStructures[token];\n    }\n\n    /// @notice Allows to rescue stuck gas from the contract.\n    function rescueGas() external onlyOwner {\n        (bool success, ) = msg.sender.call{value: address(this).balance}(\"\");\n        if (!success) revert CCTPGasRescueFailed();\n    }\n\n    /// @notice Sets the amount of chain gas airdropped to the token recipient for every fulfilled CCTP request.\n    function setChainGasAmount(uint256 newChainGasAmount) external onlyOwner {\n        chainGasAmount = newChainGasAmount;\n        emit ChainGasAmountUpdated(newChainGasAmount);\n    }\n\n    /// @notice Updates the fee structure for a supported Circle token.\n    /// @dev Will revert if the token is not supported.\n    /// @param token        Address of the token\n    /// @param relayerFee   Fee % for bridging a token to this chain, multiplied by `FEE_DENOMINATOR`\n    /// @param minBaseFee   Minimum fee for bridging a token to this chain using a base request\n    /// @param minSwapFee   Minimum fee for bridging a token to this chain using a swap request\n    /// @param maxFee       Maximum fee for bridging a token to this chain\n    function setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) external onlyOwner {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        _setTokenFee(token, relayerFee, minBaseFee, minSwapFee, maxFee);\n    }\n\n    /// @notice Sets a new protocol fee.\n    /// @dev The protocol fee is a percentage of the relayer fee that is collected by the Protocol.\n    /// @param newProtocolFee   New protocol fee, multiplied by `FEE_DENOMINATOR`\n    function setProtocolFee(uint256 newProtocolFee) external onlyOwner {\n        if (newProtocolFee \u003e MAX_PROTOCOL_FEE) revert CCTPIncorrectProtocolFee();\n        protocolFee = newProtocolFee;\n        emit ProtocolFeeUpdated(newProtocolFee);\n    }\n\n    // ═══════════════════════════════════════════ RELAYER INTERACTIONS ════════════════════════════════════════════════\n\n    /// @notice Allows the Relayer to set a fee collector for accumulated fees.\n    /// - New fees accumulated by the Relayer could only be withdrawn by new Relayer's fee collector.\n    /// - Old fees accumulated by the Relayer could only be withdrawn by old Relayer's fee collector.\n    /// @dev Default value of address(0) indicates that a Relayer's fees are accumulated by the Protocol.\n    function setFeeCollector(address feeCollector) external {\n        address oldFeeCollector = relayerFeeCollectors[msg.sender];\n        relayerFeeCollectors[msg.sender] = feeCollector;\n        emit FeeCollectorUpdated(msg.sender, oldFeeCollector, feeCollector);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// @dev Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    /// @param token        Address of the Circle token\n    /// @param amount       Amount of the Circle tokens to be bridged to this chain\n    /// @param isSwap       Whether the request is a swap request\n    /// @return fee         Fee amount\n    function calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) external view returns (uint256 fee) {\n        return _calculateFeeAmount(token, amount, isSwap);\n    }\n\n    /// @notice Returns the list of all supported bridge tokens and their symbols.\n    function getBridgeTokens() external view returns (BridgeToken[] memory bridgeTokens) {\n        uint256 length = _bridgeTokens.length();\n        bridgeTokens = new BridgeToken[](length);\n        for (uint256 i = 0; i \u003c length; i++) {\n            address token = _bridgeTokens.at(i);\n            bridgeTokens[i] = BridgeToken({symbol: tokenToSymbol[token], token: token});\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Applies the relayer fee and updates the accumulated fee amount for the token.\n    /// Will revert if the fee exceeds the token amount, or token is not supported.\n    function _applyRelayerFee(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal returns (uint256 amountAfterFee, uint256 fee) {\n        if (!_bridgeTokens.contains(token)) revert CCTPTokenNotFound();\n        fee = _calculateFeeAmount(token, amount, isSwap);\n        if (fee \u003e= amount) revert CCTPInsufficientAmount();\n        // Could use the unchecked math, as we already checked that fee \u003c amount\n        unchecked {\n            amountAfterFee = amount - fee;\n        }\n        // Check if the Relayer has specified a fee collector\n        address feeCollector = relayerFeeCollectors[msg.sender];\n        if (feeCollector == address(0)) {\n            // If the fee collector is not set, the Protocol will collect the full fees\n            accumulatedFees[address(0)][token] += fee;\n            emit FeeCollected(address(0), 0, fee);\n        } else {\n            // Otherwise, the Relayer and the Protocol will split the fees\n            uint256 protocolFeeAmount = (fee * protocolFee) / FEE_DENOMINATOR;\n            uint256 relayerFeeAmount = fee - protocolFeeAmount;\n            accumulatedFees[address(0)][token] += protocolFeeAmount;\n            accumulatedFees[feeCollector][token] += relayerFeeAmount;\n            emit FeeCollected(feeCollector, relayerFeeAmount, protocolFeeAmount);\n        }\n    }\n\n    /// @dev Sets the fee structure for a supported Circle token.\n    function _setTokenFee(\n        address token,\n        uint256 relayerFee,\n        uint256 minBaseFee,\n        uint256 minSwapFee,\n        uint256 maxFee\n    ) internal {\n        // Check that relayer fee is not too high\n        if (relayerFee \u003e MAX_RELAYER_FEE) revert CCTPIncorrectConfig();\n        // Min base fee must not exceed min swap fee\n        if (minBaseFee \u003e minSwapFee) revert CCTPIncorrectConfig();\n        // Min swap fee must not exceed max fee\n        if (minSwapFee \u003e maxFee) revert CCTPIncorrectConfig();\n        feeStructures[token] = CCTPFee({\n            relayerFee: relayerFee.safeCastToUint40(),\n            minBaseFee: minBaseFee.safeCastToUint72(),\n            minSwapFee: minSwapFee.safeCastToUint72(),\n            maxFee: maxFee.safeCastToUint72()\n        });\n    }\n\n    /// @dev Transfers `msg.value` to the recipient. Assumes that `msg.value == chainGasAmount` at this point.\n    function _transferMsgValue(address recipient) internal {\n        // Try to send the gas airdrop to the recipient\n        (bool success, ) = recipient.call{value: msg.value}(\"\");\n        // If the transfer failed, set the emitted amount to 0\n        emit ChainGasAirdropped(success ? msg.value : 0);\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Checks that the symbol hasn't been added yet and starts with \"CCTP.\"\n    function _assertCanAddSymbol(string memory symbol) internal view {\n        // Check if the symbol has already been added\n        if (symbolToToken[symbol] != address(0)) revert CCTPSymbolAlreadyAdded();\n        // Cast to bytes to check the length\n        bytes memory symbolBytes = bytes(symbol);\n        // Check that symbol is correct: starts with \"CCTP.\" and has at least 1 more character\n        if (symbolBytes.length \u003c= SYMBOL_PREFIX_LENGTH) revert CCTPSymbolIncorrect();\n        for (uint256 i = 0; i \u003c SYMBOL_PREFIX_LENGTH; ) {\n            if (symbolBytes[i] != SYMBOL_PREFIX[i]) revert CCTPSymbolIncorrect();\n            unchecked {\n                ++i;\n            }\n        }\n    }\n\n    /// @dev Calculates the fee amount for bridging a token to this chain using CCTP.\n    /// Will not check if fee exceeds the token amount. Will return 0 if the token is not supported.\n    function _calculateFeeAmount(\n        address token,\n        uint256 amount,\n        bool isSwap\n    ) internal view returns (uint256 fee) {\n        CCTPFee memory feeStructure = feeStructures[token];\n        // Calculate the fee amount\n        fee = (amount * feeStructure.relayerFee) / FEE_DENOMINATOR;\n        // Apply minimum fee\n        uint256 minFee = isSwap ? feeStructure.minSwapFee : feeStructure.minBaseFee;\n        if (fee \u003c minFee) fee = minFee;\n        // Apply maximum fee\n        if (fee \u003e feeStructure.maxFee) fee = feeStructure.maxFee;\n    }\n}\n\n// TODO: deprecate when LinkedPool PR is merged\ninterface IDefaultPool {\n    function swap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx,\n        uint256 minDy,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function calculateSwap(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 dx\n    ) external view returns (uint256 amountOut);\n\n    function getToken(uint8 index) external view returns (address token);\n}\n\ninterface IMessageTransmitter {\n    /**\n     * @notice Receives an incoming message, validating the header and passing\n     * the body to application-specific handler.\n     * @param message The message raw bytes\n     * @param signature The message signature\n     * @return success bool, true if successful\n     */\n    function receiveMessage(bytes calldata message, bytes calldata signature) external returns (bool success);\n\n    /**\n     * @notice Sends an outgoing message from the source domain, with a specified caller on the\n     * destination domain.\n     * @dev Increment nonce, format the message, and emit `MessageSent` event with message information.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * sendMessage() should be preferred for use cases where a specific destination caller is not required.\n     * @param destinationDomain Domain of destination chain\n     * @param recipient Address of message recipient on destination domain as bytes32\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @param messageBody Raw bytes content of message\n     * @return nonce reserved by message\n     */\n    function sendMessageWithCaller(\n        uint32 destinationDomain,\n        bytes32 recipient,\n        bytes32 destinationCaller,\n        bytes calldata messageBody\n    ) external returns (uint64);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Domain of chain on which the contract is deployed\n    function localDomain() external view returns (uint32);\n\n    // Next available nonce from this source domain\n    function nextAvailableNonce() external view returns (uint64);\n}\n\ninterface ISynapseCCTP {\n    /// @notice Send a Circle token supported by CCTP to a given chain\n    /// with the request for the action to take on the destination chain.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on the destination chain.\n    /// `chainId` refers to value from EIP-155 (block.chainid).\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @param chainId              Chain ID of the destination chain\n    /// @param burnToken            Address of Circle token to burn\n    /// @param amount               Amount of tokens to burn\n    /// @param requestVersion       Version of the request format\n    /// @param swapParams           Swap parameters for the action to take on the destination chain (could be empty)\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external;\n\n    /// @notice Receive  Circle token supported by CCTP with the request for the action to take.\n    /// @dev The request is a bytes array containing information about the end recipient of the tokens,\n    /// as well as an optional swap action to take on this chain.\n    /// @dev The relayers need to use SynapseCCTP.chainGasAmount() as `msg.value` when calling this function,\n    /// or the call will revert.\n    /// @param message              Message raw bytes emitted by CCTP MessageTransmitter on origin chain\n    /// @param signature            Circle's attestation for the message obtained from Circle's API\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request for the action to take on this chain\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable;\n}\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n}\n\ninterface ITokenMessenger {\n    /**\n     * @notice Deposits and burns tokens from sender to be minted on destination domain. The mint\n     * on the destination domain must be called by `destinationCaller`.\n     * WARNING: if the `destinationCaller` does not represent a valid address as bytes32, then it will not be possible\n     * to broadcast the message on the destination domain. This is an advanced feature, and the standard\n     * depositForBurn() should be preferred for use cases where a specific destination caller is not required.\n     * Emits a `DepositForBurn` event.\n     * @dev reverts if:\n     * - given destinationCaller is zero address\n     * - given burnToken is not supported\n     * - given destinationDomain has no TokenMessenger registered\n     * - transferFrom() reverts. For example, if sender's burnToken balance or approved allowance\n     * to this contract is less than `amount`.\n     * - burn() reverts. For example, if `amount` is 0.\n     * - MessageTransmitter returns false or reverts.\n     * @param amount amount of tokens to burn\n     * @param destinationDomain destination domain\n     * @param mintRecipient address of mint recipient on destination domain\n     * @param burnToken address of contract to burn deposited tokens, on local domain\n     * @param destinationCaller caller on the destination domain, as bytes32\n     * @return nonce unique nonce reserved by message\n     */\n    function depositForBurnWithCaller(\n        uint256 amount,\n        uint32 destinationDomain,\n        bytes32 mintRecipient,\n        address burnToken,\n        bytes32 destinationCaller\n    ) external returns (uint64 nonce);\n\n    /**\n     * @notice Handles an incoming message received by the local MessageTransmitter,\n     * and takes the appropriate action. For a burn message, mints the\n     * associated token to the requested recipient on the local domain.\n     * @dev Validates the local sender is the local MessageTransmitter, and the\n     * remote sender is a registered remote TokenMessenger for `remoteDomain`.\n     * @param remoteDomain The domain where the message originated from.\n     * @param sender The sender of the message (remote TokenMessenger).\n     * @param messageBody The message body bytes.\n     * @return success Bool, true if successful.\n     */\n    function handleReceiveMessage(\n        uint32 remoteDomain,\n        bytes32 sender,\n        bytes calldata messageBody\n    ) external returns (bool success);\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    // Local Message Transmitter responsible for sending and receiving messages to/from remote domains\n    function localMessageTransmitter() external view returns (address);\n\n    // Minter responsible for minting and burning tokens on the local domain\n    function localMinter() external view returns (address);\n}\n\n/// # Base Request layout\n///\n/// | Field           | Type    | Description                                    |\n/// | --------------- | ------- | ---------------------------------------------- |\n/// | originDomain    | uint32  | Domain of the origin chain used by Circle CCTP |\n/// | nonce           | uint64  | Nonce of the CCTP message on origin chain      |\n/// | originBurnToken | address | Circle token that was burned on origin chain   |\n/// | amount          | uint256 | Amount of tokens burned on origin chain        |\n/// | recipient       | address | Recipient of the tokens on destination chain   |\n///\n/// # Swap Params layout\n///\n/// | Field          | Type    | Description                                                   |\n/// | -------------- | ------- | ------------------------------------------------------------- |\n/// | tokenIndexFrom | uint8   | Index of the minted Circle token in the pool                  |\n/// | tokenIndexTo   | uint8   | Index of the final token in the pool                          |\n/// | deadline       | uint256 | Latest timestamp to execute the swap                          |\n/// | minAmountOut   | uint256 | Minimum amount of tokens to receive from the swap             |\nlibrary RequestLib {\n    uint32 internal constant REQUEST_BASE = 0;\n    uint32 internal constant REQUEST_SWAP = 1;\n\n    /// @notice Length of the encoded base request.\n    uint256 internal constant REQUEST_BASE_LENGTH = 5 * 32;\n    /// @notice Length of the encoded swap parameters.\n    uint256 internal constant SWAP_PARAMS_LENGTH = 4 * 32;\n    /// @notice Length of the encoded swap request.\n    /// Need 2 extra words for each `bytes` field to store its offset in the full payload, and length.\n    uint256 internal constant REQUEST_SWAP_LENGTH = 4 * 32 + REQUEST_BASE_LENGTH + SWAP_PARAMS_LENGTH;\n\n    // ════════════════════════════════════════════════ FORMATTING ═════════════════════════════════════════════════════\n\n    /// @notice Formats the base request into a bytes array.\n    /// @param originDomain         Domain of the origin chain\n    /// @param nonce                Nonce of the CCTP message on origin chain\n    /// @param originBurnToken      Circle token that was burned on origin chain\n    /// @param amount               Amount of tokens burned on origin chain\n    /// @param recipient            Recipient of the tokens on destination chain\n    /// @return formattedRequest    Properly formatted base request\n    function formatBaseRequest(\n        uint32 originDomain,\n        uint64 nonce,\n        address originBurnToken,\n        uint256 amount,\n        address recipient\n    ) internal pure returns (bytes memory formattedRequest) {\n        return abi.encode(originDomain, nonce, originBurnToken, amount, recipient);\n    }\n\n    /// @notice Formats the swap parameters part of the swap request into a bytes array.\n    /// @param tokenIndexFrom       Index of the minted Circle token in the pool\n    /// @param tokenIndexTo         Index of the final token in the pool\n    /// @param deadline             Latest timestamp to execute the swap\n    /// @param minAmountOut         Minimum amount of tokens to receive from the swap\n    /// @return formattedSwapParams Properly formatted swap parameters\n    function formatSwapParams(\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal pure returns (bytes memory formattedSwapParams) {\n        return abi.encode(tokenIndexFrom, tokenIndexTo, deadline, minAmountOut);\n    }\n\n    /// @notice Formats the request into a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Base request is not properly formatted.\n    /// - Swap parameters are specified for a base request.\n    /// - Swap parameters are not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param baseRequest          Formatted base request\n    /// @param swapParams           Formatted swap parameters\n    /// @return formattedRequest    Properly formatted request\n    function formatRequest(\n        uint32 requestVersion,\n        bytes memory baseRequest,\n        bytes memory swapParams\n    ) internal pure returns (bytes memory formattedRequest) {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        if (requestVersion == REQUEST_BASE) {\n            if (swapParams.length != 0) revert IncorrectRequestLength();\n            // swapParams is empty, so we can just return the base request\n            return baseRequest;\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n            // Encode both the base request and the swap parameters\n            return abi.encode(baseRequest, swapParams);\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n\n    // ═════════════════════════════════════════════════ DECODING ══════════════════════════════════════════════════════\n\n    /// @notice Decodes the base request from a bytes array.\n    /// @dev Will revert if the request is not properly formatted.\n    /// @param baseRequest          Formatted base request\n    /// @return originDomain        Domain of the origin chain\n    /// @return nonce               Nonce of the CCTP message on origin domain\n    /// @return originBurnToken     Circle token that was burned on origin domain\n    /// @return amount              Amount of tokens to burn\n    /// @return recipient           Recipient of the tokens on destination domain\n    function decodeBaseRequest(bytes memory baseRequest)\n        internal\n        pure\n        returns (\n            uint32 originDomain,\n            uint64 nonce,\n            address originBurnToken,\n            uint256 amount,\n            address recipient\n        )\n    {\n        if (baseRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(baseRequest, (uint32, uint64, address, uint256, address));\n    }\n\n    /// @notice Decodes the swap parameters from a bytes array.\n    /// @dev Will revert if the swap parameters are not properly formatted.\n    /// @param swapParams           Formatted swap parameters\n    /// @return tokenIndexFrom      Index of the minted Circle token in the pool\n    /// @return tokenIndexTo        Index of the final token in the pool\n    /// @return deadline            Latest timestamp to execute the swap\n    /// @return minAmountOut        Minimum amount of tokens to receive from the swap\n    function decodeSwapParams(bytes memory swapParams)\n        internal\n        pure\n        returns (\n            uint8 tokenIndexFrom,\n            uint8 tokenIndexTo,\n            uint256 deadline,\n            uint256 minAmountOut\n        )\n    {\n        if (swapParams.length != SWAP_PARAMS_LENGTH) revert IncorrectRequestLength();\n        return abi.decode(swapParams, (uint8, uint8, uint256, uint256));\n    }\n\n    /// @notice Decodes the versioned request from a bytes array.\n    /// @dev Will revert if the either of these is true:\n    /// - Request version is unknown.\n    /// - Request is not properly formatted.\n    /// @param requestVersion       Version of the request format\n    /// @param formattedRequest     Formatted request\n    /// @return baseRequest         Formatted base request\n    /// @return swapParams          Formatted swap parameters\n    function decodeRequest(uint32 requestVersion, bytes memory formattedRequest)\n        internal\n        pure\n        returns (bytes memory baseRequest, bytes memory swapParams)\n    {\n        if (requestVersion == REQUEST_BASE) {\n            if (formattedRequest.length != REQUEST_BASE_LENGTH) revert IncorrectRequestLength();\n            return (formattedRequest, \"\");\n        } else if (requestVersion == REQUEST_SWAP) {\n            if (formattedRequest.length != REQUEST_SWAP_LENGTH) revert IncorrectRequestLength();\n            return abi.decode(formattedRequest, (bytes, bytes));\n        } else {\n            revert UnknownRequestVersion();\n        }\n    }\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length \u003e 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance \u003e= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance \u003e= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length \u003e 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n\n/// Minimal Forwarder is a EIP-1167 (Minimal Proxy Contract) spin-off that\n/// forwards all calls to a any target address with any payload.\n/// Unlike EIP-1167, delegates calls are not used, so the forwarder contract\n/// is `msg.sender` as far as the target contract is concerned.\n/// # Minimal Forwarder Bytecode\n/// Inspired by [EIP-1167](https://eips.ethereum.org/EIPS/eip-1167).\n/// Following changes were made:\n/// - Target address is not saved in the deployed contract code, but is passed as a part of the payload.\n/// - To forward a call, the sender needs to provide the target address as the first 32 bytes of the payload.\n/// - The payload to pass to the target contract occupies the rest of the payload, having an offset of 32 bytes.\n/// - The target address is derived using CALLDATALOAD.\n/// - CALLVALUE is used to pass the msg.value to the target contract.\n/// - `call()` is used instead of `delegatecall()`.\n/// ## Bytecode Table\n/// | Pos  | OP   | OP + Args | Description    | S7  | S6   | S5  | S4  | S3     | S2  | S1     | S0     |\n/// | ---- | ---- | --------- | -------------- | --- | ---- | --- | --- | ------ | --- | ------ | ------ |\n/// | 0x00 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        |     |        | 32     |\n/// | 0x02 | 0x36 | 0x36      | calldatasize   |     |      |     |     |        |     | cds    | 32     |\n/// | 0x03 | 0x03 | 0x03      | sub            |     |      |     |     |        |     |        | cds-32 |\n/// | 0x04 | 0x80 | 0x80      | dup1           |     |      |     |     |        |     | cds-32 | cds-32 |\n/// | 0x05 | 0x60 | 0x6020    | push1 0x20     |     |      |     |     |        | 32  | cds-32 | cds-32 |\n/// | 0x07 | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 32  | cds-32 | cds-32 |\n/// | 0x08 | 0x37 | 0x37      | calldatacopy   |     |      |     |     |        |     |        | cds-32 |\n/// | 0x09 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        |     | 0      | cds-32 |\n/// | 0x0a | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | 0   | 0      | cds-32 |\n/// | 0x0b | 0x3d | 0x3d      | returndatasize |     |      |     |     | 0      | 0   | 0      | cds-32 |\n/// | 0x0c | 0x92 | 0x92      | swap3          |     |      |     |     | cds-32 | 0   | 0      | 0      |\n/// | 0x0d | 0x3d | 0x3d      | returndatasize |     |      |     | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0e | 0x34 | 0x34      | callvalue      |     |      | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x0f | 0x3d | 0x3d      | returndatasize |     | 0    | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x10 | 0x35 | 0x35      | calldataload   |     | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x11 | 0x5a | 0x5a      | gas            | gas | addr | val | 0   | cds-32 | 0   | 0      | 0      |\n/// | 0x12 | 0xf1 | 0xf1      | call           |     |      |     |     |        |     | suc    | 0      |\n/// | 0x13 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | suc    | 0      |\n/// | 0x14 | 0x82 | 0x82      | dup3           |     |      |     |     | 0      | rds | suc    | 0      |\n/// | 0x15 | 0x80 | 0x80      | dup1           |     |      |     | 0   | 0      | rds | suc    | 0      |\n/// | 0x16 | 0x3e | 0x3e      | returndatacopy |     |      |     |     |        |     | suc    | 0      |\n/// | 0x17 | 0x90 | 0x90      | swap1          |     |      |     |     |        |     | 0      | suc    |\n/// | 0x18 | 0x3d | 0x3d      | returndatasize |     |      |     |     |        | rds | 0      | suc    |\n/// | 0x19 | 0x91 | 0x91      | swap2          |     |      |     |     |        | suc | 0      | rds    |\n/// | 0x1a | 0x60 | 0x601e    | push1 0x1e     |     |      |     |     | 0x1e   | suc | 0      | rds    |\n/// | 0x1c | 0x57 | 0x57      | jumpi          |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1d | 0xfd | 0xfd      | revert         |     |      |     |     |        |     |        |        |\n/// | 0x1e | 0x5b | 0x5b      | jumpdest       |     |      |     |     |        |     | 0      | rds    |\n/// | 0x1f | 0xf3 | 0xf3      | return         |     |      |     |     |        |     |        |        |\n/// \u003e - Opcode + Args refers to the bytecode of the opcode and its arguments (if there are any).\n/// \u003e - Stack View (S7..S0) is shown after the execution of the opcode.\n/// \u003e - The stack elements are shown from top to bottom.\n/// \u003e Opcodes are typically dealing with the top stack elements, so they are shown first.\n/// \u003e - `cds` refers to the calldata size.\n/// \u003e - `rds` refers to the returndata size (which is zero before the first external call).\n/// \u003e - `val` refers to the provided `msg.value`.\n/// \u003e - `addr` refers to the target address loaded from calldata.\n/// \u003e - `gas` refers to the return value of the `gas()` opcode: the amount of gas left.\n/// \u003e - `suc` refers to the return value of the `call()` opcode: 0 on failure, 1 on success.\n/// ## Bytecode Explanation\n/// - `0x00..0x03` - Calculate the offset of the payload in the calldata (first 32 bytes is target address).\n/// \u003e - `sub` pops the top two stack items, subtracts them, and pushes the result onto the stack.\n/// - `0x04..0x04` - Duplicate the offset to use it later as \"payload length\".\n/// \u003e - `dup1` duplicates the top stack item.\n/// - `0x05..0x08` - Copy the target call payload to memory.\n/// \u003e - `calldatacopy` copies a portion of the calldata to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, calldata offset to read from, and length of the data to copy.\n/// - `0x09..0x11` - Prepare the stack for the `call` opcode.\n/// \u003e - We are putting an extra zero on the stack to use it later on, as `returndatacopy` will not return zero\n/// \u003e after we perform the first external call.\n/// \u003e - `swap3` swaps the top stack item with the fourth stack item.\n/// \u003e - `callvalue` pushes `msg.value` onto the stack.\n/// \u003e - `calldataload` pushes a word (32 bytes) onto the stack from calldata. Pops the calldata offset from the stack.\n/// \u003e Writes the word from calldata to the stack. We are using offset==0 to load the target address.\n/// \u003e - `gas` pushes the remaining gas onto the stack.\n/// - `0x12..0x12` - Call the target contract.\n/// \u003e - `call` issues an external call to a target address.\n/// \u003e -  Pops seven top stack items: gas, target address, value, input offset, input length,\n/// \u003e memory offset to write return data to, and length of return data to write to memory.\n/// \u003e - Pushes on stack: 0 on failure, 1 on success.\n/// - `0x13..0x16` - Copy the return data to memory.\n/// \u003e - `returndatasize` pushes the size of the returned data from the external call onto the stack.\n/// \u003e - `dup3` duplicates the third stack item.\n/// \u003e - `returncopydata` copies a portion of the returned data to memory. Pops three top stack elements:\n/// \u003e memory offset to write to, return data offset to read from, and length of the data to copy.\n/// - `0x17..0x1b` - Prepare the stack for either revert or return: jump dst, success flag, zero, and return data size.\n/// \u003e - `swap1` swaps the top stack item with the second stack item.\n/// \u003e - `swap2` swaps the top stack item with the third stack item.\n/// \u003e - `0x1e` refers to the position of the `jumpdest` opcode.\n/// \u003e  It is used to jump to the `return` opcode, if call was successful.\n/// - `0x1c..0x1c` - Jump to 0x1e position, if call was successful.\n/// \u003e - `jumpi` pops two top stack items: jump destination and jump condition.\n/// \u003e If jump condition is nonzero, jumps to the jump destination.\n/// - `0x1d..0x1d` - Revert if call was unsuccessful.\n/// \u003e - `revert` pops two top stack items: memory offset to read revert message from and length of the revert message.\n/// \u003e - This allows us to bubble the revert message from the external call.\n/// - `0x1e..0x1e` - Jump destination for successful call.\n/// \u003e - `jumpdest` is a no-op that marks a valid jump destination.\n/// - `0x1f..0x1f` - Return if call was successful.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to reuse the return data from the external call.\n/// # Minimal Forwarder Init Code\n/// Inspired by [Create3 Init Code](https://github.com/0xSequence/create3/blob/master/contracts/Create3.sol).\n/// Following changes were made:\n/// - Adjusted bytecode length to 32 bytes.\n/// - Replaced second PUSH1 opcode with RETURNDATASIZE to push 0 onto the stack.\n/// \u003e `bytecode` refers to the bytecode specified in the above table.\n/// ## Init Code Table\n/// | Pos  | OP   | OP + Args | Description     | S1  | S0       |\n/// | ---- | ---- | --------- | --------------- | --- | -------- |\n/// | 0x00 | 0x7f | 0x7fXXXX  | push32 bytecode |     | bytecode |\n/// | 0x1b | 0x3d | 0x3d      | returndatasize  | 0   | bytecode |\n/// | 0x1c | 0x52 | 0x52      | mstore          |     |          |\n/// | 0x1d | 0x60 | 0x6020    | push1 0x20      |     | 32       |\n/// | 0x1f | 0x3d | 0x3d      | returndatasize  | 0   | 32       |\n/// | 0x20 | 0xf3 | 0xf3      | return          |     |          |\n/// \u003e Init Code is executed when a contract is deployed. The returned value is saved as the contract code.\n/// \u003e Therefore, the init code is constructed in such a way that it returns the Minimal Forwarder bytecode.\n/// ## Init Code Explanation\n/// - `0x00..0x1a` - Push the Minimal Forwarder bytecode onto the stack.\n/// \u003e - `push32` pushes 32 bytes as a single stack item onto the stack.\n/// - `0x1b..0x1b` - Push 0 onto the stack.\n/// \u003e No external calls were made, so the return data size is 0.\n/// - `0x1c..0x1c` - Write the Minimal Forwarder bytecode to memory.\n/// \u003e - `mstore` pops two top stack items: memory offset to write to and value to write.\n/// \u003e - Minimal Forwarder bytecode is 32 bytes long, so we need a single `mstore` to write it to memory.\n/// - `0x1d..0x1f` - Prepare stack for `return` opcode.\n/// \u003e - We need to put `0 32` on the stack in order to return first 32 bytes of memory.\n/// - `0x20..0x20` - Return the Minimal Forwarder bytecode.\n/// \u003e - `return` pops two top stack items: memory offset to read return data from and length of the return data.\n/// \u003e - This allows us to return the Minimal Forwarder bytecode.\nlibrary MinimalForwarderLib {\n    using Address for address;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Minimal Forwarder deployed bytecode. See the above table for more details.\n    bytes internal constant FORWARDER_BYTECODE =\n        hex\"60_20_36_03_80_60_20_3d_37_3d_3d_3d_92_3d_34_3d_35_5a_f1_3d_82_80_3e_90_3d_91_60_1e_57_fd_5b_f3\";\n\n    /// @notice Init code to deploy a minimal forwarder contract.\n    bytes internal constant FORWARDER_INIT_CODE = abi.encodePacked(hex\"7f\", FORWARDER_BYTECODE, hex\"3d_52_60_20_3d_f3\");\n\n    /// @notice Hash of the minimal forwarder init code. Used to predict the address of a deployed forwarder.\n    bytes32 internal constant FORWARDER_INIT_CODE_HASH = keccak256(FORWARDER_INIT_CODE);\n\n    /// @notice Deploys a minimal forwarder contract using `CREATE2` with a given salt.\n    /// @dev Will revert if the salt is already used.\n    /// @param salt         The salt to use for the deployment\n    /// @return forwarder   The address of the deployed minimal forwarder\n    function deploy(bytes32 salt) internal returns (address forwarder) {\n        // `bytes arr` is stored in memory in the following way\n        // 1. First, uint256 arr.length is stored. That requires 32 bytes (0x20).\n        // 2. Then, the array data is stored.\n        bytes memory initCode = FORWARDER_INIT_CODE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Deploy the minimal forwarder with our pre-made bytecode via CREATE2.\n            // We add 0x20 to get the location where the init code starts.\n            forwarder := create2(0, add(initCode, 0x20), mload(initCode), salt)\n        }\n        // Deploy fails if the given salt is already used.\n        if (forwarder == address(0)) {\n            revert ForwarderDeploymentFailed();\n        }\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @return returnData  The return data from the target contract\n    function forwardCall(\n        address forwarder,\n        address target,\n        bytes memory payload\n    ) internal returns (bytes memory returnData) {\n        // Forward a call without any ETH value\n        returnData = forwardCallWithValue(forwarder, target, payload, 0);\n    }\n\n    /// @notice Forwards a call to a target address using a minimal forwarder with the given `msg.value`.\n    /// @dev Will bubble up any revert messages from the target.\n    /// @param forwarder    The address of the minimal forwarder to use\n    /// @param target       The address of the target contract to call\n    /// @param payload      The payload to pass to the target contract\n    /// @param value        The amount of ETH to send with the call\n    /// @return returnData  The return data from the target contract\n    function forwardCallWithValue(\n        address forwarder,\n        address target,\n        bytes memory payload,\n        uint256 value\n    ) internal returns (bytes memory returnData) {\n        // The payload to pass to the forwarder:\n        // 1. First 32 bytes is the encoded target address\n        // 2. The rest is the encoded payload to pass to the target\n        returnData = forwarder.functionCallWithValue(abi.encodePacked(target.addressToBytes32(), payload), value);\n    }\n\n    /// @notice Predicts the address of a minimal forwarder contract deployed using `deploy()`.\n    /// @param deployer     The address of the deployer of the minimal forwarder\n    /// @param salt         The salt to use for the deployment\n    /// @return The predicted address of the minimal forwarder deployed with the given salt\n    function predictAddress(address deployer, bytes32 salt) internal pure returns (address) {\n        return keccak256(abi.encodePacked(hex\"ff\", deployer, salt, FORWARDER_INIT_CODE_HASH)).bytes32ToAddress();\n    }\n}\n\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance \u003e= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length \u003e 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n\ncontract SynapseCCTP is SynapseCCTPFees, SynapseCCTPEvents, ISynapseCCTP {\n    using EnumerableSet for EnumerableSet.AddressSet;\n    using MinimalForwarderLib for address;\n    using SafeERC20 for IERC20;\n    using TypeCasts for address;\n    using TypeCasts for bytes32;\n\n    /// @notice Struct defining the configuration of a remote domain that has SynapseCCTP deployed.\n    /// @dev CCTP uses the following convention for domain numbers:\n    /// - 0: Ethereum Mainnet\n    /// - 1: Avalanche Mainnet\n    /// With more chains added, the convention will be extended.\n    /// @param domain       Value for the remote domain used in CCTP messages.\n    /// @param synapseCCTP  Address of the SynapseCCTP deployed on the remote chain.\n    struct DomainConfig {\n        uint32 domain;\n        address synapseCCTP;\n    }\n\n    /// @notice Refers to the local domain number used in CCTP messages.\n    uint32 public immutable localDomain;\n    IMessageTransmitter public immutable messageTransmitter;\n    ITokenMessenger public immutable tokenMessenger;\n\n    // (chainId =\u003e configuration of the remote chain)\n    mapping(uint256 =\u003e DomainConfig) public remoteDomainConfig;\n    // (Circle token =\u003e liquidity pool with the token)\n    mapping(address =\u003e address) public circleTokenPool;\n\n    constructor(ITokenMessenger tokenMessenger_) {\n        tokenMessenger = tokenMessenger_;\n        messageTransmitter = IMessageTransmitter(tokenMessenger_.localMessageTransmitter());\n        localDomain = messageTransmitter.localDomain();\n    }\n\n    // ═════════════════════════════════════════════ SET CONFIG LOGIC ══════════════════════════════════════════════════\n\n    /// @notice Sets the remote domain and deployment of SynapseCCTP for the given remote chainId.\n    function setRemoteDomainConfig(\n        uint256 remoteChainId,\n        uint32 remoteDomain,\n        address remoteSynapseCCTP\n    ) external onlyOwner {\n        // ChainId should be non-zero and different from the local chain id.\n        if (remoteChainId == 0 || remoteChainId == block.chainid) revert CCTPIncorrectChainId();\n        // Remote domain should differ from the local domain.\n        if (remoteDomain == localDomain) revert CCTPIncorrectDomain();\n        // Remote domain should be 0 IF AND ONLY IF remote chain id is 1 (Ethereum Mainnet).\n        // Or if remote chain id is 5 (Goerli). TODO: remove this in production.\n        if ((remoteDomain == 0) != (remoteChainId == 1 || remoteChainId == 5)) revert CCTPIncorrectDomain();\n        // Remote SynapseCCTP should be non-zero.\n        if (remoteSynapseCCTP == address(0)) revert CCTPZeroAddress();\n        remoteDomainConfig[remoteChainId] = DomainConfig(remoteDomain, remoteSynapseCCTP);\n    }\n\n    /// @notice Sets the liquidity pool for the given Circle token.\n    function setCircleTokenPool(address circleToken, address pool) external onlyOwner {\n        if (circleToken == address(0)) revert CCTPZeroAddress();\n        if (!_bridgeTokens.contains(circleToken)) revert CCTPTokenNotFound();\n        // Pool address can be zero if no swaps are supported for the Circle token.\n        circleTokenPool[circleToken] = pool;\n    }\n\n    // ═════════════════════════════════════════════ FEES WITHDRAWING ══════════════════════════════════════════════════\n\n    /// @notice Allows the owner to withdraw accumulated protocol fees.\n    function withdrawProtocolFees(address token) external onlyOwner {\n        uint256 accFees = accumulatedFees[address(0)][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[address(0)][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    /// @notice Allows the Relayer's fee collector to withdraw accumulated relayer fees.\n    function withdrawRelayerFees(address token) external {\n        uint256 accFees = accumulatedFees[msg.sender][token];\n        if (accFees == 0) revert CCTPZeroAmount();\n        accumulatedFees[msg.sender][token] = 0;\n        IERC20(token).safeTransfer(msg.sender, accFees);\n    }\n\n    // ════════════════════════════════════════════════ CCTP LOGIC ═════════════════════════════════════════════════════\n\n    /// @inheritdoc ISynapseCCTP\n    function sendCircleToken(\n        address recipient,\n        uint256 chainId,\n        address burnToken,\n        uint256 amount,\n        uint32 requestVersion,\n        bytes memory swapParams\n    ) external {\n        // Check if token is supported before doing anything else.\n        if (!_bridgeTokens.contains(burnToken)) revert CCTPTokenNotFound();\n        // Pull token from user and update the amount in case of transfer fee.\n        amount = _pullToken(burnToken, amount);\n        uint64 nonce = messageTransmitter.nextAvailableNonce();\n        // This will revert if the request version is not supported, or swap params are not properly formatted.\n        bytes memory formattedRequest = RequestLib.formatRequest(\n            requestVersion,\n            RequestLib.formatBaseRequest(localDomain, nonce, burnToken, amount, recipient),\n            swapParams\n        );\n        DomainConfig memory config = remoteDomainConfig[chainId];\n        bytes32 dstSynapseCCTP = config.synapseCCTP.addressToBytes32();\n        if (dstSynapseCCTP == 0) revert RemoteCCTPDeploymentNotSet();\n        uint32 destinationDomain = config.domain;\n        // Construct the request identifier to be used as salt later.\n        // The identifier (requestID) is unique for every single request on all the chains.\n        // This is done by including origin and destination domains as well as origin nonce in the hashed data.\n        // Origin domain and nonce are included in `formattedRequest`, so we only need to add the destination domain.\n        bytes32 requestID = _requestID(destinationDomain, requestVersion, formattedRequest);\n        // Issue allowance if needed\n        _approveToken(burnToken, address(tokenMessenger), amount);\n        tokenMessenger.depositForBurnWithCaller(\n            amount,\n            destinationDomain,\n            dstSynapseCCTP,\n            burnToken,\n            _destinationCaller(dstSynapseCCTP.bytes32ToAddress(), requestID)\n        );\n        emit CircleRequestSent(chainId, nonce, burnToken, amount, requestVersion, formattedRequest, requestID);\n    }\n\n    // TODO: guard this to be only callable by the validators?\n    /// @inheritdoc ISynapseCCTP\n    function receiveCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) external payable {\n        // Check that the Relayer provided correct `msg.value`\n        if (msg.value != chainGasAmount) revert CCTPIncorrectGasAmount();\n        (bytes memory baseRequest, bytes memory swapParams) = RequestLib.decodeRequest(\n            requestVersion,\n            formattedRequest\n        );\n        (uint32 originDomain, , address originBurnToken, uint256 amount, address recipient) = RequestLib\n            .decodeBaseRequest(baseRequest);\n        // For requestID hashing we use origin and destination domains as well as origin nonce.\n        // This ensures that requestID is unique for each request, and that it is not possible to replay requests.\n        bytes32 requestID = _requestID(localDomain, requestVersion, formattedRequest);\n        // Kindly ask the Circle Bridge to mint the tokens for us.\n        _mintCircleToken(message, signature, requestID);\n        address token = _getLocalToken(originDomain, originBurnToken);\n        uint256 fee;\n        // Apply the bridging fee. This will revert if amount \u003c= fee.\n        (amount, fee) = _applyRelayerFee(token, amount, requestVersion == RequestLib.REQUEST_SWAP);\n        // Fulfill the request: perform an optional swap and send the end tokens to the recipient.\n        (address tokenOut, uint256 amountOut) = _fulfillRequest(recipient, token, amount, swapParams);\n        // Perform the gas airdrop and emit corresponding event if gas airdrop is enabled\n        if (msg.value \u003e 0) _transferMsgValue(recipient);\n        emit CircleRequestFulfilled(recipient, token, fee, tokenOut, amountOut, requestID);\n    }\n\n    // ═══════════════════════════════════════════════════ VIEWS ═══════════════════════════════════════════════════════\n\n    /// @notice Get the local token associated with the given remote domain and token.\n    function getLocalToken(uint32 remoteDomain, address remoteToken) external view returns (address) {\n        return _getLocalToken(remoteDomain, remoteToken);\n    }\n\n    /// @notice Checks if the given request is already fulfilled.\n    function isRequestFulfilled(bytes32 requestID) external view returns (bool) {\n        // Request is fulfilled if the requestID is already used, meaning the forwarder is already deployed.\n        return MinimalForwarderLib.predictAddress(address(this), requestID).code.length \u003e 0;\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL LOGIC ═══════════════════════════════════════════════════\n\n    /// @dev Approves the token to be spent by the given spender indefinitely by giving infinite allowance.\n    /// Doesn't modify the allowance if it's already enough for the given amount.\n    function _approveToken(\n        address token,\n        address spender,\n        uint256 amount\n    ) internal {\n        uint256 allowance = IERC20(token).allowance(address(this), spender);\n        if (allowance \u003c amount) {\n            // Reset allowance to 0 before setting it to the new value.\n            if (allowance != 0) IERC20(token).safeApprove(spender, 0);\n            IERC20(token).safeApprove(spender, type(uint256).max);\n        }\n    }\n\n    /// @dev Pulls the token from the sender.\n    function _pullToken(address token, uint256 amount) internal returns (uint256 amountPulled) {\n        uint256 balanceBefore = IERC20(token).balanceOf(address(this));\n        IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n        amountPulled = IERC20(token).balanceOf(address(this)) - balanceBefore;\n    }\n\n    /// @dev Mints the Circle token by sending the message and signature to the Circle Bridge.\n    function _mintCircleToken(\n        bytes calldata message,\n        bytes calldata signature,\n        bytes32 requestID\n    ) internal {\n        // Deploy a forwarder specific to this request. Will revert if the requestID has been used before.\n        address forwarder = MinimalForwarderLib.deploy(requestID);\n        // Form the payload for the Circle Bridge.\n        bytes memory payload = abi.encodeWithSelector(IMessageTransmitter.receiveMessage.selector, message, signature);\n        // Use the deployed forwarder (who is the only one who can call the Circle Bridge for this message)\n        // This will revert if the provided message is not properly formatted, or if the signatures are invalid.\n        bytes memory returnData = forwarder.forwardCall(address(messageTransmitter), payload);\n        // messageTransmitter.receiveMessage is supposed to return true if the message was received.\n        if (!abi.decode(returnData, (bool))) revert CCTPMessageNotReceived();\n    }\n\n    /// @dev Performs a swap, if was requested back on origin chain, and transfers the tokens to the recipient.\n    /// Should the swap fail, will transfer `token` to the recipient instead.\n    function _fulfillRequest(\n        address recipient,\n        address token,\n        uint256 amount,\n        bytes memory swapParams\n    ) internal returns (address tokenOut, uint256 amountOut) {\n        // Fallback to Base Request if no swap params are provided\n        if (swapParams.length == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // We checked request version to be a valid value when wrapping into `request`,\n        // so this could only be `RequestLib.REQUEST_SWAP`.\n        address pool = circleTokenPool[token];\n        // Fallback to Base Request if no pool is found\n        if (pool == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        (uint8 tokenIndexFrom, uint8 tokenIndexTo, uint256 deadline, uint256 minAmountOut) = RequestLib\n            .decodeSwapParams(swapParams);\n        tokenOut = _tryGetToken(pool, tokenIndexTo);\n        // Fallback to Base Request if failed to get tokenOut address\n        if (tokenOut == address(0)) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Approve the pool to spend the token, if needed.\n        _approveToken(token, pool, amount);\n        amountOut = _trySwap(pool, tokenIndexFrom, tokenIndexTo, amount, deadline, minAmountOut);\n        // Fallback to Base Request if failed to swap\n        if (amountOut == 0) {\n            IERC20(token).safeTransfer(recipient, amount);\n            return (token, amount);\n        }\n        // Transfer the swapped tokens to the recipient.\n        IERC20(tokenOut).safeTransfer(recipient, amountOut);\n    }\n\n    /// @dev Tries to swap tokens using the provided swap instructions.\n    /// Instead of reverting, returns 0 if the swap failed.\n    function _trySwap(\n        address pool,\n        uint8 tokenIndexFrom,\n        uint8 tokenIndexTo,\n        uint256 amount,\n        uint256 deadline,\n        uint256 minAmountOut\n    ) internal returns (uint256 amountOut) {\n        try IDefaultPool(pool).swap(tokenIndexFrom, tokenIndexTo, amount, minAmountOut, deadline) returns (\n            uint256 amountOut_\n        ) {\n            amountOut = amountOut_;\n        } catch {\n            // Swapping failed, return 0\n            amountOut = 0;\n        }\n    }\n\n    // ══════════════════════════════════════════════ INTERNAL VIEWS ═══════════════════════════════════════════════════\n\n    /// @dev Gets the address of the local minted Circle token from the local TokenMinter.\n    function _getLocalToken(uint32 remoteDomain, address remoteToken) internal view returns (address token) {\n        ITokenMinter minter = ITokenMinter(tokenMessenger.localMinter());\n        token = minter.getLocalToken(remoteDomain, remoteToken.addressToBytes32());\n        // Revert if TokenMinter is not aware of this remote token.\n        if (token == address(0)) revert CCTPTokenNotFound();\n    }\n\n    /// @dev Tries to get the token address from the pool.\n    /// Instead of reverting, returns 0 if the getToken failed.\n    function _tryGetToken(address pool, uint8 tokenIndex) internal view returns (address token) {\n        // Issue a low level static call instead of IDefaultPool(pool).getToken(tokenIndex)\n        // to ensure this never reverts\n        (bool success, bytes memory returnData) = pool.staticcall(\n            abi.encodeWithSelector(IDefaultPool.getToken.selector, tokenIndex)\n        );\n        if (success \u0026\u0026 returnData.length == 32) {\n            // Do the casting instead of using abi.decode to discard the dirty highest bits if there are any\n            token = bytes32(returnData).bytes32ToAddress();\n        } else {\n            // Return 0 on revert or if pool returned something unexpected\n            token = address(0);\n        }\n    }\n\n    /// @dev Predicts the address of the destination caller that will be used to call the Circle Message Transmitter.\n    function _destinationCaller(address synapseCCTP, bytes32 requestID) internal pure returns (bytes32) {\n        // On the destination chain, Synapse CCTP will deploy a MinimalForwarder for each request,\n        // using requestID as salt for the create2 deployment.\n        return synapseCCTP.predictAddress(requestID).addressToBytes32();\n    }\n\n    /// @dev Calculates the unique identifier of the request.\n    function _requestID(\n        uint32 destinationDomain,\n        uint32 requestVersion,\n        bytes memory formattedRequest\n    ) internal pure returns (bytes32 requestID) {\n        // Merge the destination domain and the request version into a single uint256.\n        uint256 prefix = (uint256(destinationDomain) \u003c\u003c 32) | requestVersion;\n        bytes32 requestHash = keccak256(formattedRequest);\n        // Use assembly to return hash of the prefix and the request hash.\n        // We are using scratch space to avoid unnecessary memory expansion.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Store prefix in memory at 0, and requestHash at 32.\n            mstore(0, prefix)\n            mstore(32, requestHash)\n            // Return hash of first 64 bytes of memory.\n            requestID := keccak256(0, 64)\n        }\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"4372:866:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;4372:866:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"4372:866:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/SynapseCCTP.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/SynapseCCTP.sol\":{\"keccak256\":\"0x2e0ee295c4ebff2eaa2e2c256b5fa9281288f82e66a3ea88f457c5df11ea4160\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://aa7032ae5ecee3299fb4f83bda1294e0e7f5aeea0aa2885267afc828d84944fc\",\"dweb:/ipfs/QmPkAEqE2ZdWMoHYznBVzE3gV7UzzEY6dzR9qZnjRwGdcL\"]}},\"version\":1}"},"hashes":{}}}