{"solidity/MockTokenMinter.sol:IERC20":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n\n    // local token (address) =\u003e maximum burn amounts per message\n    function burnLimitsPerMessage(address token) external view returns (uint256);\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title IMintBurnToken\n * @notice interface for mintable and burnable ERC20 token\n */\ninterface IMintBurnToken is IERC20 {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param amount The amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of the caller.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev allows a minter to burn some of its own tokens\n     * Validates that caller is a minter and that sender is not blacklisted\n     * amount is less than or equal to the minter's account balance\n     * @param amount uint256 the amount of tokens to be burned\n     */\n    function burn(uint256 amount) external;\n}\n\ncontract MockTokenMinter is ITokenMinter {\n    mapping(uint32 =\u003e mapping(bytes32 =\u003e address)) internal localTokens;\n    address public localTokenMessenger;\n    mapping(address =\u003e uint256) public burnLimitsPerMessage;\n\n    constructor(address localTokenMessenger_) {\n        localTokenMessenger = localTokenMessenger_;\n    }\n\n    function setLocalToken(\n        uint32 remoteDomain,\n        bytes32 remoteToken,\n        address localToken\n    ) external {\n        localTokens[remoteDomain][remoteToken] = localToken;\n    }\n\n    function setBurnLimitPerMessage(address token, uint256 limit) external {\n        burnLimitsPerMessage[token] = limit;\n    }\n\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken) {\n        require(msg.sender == localTokenMessenger, \"Caller not local TokenMessenger\");\n        mintToken = localTokens[sourceDomain][burnToken];\n        require(mintToken != address(0), \"Mint token not supported\");\n        IMintBurnToken(mintToken).mint(to, amount);\n    }\n\n    function burn(address burnToken, uint256 amount) external {\n        require(msg.sender == localTokenMessenger, \"Caller not local TokenMessenger\");\n        IMintBurnToken(burnToken).burn(amount);\n    }\n\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address) {\n        return localTokens[remoteDomain][remoteToken];\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Interface of the ERC20 standard as defined in the EIP.","events":{"Approval(address,address,uint256)":{"details":"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{"details":"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},"kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{"details":"Returns the amount of tokens owned by `account`."},"totalSupply()":{"details":"Returns the amount of tokens in existence."},"transfer(address,uint256)":{"details":"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{"details":"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC20 standard as defined in the EIP.\",\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"}},\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the amount of tokens owned by `account`.\"},\"totalSupply()\":{\"details\":\"Returns the amount of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MockTokenMinter.sol\":\"IERC20\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MockTokenMinter.sol\":{\"keccak256\":\"0x583efb59b744fc37c0634811ddca5bcb6108d9a9276e756dd65b61a4cbac9f7d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://83b0308f4aa30afa825c62acdada12301acf2a9a94db78895919e31057611892\",\"dweb:/ipfs/QmPcvdQMe37RUN8YVuusgHtdEjE1NTd4XMVwbnMVCNpUBi\"]}},\"version\":1}"},"hashes":{"allowance(address,address)":"dd62ed3e","approve(address,uint256)":"095ea7b3","balanceOf(address)":"70a08231","totalSupply()":"18160ddd","transfer(address,uint256)":"a9059cbb","transferFrom(address,address,uint256)":"23b872dd"}},"solidity/MockTokenMinter.sol:IMintBurnToken":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n\n    // local token (address) =\u003e maximum burn amounts per message\n    function burnLimitsPerMessage(address token) external view returns (uint256);\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title IMintBurnToken\n * @notice interface for mintable and burnable ERC20 token\n */\ninterface IMintBurnToken is IERC20 {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param amount The amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of the caller.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev allows a minter to burn some of its own tokens\n     * Validates that caller is a minter and that sender is not blacklisted\n     * amount is less than or equal to the minter's account balance\n     * @param amount uint256 the amount of tokens to be burned\n     */\n    function burn(uint256 amount) external;\n}\n\ncontract MockTokenMinter is ITokenMinter {\n    mapping(uint32 =\u003e mapping(bytes32 =\u003e address)) internal localTokens;\n    address public localTokenMessenger;\n    mapping(address =\u003e uint256) public burnLimitsPerMessage;\n\n    constructor(address localTokenMessenger_) {\n        localTokenMessenger = localTokenMessenger_;\n    }\n\n    function setLocalToken(\n        uint32 remoteDomain,\n        bytes32 remoteToken,\n        address localToken\n    ) external {\n        localTokens[remoteDomain][remoteToken] = localToken;\n    }\n\n    function setBurnLimitPerMessage(address token, uint256 limit) external {\n        burnLimitsPerMessage[token] = limit;\n    }\n\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken) {\n        require(msg.sender == localTokenMessenger, \"Caller not local TokenMessenger\");\n        mintToken = localTokens[sourceDomain][burnToken];\n        require(mintToken != address(0), \"Mint token not supported\");\n        IMintBurnToken(mintToken).mint(to, amount);\n    }\n\n    function burn(address burnToken, uint256 amount) external {\n        require(msg.sender == localTokenMessenger, \"Caller not local TokenMessenger\");\n        IMintBurnToken(burnToken).burn(amount);\n    }\n\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address) {\n        return localTokens[remoteDomain][remoteToken];\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"notice":"interface for mintable and burnable ERC20 token","version":1},"developerDoc":{"kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{"details":"Returns the amount of tokens owned by `account`."},"burn(uint256)":{"details":"allows a minter to burn some of its own tokens Validates that caller is a minter and that sender is not blacklisted amount is less than or equal to the minter's account balance","params":{"amount":"uint256 the amount of tokens to be burned"}},"mint(address,uint256)":{"details":"Function to mint tokens","params":{"amount":"The amount of tokens to mint. Must be less than or equal to the minterAllowance of the caller.","to":"The address that will receive the minted tokens."},"returns":{"_0":"A boolean that indicates if the operation was successful."}},"totalSupply()":{"details":"Returns the amount of tokens in existence."},"transfer(address,uint256)":{"details":"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{"details":"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}},"title":"IMintBurnToken","version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the amount of tokens owned by `account`.\"},\"burn(uint256)\":{\"details\":\"allows a minter to burn some of its own tokens Validates that caller is a minter and that sender is not blacklisted amount is less than or equal to the minter's account balance\",\"params\":{\"amount\":\"uint256 the amount of tokens to be burned\"}},\"mint(address,uint256)\":{\"details\":\"Function to mint tokens\",\"params\":{\"amount\":\"The amount of tokens to mint. Must be less than or equal to the minterAllowance of the caller.\",\"to\":\"The address that will receive the minted tokens.\"},\"returns\":{\"_0\":\"A boolean that indicates if the operation was successful.\"}},\"totalSupply()\":{\"details\":\"Returns the amount of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"}},\"title\":\"IMintBurnToken\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"interface for mintable and burnable ERC20 token\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MockTokenMinter.sol\":\"IMintBurnToken\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MockTokenMinter.sol\":{\"keccak256\":\"0x583efb59b744fc37c0634811ddca5bcb6108d9a9276e756dd65b61a4cbac9f7d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://83b0308f4aa30afa825c62acdada12301acf2a9a94db78895919e31057611892\",\"dweb:/ipfs/QmPcvdQMe37RUN8YVuusgHtdEjE1NTd4XMVwbnMVCNpUBi\"]}},\"version\":1}"},"hashes":{"allowance(address,address)":"dd62ed3e","approve(address,uint256)":"095ea7b3","balanceOf(address)":"70a08231","burn(uint256)":"42966c68","mint(address,uint256)":"40c10f19","totalSupply()":"18160ddd","transfer(address,uint256)":"a9059cbb","transferFrom(address,address,uint256)":"23b872dd"}},"solidity/MockTokenMinter.sol:ITokenMinter":{"code":"0x","runtime-code":"0x","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n\n    // local token (address) =\u003e maximum burn amounts per message\n    function burnLimitsPerMessage(address token) external view returns (uint256);\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title IMintBurnToken\n * @notice interface for mintable and burnable ERC20 token\n */\ninterface IMintBurnToken is IERC20 {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param amount The amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of the caller.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev allows a minter to burn some of its own tokens\n     * Validates that caller is a minter and that sender is not blacklisted\n     * amount is less than or equal to the minter's account balance\n     * @param amount uint256 the amount of tokens to be burned\n     */\n    function burn(uint256 amount) external;\n}\n\ncontract MockTokenMinter is ITokenMinter {\n    mapping(uint32 =\u003e mapping(bytes32 =\u003e address)) internal localTokens;\n    address public localTokenMessenger;\n    mapping(address =\u003e uint256) public burnLimitsPerMessage;\n\n    constructor(address localTokenMessenger_) {\n        localTokenMessenger = localTokenMessenger_;\n    }\n\n    function setLocalToken(\n        uint32 remoteDomain,\n        bytes32 remoteToken,\n        address localToken\n    ) external {\n        localTokens[remoteDomain][remoteToken] = localToken;\n    }\n\n    function setBurnLimitPerMessage(address token, uint256 limit) external {\n        burnLimitsPerMessage[token] = limit;\n    }\n\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken) {\n        require(msg.sender == localTokenMessenger, \"Caller not local TokenMessenger\");\n        mintToken = localTokens[sourceDomain][burnToken];\n        require(mintToken != address(0), \"Mint token not supported\");\n        IMintBurnToken(mintToken).mint(to, amount);\n    }\n\n    function burn(address burnToken, uint256 amount) external {\n        require(msg.sender == localTokenMessenger, \"Caller not local TokenMessenger\");\n        IMintBurnToken(burnToken).burn(amount);\n    }\n\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address) {\n        return localTokens[remoteDomain][remoteToken];\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"}],"name":"burnLimitsPerMessage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"bytes32","name":"remoteToken","type":"bytes32"}],"name":"getLocalToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"sourceDomain","type":"uint32"},{"internalType":"bytes32","name":"burnToken","type":"bytes32"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"address","name":"mintToken","type":"address"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"burn(address,uint256)":{"notice":"Burn tokens owned by this ITokenMinter."},"getLocalToken(uint32,bytes32)":{"notice":"Get the local token associated with the given remote domain and token."},"mint(uint32,bytes32,address,uint256)":{"notice":"Mints `amount` of local tokens corresponding to the given (`sourceDomain`, `burnToken`) pair, to `to` address."}},"version":1},"developerDoc":{"kind":"dev","methods":{"burn(address,uint256)":{"params":{"amount":"amount of tokens to burn. Must be less than or equal to this ITokenMinter's account balance of the given `_burnToken`.","burnToken":"burnable token."}},"getLocalToken(uint32,bytes32)":{"params":{"remoteDomain":"Remote domain","remoteToken":"Remote token"},"returns":{"_0":"local token address"}},"mint(uint32,bytes32,address,uint256)":{"details":"reverts if the (`sourceDomain`, `burnToken`) pair does not map to a nonzero local token address. This mapping can be queried using getLocalToken().","params":{"amount":"Amount of tokens to mint. Must be less than or equal to the minterAllowance of this TokenMinter for given `_mintToken`.","burnToken":"Burned token address as bytes32.","sourceDomain":"Source domain where `burnToken` was burned.","to":"Address to receive minted tokens, corresponding to `burnToken`, on this domain."},"returns":{"mintToken":"token minted."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"burnLimitsPerMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"remoteToken\",\"type\":\"bytes32\"}],\"name\":\"getLocalToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"sourceDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"burnToken\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"mintToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"burn(address,uint256)\":{\"params\":{\"amount\":\"amount of tokens to burn. Must be less than or equal to this ITokenMinter's account balance of the given `_burnToken`.\",\"burnToken\":\"burnable token.\"}},\"getLocalToken(uint32,bytes32)\":{\"params\":{\"remoteDomain\":\"Remote domain\",\"remoteToken\":\"Remote token\"},\"returns\":{\"_0\":\"local token address\"}},\"mint(uint32,bytes32,address,uint256)\":{\"details\":\"reverts if the (`sourceDomain`, `burnToken`) pair does not map to a nonzero local token address. This mapping can be queried using getLocalToken().\",\"params\":{\"amount\":\"Amount of tokens to mint. Must be less than or equal to the minterAllowance of this TokenMinter for given `_mintToken`.\",\"burnToken\":\"Burned token address as bytes32.\",\"sourceDomain\":\"Source domain where `burnToken` was burned.\",\"to\":\"Address to receive minted tokens, corresponding to `burnToken`, on this domain.\"},\"returns\":{\"mintToken\":\"token minted.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"burn(address,uint256)\":{\"notice\":\"Burn tokens owned by this ITokenMinter.\"},\"getLocalToken(uint32,bytes32)\":{\"notice\":\"Get the local token associated with the given remote domain and token.\"},\"mint(uint32,bytes32,address,uint256)\":{\"notice\":\"Mints `amount` of local tokens corresponding to the given (`sourceDomain`, `burnToken`) pair, to `to` address.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MockTokenMinter.sol\":\"ITokenMinter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MockTokenMinter.sol\":{\"keccak256\":\"0x583efb59b744fc37c0634811ddca5bcb6108d9a9276e756dd65b61a4cbac9f7d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://83b0308f4aa30afa825c62acdada12301acf2a9a94db78895919e31057611892\",\"dweb:/ipfs/QmPcvdQMe37RUN8YVuusgHtdEjE1NTd4XMVwbnMVCNpUBi\"]}},\"version\":1}"},"hashes":{"burn(address,uint256)":"9dc29fac","burnLimitsPerMessage(address)":"a56ec632","getLocalToken(uint32,bytes32)":"78a0565e","mint(uint32,bytes32,address,uint256)":"d54de06f"}},"solidity/MockTokenMinter.sol:MockTokenMinter":{"code":"0x608060405234801561001057600080fd5b506040516106ee3803806106ee83398101604081905261002f91610054565b600180546001600160a01b0319166001600160a01b0392909216919091179055610084565b60006020828403121561006657600080fd5b81516001600160a01b038116811461007d57600080fd5b9392505050565b61065b806100936000396000f3fe608060405234801561001057600080fd5b506004361061007d5760003560e01c80639dc29fac1161005b5780639dc29fac14610186578063a56ec63214610199578063c7823e2b146101c7578063d54de06f146101fe57600080fd5b80636a879ac414610082578063770fc1f0146100f557806378a0565e1461013f575b600080fd5b6100f361009036600461051b565b63ffffffff929092166000908152602081815260408083209383529290522080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff909216919091179055565b005b6001546101159073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61011561014d366004610557565b63ffffffff91909116600090815260208181526040808320938352929052205473ffffffffffffffffffffffffffffffffffffffff1690565b6100f3610194366004610581565b610211565b6101b96101a736600461059d565b60026020526000908152604090205481565b604051908152602001610136565b6100f36101d5366004610581565b73ffffffffffffffffffffffffffffffffffffffff909116600090815260026020526040902055565b61011561020c3660046105bf565b61031b565b60015473ffffffffffffffffffffffffffffffffffffffff163314610297576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f43616c6c6572206e6f74206c6f63616c20546f6b656e4d657373656e6765720060448201526064015b60405180910390fd5b6040517f42966c680000000000000000000000000000000000000000000000000000000081526004810182905273ffffffffffffffffffffffffffffffffffffffff8316906342966c6890602401600060405180830381600087803b1580156102ff57600080fd5b505af1158015610313573d6000803e3d6000fd5b505050505050565b60015460009073ffffffffffffffffffffffffffffffffffffffff16331461039f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f43616c6c6572206e6f74206c6f63616c20546f6b656e4d657373656e67657200604482015260640161028e565b5063ffffffff841660009081526020818152604080832086845290915290205473ffffffffffffffffffffffffffffffffffffffff168061043c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4d696e7420746f6b656e206e6f7420737570706f727465640000000000000000604482015260640161028e565b6040517f40c10f1900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8481166004830152602482018490528216906340c10f19906044016020604051808303816000875af11580156104b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d59190610603565b50949350505050565b803563ffffffff811681146104f257600080fd5b919050565b803573ffffffffffffffffffffffffffffffffffffffff811681146104f257600080fd5b60008060006060848603121561053057600080fd5b610539846104de565b92506020840135915061054e604085016104f7565b90509250925092565b6000806040838503121561056a57600080fd5b610573836104de565b946020939093013593505050565b6000806040838503121561059457600080fd5b610573836104f7565b6000602082840312156105af57600080fd5b6105b8826104f7565b9392505050565b600080600080608085870312156105d557600080fd5b6105de856104de565b9350602085013592506105f3604086016104f7565b9396929550929360600135925050565b60006020828403121561061557600080fd5b815180151581146105b857600080fdfea2646970667358221220dd305bbb874df5df5ebd93550fd296a25a4152acafb318f1ae3083cbd42e7b0364736f6c63430008110033","runtime-code":"0x608060405234801561001057600080fd5b506004361061007d5760003560e01c80639dc29fac1161005b5780639dc29fac14610186578063a56ec63214610199578063c7823e2b146101c7578063d54de06f146101fe57600080fd5b80636a879ac414610082578063770fc1f0146100f557806378a0565e1461013f575b600080fd5b6100f361009036600461051b565b63ffffffff929092166000908152602081815260408083209383529290522080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff909216919091179055565b005b6001546101159073ffffffffffffffffffffffffffffffffffffffff1681565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020015b60405180910390f35b61011561014d366004610557565b63ffffffff91909116600090815260208181526040808320938352929052205473ffffffffffffffffffffffffffffffffffffffff1690565b6100f3610194366004610581565b610211565b6101b96101a736600461059d565b60026020526000908152604090205481565b604051908152602001610136565b6100f36101d5366004610581565b73ffffffffffffffffffffffffffffffffffffffff909116600090815260026020526040902055565b61011561020c3660046105bf565b61031b565b60015473ffffffffffffffffffffffffffffffffffffffff163314610297576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f43616c6c6572206e6f74206c6f63616c20546f6b656e4d657373656e6765720060448201526064015b60405180910390fd5b6040517f42966c680000000000000000000000000000000000000000000000000000000081526004810182905273ffffffffffffffffffffffffffffffffffffffff8316906342966c6890602401600060405180830381600087803b1580156102ff57600080fd5b505af1158015610313573d6000803e3d6000fd5b505050505050565b60015460009073ffffffffffffffffffffffffffffffffffffffff16331461039f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f43616c6c6572206e6f74206c6f63616c20546f6b656e4d657373656e67657200604482015260640161028e565b5063ffffffff841660009081526020818152604080832086845290915290205473ffffffffffffffffffffffffffffffffffffffff168061043c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601860248201527f4d696e7420746f6b656e206e6f7420737570706f727465640000000000000000604482015260640161028e565b6040517f40c10f1900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff8481166004830152602482018490528216906340c10f19906044016020604051808303816000875af11580156104b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d59190610603565b50949350505050565b803563ffffffff811681146104f257600080fd5b919050565b803573ffffffffffffffffffffffffffffffffffffffff811681146104f257600080fd5b60008060006060848603121561053057600080fd5b610539846104de565b92506020840135915061054e604085016104f7565b90509250925092565b6000806040838503121561056a57600080fd5b610573836104de565b946020939093013593505050565b6000806040838503121561059457600080fd5b610573836104f7565b6000602082840312156105af57600080fd5b6105b8826104f7565b9392505050565b600080600080608085870312156105d557600080fd5b6105de856104de565b9350602085013592506105f3604086016104f7565b9396929550929360600135925050565b60006020828403121561061557600080fd5b815180151581146105b857600080fdfea2646970667358221220dd305bbb874df5df5ebd93550fd296a25a4152acafb318f1ae3083cbd42e7b0364736f6c63430008110033","info":{"source":"// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ITokenMinter {\n    /**\n     * @notice Mints `amount` of local tokens corresponding to the\n     * given (`sourceDomain`, `burnToken`) pair, to `to` address.\n     * @dev reverts if the (`sourceDomain`, `burnToken`) pair does not\n     * map to a nonzero local token address. This mapping can be queried using\n     * getLocalToken().\n     * @param sourceDomain Source domain where `burnToken` was burned.\n     * @param burnToken Burned token address as bytes32.\n     * @param to Address to receive minted tokens, corresponding to `burnToken`,\n     * on this domain.\n     * @param amount Amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of this TokenMinter for given `_mintToken`.\n     * @return mintToken token minted.\n     */\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken);\n\n    /**\n     * @notice Burn tokens owned by this ITokenMinter.\n     * @param burnToken burnable token.\n     * @param amount amount of tokens to burn. Must be less than or equal to this ITokenMinter's\n     * account balance of the given `_burnToken`.\n     */\n    function burn(address burnToken, uint256 amount) external;\n\n    /**\n     * @notice Get the local token associated with the given remote domain and token.\n     * @param remoteDomain Remote domain\n     * @param remoteToken Remote token\n     * @return local token address\n     */\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address);\n\n    // local token (address) =\u003e maximum burn amounts per message\n    function burnLimitsPerMessage(address token) external view returns (uint256);\n}\n\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n/**\n * @title IMintBurnToken\n * @notice interface for mintable and burnable ERC20 token\n */\ninterface IMintBurnToken is IERC20 {\n    /**\n     * @dev Function to mint tokens\n     * @param to The address that will receive the minted tokens.\n     * @param amount The amount of tokens to mint. Must be less than or equal\n     * to the minterAllowance of the caller.\n     * @return A boolean that indicates if the operation was successful.\n     */\n    function mint(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev allows a minter to burn some of its own tokens\n     * Validates that caller is a minter and that sender is not blacklisted\n     * amount is less than or equal to the minter's account balance\n     * @param amount uint256 the amount of tokens to be burned\n     */\n    function burn(uint256 amount) external;\n}\n\ncontract MockTokenMinter is ITokenMinter {\n    mapping(uint32 =\u003e mapping(bytes32 =\u003e address)) internal localTokens;\n    address public localTokenMessenger;\n    mapping(address =\u003e uint256) public burnLimitsPerMessage;\n\n    constructor(address localTokenMessenger_) {\n        localTokenMessenger = localTokenMessenger_;\n    }\n\n    function setLocalToken(\n        uint32 remoteDomain,\n        bytes32 remoteToken,\n        address localToken\n    ) external {\n        localTokens[remoteDomain][remoteToken] = localToken;\n    }\n\n    function setBurnLimitPerMessage(address token, uint256 limit) external {\n        burnLimitsPerMessage[token] = limit;\n    }\n\n    function mint(\n        uint32 sourceDomain,\n        bytes32 burnToken,\n        address to,\n        uint256 amount\n    ) external returns (address mintToken) {\n        require(msg.sender == localTokenMessenger, \"Caller not local TokenMessenger\");\n        mintToken = localTokens[sourceDomain][burnToken];\n        require(mintToken != address(0), \"Mint token not supported\");\n        IMintBurnToken(mintToken).mint(to, amount);\n    }\n\n    function burn(address burnToken, uint256 amount) external {\n        require(msg.sender == localTokenMessenger, \"Caller not local TokenMessenger\");\n        IMintBurnToken(burnToken).burn(amount);\n    }\n\n    function getLocalToken(uint32 remoteDomain, bytes32 remoteToken) external view returns (address) {\n        return localTokens[remoteDomain][remoteToken];\n    }\n}\n","language":"Solidity","languageVersion":"0.8.17","compilerVersion":"0.8.17","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"5334:1460:0:-:0;;;5556:101;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5608:19;:42;;-1:-1:-1;;;;;;5608:42:0;-1:-1:-1;;;;;5608:42:0;;;;;;;;;;5334:1460;;14:290:1;84:6;137:2;125:9;116:7;112:23;108:32;105:52;;;153:1;150;143:12;105:52;179:16;;-1:-1:-1;;;;;224:31:1;;214:42;;204:70;;270:1;267;260:12;204:70;293:5;14:290;-1:-1:-1;;;14:290:1:o;:::-;5334:1460:0;;;;;;","srcMapRuntime":"5334:1460:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;5663:192;;;;;;:::i;:::-;5797:25;;;;;:11;:25;;;;;;;;;;;:38;;;;;;;:51;;;;;;;;;;;;;;5663:192;;;5454:34;;;;;;;;;;;;890:42:1;878:55;;;860:74;;848:2;833:18;5454:34:0;;;;;;;;6633:159;;;;;;:::i;:::-;6747:25;;;;;6721:7;6747:25;;;;;;;;;;;:38;;;;;;;;;;;6633:159;6427:200;;;;;;:::i;:::-;;:::i;5494:55::-;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;1798:25:1;;;1786:2;1771:18;5494:55:0;1652:177:1;5861:123:0;;;;;;:::i;:::-;5942:27;;;;;;;;:20;:27;;;;;:35;5861:123;5990:431;;;;;;:::i;:::-;;:::i;6427:200::-;6517:19;;;;6503:10;:33;6495:77;;;;;;;2436:2:1;6495:77:0;;;2418:21:1;2475:2;2455:18;;;2448:30;2514:33;2494:18;;;2487:61;2565:18;;6495:77:0;;;;;;;;;6582:38;;;;;;;;1798:25:1;;;6582:30:0;;;;;;1771:18:1;;6582:38:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6427:200;;:::o;5990:431::-;6179:19;;6128:17;;6179:19;;6165:10;:33;6157:77;;;;;;;2436:2:1;6157:77:0;;;2418:21:1;2475:2;2455:18;;;2448:30;2514:33;2494:18;;;2487:61;2565:18;;6157:77:0;2234:355:1;6157:77:0;-1:-1:-1;6256:25:0;;;:11;:25;;;;;;;;;;;:36;;;;;;;;;;;;6302:60;;;;;;;2796:2:1;6302:60:0;;;2778:21:1;2835:2;2815:18;;;2808:30;2874:26;2854:18;;;2847:54;2918:18;;6302:60:0;2594:348:1;6302:60:0;6372:42;;;;;:30;3139:55:1;;;6372:42:0;;;3121:74:1;3211:18;;;3204:34;;;6372:30:0;;;;;3094:18:1;;6372:42:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;5990:431;;;;;;:::o;14:163:1:-;81:20;;141:10;130:22;;120:33;;110:61;;167:1;164;157:12;110:61;14:163;;;:::o;182:196::-;250:20;;310:42;299:54;;289:65;;279:93;;368:1;365;358:12;383:326;459:6;467;475;528:2;516:9;507:7;503:23;499:32;496:52;;;544:1;541;534:12;496:52;567:28;585:9;567:28;:::i;:::-;557:38;;642:2;631:9;627:18;614:32;604:42;;665:38;699:2;688:9;684:18;665:38;:::i;:::-;655:48;;383:326;;;;;:::o;945:252::-;1012:6;1020;1073:2;1061:9;1052:7;1048:23;1044:32;1041:52;;;1089:1;1086;1079:12;1041:52;1112:28;1130:9;1112:28;:::i;:::-;1102:38;1187:2;1172:18;;;;1159:32;;-1:-1:-1;;;945:252:1:o;1202:254::-;1270:6;1278;1331:2;1319:9;1310:7;1306:23;1302:32;1299:52;;;1347:1;1344;1337:12;1299:52;1370:29;1389:9;1370:29;:::i;1461:186::-;1520:6;1573:2;1561:9;1552:7;1548:23;1544:32;1541:52;;;1589:1;1586;1579:12;1541:52;1612:29;1631:9;1612:29;:::i;:::-;1602:39;1461:186;-1:-1:-1;;;1461:186:1:o;1834:395::-;1919:6;1927;1935;1943;1996:3;1984:9;1975:7;1971:23;1967:33;1964:53;;;2013:1;2010;2003:12;1964:53;2036:28;2054:9;2036:28;:::i;:::-;2026:38;;2111:2;2100:9;2096:18;2083:32;2073:42;;2134:38;2168:2;2157:9;2153:18;2134:38;:::i;:::-;1834:395;;;;-1:-1:-1;2124:48:1;;2219:2;2204:18;2191:32;;-1:-1:-1;;1834:395:1:o;3249:277::-;3316:6;3369:2;3357:9;3348:7;3344:23;3340:32;3337:52;;;3385:1;3382;3375:12;3337:52;3417:9;3411:16;3470:5;3463:13;3456:21;3449:5;3446:32;3436:60;;3492:1;3489;3482:12","abiDefinition":[{"inputs":[{"internalType":"address","name":"localTokenMessenger_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"address","name":"burnToken","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burn","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"burnLimitsPerMessage","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"bytes32","name":"remoteToken","type":"bytes32"}],"name":"getLocalToken","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"localTokenMessenger","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"sourceDomain","type":"uint32"},{"internalType":"bytes32","name":"burnToken","type":"bytes32"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[{"internalType":"address","name":"mintToken","type":"address"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"token","type":"address"},{"internalType":"uint256","name":"limit","type":"uint256"}],"name":"setBurnLimitPerMessage","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint32","name":"remoteDomain","type":"uint32"},{"internalType":"bytes32","name":"remoteToken","type":"bytes32"},{"internalType":"address","name":"localToken","type":"address"}],"name":"setLocalToken","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"burn(address,uint256)":{"notice":"Burn tokens owned by this ITokenMinter."},"getLocalToken(uint32,bytes32)":{"notice":"Get the local token associated with the given remote domain and token."},"mint(uint32,bytes32,address,uint256)":{"notice":"Mints `amount` of local tokens corresponding to the given (`sourceDomain`, `burnToken`) pair, to `to` address."}},"version":1},"developerDoc":{"kind":"dev","methods":{"burn(address,uint256)":{"params":{"amount":"amount of tokens to burn. Must be less than or equal to this ITokenMinter's account balance of the given `_burnToken`.","burnToken":"burnable token."}},"getLocalToken(uint32,bytes32)":{"params":{"remoteDomain":"Remote domain","remoteToken":"Remote token"},"returns":{"_0":"local token address"}},"mint(uint32,bytes32,address,uint256)":{"details":"reverts if the (`sourceDomain`, `burnToken`) pair does not map to a nonzero local token address. This mapping can be queried using getLocalToken().","params":{"amount":"Amount of tokens to mint. Must be less than or equal to the minterAllowance of this TokenMinter for given `_mintToken`.","burnToken":"Burned token address as bytes32.","sourceDomain":"Source domain where `burnToken` was burned.","to":"Address to receive minted tokens, corresponding to `burnToken`, on this domain."},"returns":{"mintToken":"token minted."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"localTokenMessenger_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"burnToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"burnLimitsPerMessage\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"remoteToken\",\"type\":\"bytes32\"}],\"name\":\"getLocalToken\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"localTokenMessenger\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"sourceDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"burnToken\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"mintToken\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"setBurnLimitPerMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"remoteDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"remoteToken\",\"type\":\"bytes32\"},{\"internalType\":\"address\",\"name\":\"localToken\",\"type\":\"address\"}],\"name\":\"setLocalToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"burn(address,uint256)\":{\"params\":{\"amount\":\"amount of tokens to burn. Must be less than or equal to this ITokenMinter's account balance of the given `_burnToken`.\",\"burnToken\":\"burnable token.\"}},\"getLocalToken(uint32,bytes32)\":{\"params\":{\"remoteDomain\":\"Remote domain\",\"remoteToken\":\"Remote token\"},\"returns\":{\"_0\":\"local token address\"}},\"mint(uint32,bytes32,address,uint256)\":{\"details\":\"reverts if the (`sourceDomain`, `burnToken`) pair does not map to a nonzero local token address. This mapping can be queried using getLocalToken().\",\"params\":{\"amount\":\"Amount of tokens to mint. Must be less than or equal to the minterAllowance of this TokenMinter for given `_mintToken`.\",\"burnToken\":\"Burned token address as bytes32.\",\"sourceDomain\":\"Source domain where `burnToken` was burned.\",\"to\":\"Address to receive minted tokens, corresponding to `burnToken`, on this domain.\"},\"returns\":{\"mintToken\":\"token minted.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"burn(address,uint256)\":{\"notice\":\"Burn tokens owned by this ITokenMinter.\"},\"getLocalToken(uint32,bytes32)\":{\"notice\":\"Get the local token associated with the given remote domain and token.\"},\"mint(uint32,bytes32,address,uint256)\":{\"notice\":\"Mints `amount` of local tokens corresponding to the given (`sourceDomain`, `burnToken`) pair, to `to` address.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MockTokenMinter.sol\":\"MockTokenMinter\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MockTokenMinter.sol\":{\"keccak256\":\"0x583efb59b744fc37c0634811ddca5bcb6108d9a9276e756dd65b61a4cbac9f7d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://83b0308f4aa30afa825c62acdada12301acf2a9a94db78895919e31057611892\",\"dweb:/ipfs/QmPcvdQMe37RUN8YVuusgHtdEjE1NTd4XMVwbnMVCNpUBi\"]}},\"version\":1}"},"hashes":{"burn(address,uint256)":"9dc29fac","burnLimitsPerMessage(address)":"a56ec632","getLocalToken(uint32,bytes32)":"78a0565e","localTokenMessenger()":"770fc1f0","mint(uint32,bytes32,address,uint256)":"d54de06f","setBurnLimitPerMessage(address,uint256)":"c7823e2b","setLocalToken(uint32,bytes32,address)":"6a879ac4"}}}