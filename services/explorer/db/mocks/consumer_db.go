// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	context "context"

	gorm "gorm.io/gorm"

	mock "github.com/stretchr/testify/mock"

	model "github.com/synapsecns/sanguine/services/explorer/graphql/server/graph/model"

	sql "github.com/synapsecns/sanguine/services/explorer/db/sql"
)

// ConsumerDB is an autogenerated mock type for the ConsumerDB type
type ConsumerDB struct {
	mock.Mock
}

// BridgeEventCount provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) BridgeEventCount(ctx context.Context, query string) (uint64, error) {
	ret := _m.Called(ctx, query)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, string) uint64); ok {
		r0 = rf(ctx, query)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllChainIDs provides a mock function with given fields: ctx
func (_m *ConsumerDB) GetAllChainIDs(ctx context.Context) ([]uint32, error) {
	ret := _m.Called(ctx)

	var r0 []uint32
	if rf, ok := ret.Get(0).(func(context.Context) []uint32); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]uint32)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBridgeStatistic provides a mock function with given fields: ctx, subQuery
func (_m *ConsumerDB) GetBridgeStatistic(ctx context.Context, subQuery string) (*string, error) {
	ret := _m.Called(ctx, subQuery)

	var r0 *string
	if rf, ok := ret.Get(0).(func(context.Context, string) *string); ok {
		r0 = rf(ctx, subQuery)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, subQuery)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetHistoricalData provides a mock function with given fields: ctx, subQuery, typeArg, filter
func (_m *ConsumerDB) GetHistoricalData(ctx context.Context, subQuery string, typeArg *model.HistoricalResultType, filter string) (*model.HistoricalResult, error) {
	ret := _m.Called(ctx, subQuery, typeArg, filter)

	var r0 *model.HistoricalResult
	if rf, ok := ret.Get(0).(func(context.Context, string, *model.HistoricalResultType, string) *model.HistoricalResult); ok {
		r0 = rf(ctx, subQuery, typeArg, filter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*model.HistoricalResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, *model.HistoricalResultType, string) error); ok {
		r1 = rf(ctx, subQuery, typeArg, filter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetKappaFromTxHash provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) GetKappaFromTxHash(ctx context.Context, query string) (*string, error) {
	ret := _m.Called(ctx, query)

	var r0 *string
	if rf, ok := ret.Get(0).(func(context.Context, string) *string); ok {
		r0 = rf(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSwapSuccess provides a mock function with given fields: ctx, kappa, chainID
func (_m *ConsumerDB) GetSwapSuccess(ctx context.Context, kappa string, chainID uint32) (*bool, error) {
	ret := _m.Called(ctx, kappa, chainID)

	var r0 *bool
	if rf, ok := ret.Get(0).(func(context.Context, string, uint32) *bool); ok {
		r0 = rf(ctx, kappa, chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bool)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, uint32) error); ok {
		r1 = rf(ctx, kappa, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTokenAddressesByChainID provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) GetTokenAddressesByChainID(ctx context.Context, query string) ([]string, error) {
	ret := _m.Called(ctx, query)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = rf(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactionCountForEveryAddress provides a mock function with given fields: ctx, subQuery
func (_m *ConsumerDB) GetTransactionCountForEveryAddress(ctx context.Context, subQuery string) ([]*model.AddressRanking, error) {
	ret := _m.Called(ctx, subQuery)

	var r0 []*model.AddressRanking
	if rf, ok := ret.Get(0).(func(context.Context, string) []*model.AddressRanking); ok {
		r0 = rf(ctx, subQuery)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.AddressRanking)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, subQuery)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTxHashFromKappa provides a mock function with given fields: ctx, kappa
func (_m *ConsumerDB) GetTxHashFromKappa(ctx context.Context, kappa string) (*string, error) {
	ret := _m.Called(ctx, kappa)

	var r0 *string
	if rf, ok := ret.Get(0).(func(context.Context, string) *string); ok {
		r0 = rf(ctx, kappa)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, kappa)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PartialInfosFromIdentifiers provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) PartialInfosFromIdentifiers(ctx context.Context, query string) ([]*model.PartialInfo, error) {
	ret := _m.Called(ctx, query)

	var r0 []*model.PartialInfo
	if rf, ok := ret.Get(0).(func(context.Context, string) []*model.PartialInfo); ok {
		r0 = rf(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PartialInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ReadBlockNumberByChainID provides a mock function with given fields: ctx, eventType, chainID
func (_m *ConsumerDB) ReadBlockNumberByChainID(ctx context.Context, eventType int8, chainID uint32) (*uint64, error) {
	ret := _m.Called(ctx, eventType, chainID)

	var r0 *uint64
	if rf, ok := ret.Get(0).(func(context.Context, int8, uint32) *uint64); ok {
		r0 = rf(ctx, eventType, chainID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*uint64)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int8, uint32) error); ok {
		r1 = rf(ctx, eventType, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RetrieveLastBlock provides a mock function with given fields: ctx, chainID
func (_m *ConsumerDB) RetrieveLastBlock(ctx context.Context, chainID uint32) (uint64, error) {
	ret := _m.Called(ctx, chainID)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, uint32) uint64); ok {
		r0 = rf(ctx, chainID)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, uint32) error); ok {
		r1 = rf(ctx, chainID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StoreEvent provides a mock function with given fields: ctx, bridgeEvent, swapEvent
func (_m *ConsumerDB) StoreEvent(ctx context.Context, bridgeEvent *sql.BridgeEvent, swapEvent *sql.SwapEvent) error {
	ret := _m.Called(ctx, bridgeEvent, swapEvent)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *sql.BridgeEvent, *sql.SwapEvent) error); ok {
		r0 = rf(ctx, bridgeEvent, swapEvent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreLastBlock provides a mock function with given fields: ctx, chainID, blockNumber
func (_m *ConsumerDB) StoreLastBlock(ctx context.Context, chainID uint32, blockNumber uint64) error {
	ret := _m.Called(ctx, chainID, blockNumber)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint64) error); ok {
		r0 = rf(ctx, chainID, blockNumber)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UNSAFE_DB provides a mock function with given fields:
func (_m *ConsumerDB) UNSAFE_DB() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

type mockConstructorTestingTNewConsumerDB interface {
	mock.TestingT
	Cleanup(func())
}

// NewConsumerDB creates a new instance of ConsumerDB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewConsumerDB(t mockConstructorTestingTNewConsumerDB) *ConsumerDB {
	mock := &ConsumerDB{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
