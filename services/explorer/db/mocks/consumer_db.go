// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	context "context"

	gorm "gorm.io/gorm"

	mock "github.com/stretchr/testify/mock"

	model "github.com/synapsecns/sanguine/services/explorer/graphql/server/graph/model"

	sql "github.com/synapsecns/sanguine/services/explorer/db/sql"
)

// ConsumerDB is an autogenerated mock type for the ConsumerDB type
type ConsumerDB struct {
	mock.Mock
}

// GetAddressRanking provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) GetAddressRanking(ctx context.Context, query string) ([]*model.AddressRanking, error) {
	ret := _m.Called(ctx, query)

	var r0 []*model.AddressRanking
	if rf, ok := ret.Get(0).(func(context.Context, string) []*model.AddressRanking); ok {
		r0 = rf(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.AddressRanking)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAllChainIDs provides a mock function with given fields: ctx
func (_m *ConsumerDB) GetAllChainIDs(ctx context.Context) ([]int, error) {
	ret := _m.Called(ctx)

	var r0 []int
	if rf, ok := ret.Get(0).(func(context.Context) []int); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBridgeEvent provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) GetBridgeEvent(ctx context.Context, query string) (*sql.BridgeEvent, error) {
	ret := _m.Called(ctx, query)

	var r0 *sql.BridgeEvent
	if rf, ok := ret.Get(0).(func(context.Context, string) *sql.BridgeEvent); ok {
		r0 = rf(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*sql.BridgeEvent)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDateResults provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) GetDateResults(ctx context.Context, query string) ([]*model.DateResult, error) {
	ret := _m.Called(ctx, query)

	var r0 []*model.DateResult
	if rf, ok := ret.Get(0).(func(context.Context, string) []*model.DateResult); ok {
		r0 = rf(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.DateResult)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFloat64 provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) GetFloat64(ctx context.Context, query string) (float64, error) {
	ret := _m.Called(ctx, query)

	var r0 float64
	if rf, ok := ret.Get(0).(func(context.Context, string) float64); ok {
		r0 = rf(ctx, query)
	} else {
		r0 = ret.Get(0).(float64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStringArray provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) GetStringArray(ctx context.Context, query string) ([]string, error) {
	ret := _m.Called(ctx, query)

	var r0 []string
	if rf, ok := ret.Get(0).(func(context.Context, string) []string); ok {
		r0 = rf(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUint64 provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) GetUint64(ctx context.Context, query string) (uint64, error) {
	ret := _m.Called(ctx, query)

	var r0 uint64
	if rf, ok := ret.Get(0).(func(context.Context, string) uint64); ok {
		r0 = rf(ctx, query)
	} else {
		r0 = ret.Get(0).(uint64)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PartialInfosFromIdentifiers provides a mock function with given fields: ctx, query
func (_m *ConsumerDB) PartialInfosFromIdentifiers(ctx context.Context, query string) ([]*model.PartialInfo, error) {
	ret := _m.Called(ctx, query)

	var r0 []*model.PartialInfo
	if rf, ok := ret.Get(0).(func(context.Context, string) []*model.PartialInfo); ok {
		r0 = rf(ctx, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*model.PartialInfo)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StoreEvent provides a mock function with given fields: ctx, bridgeEvent, swapEvent
func (_m *ConsumerDB) StoreEvent(ctx context.Context, bridgeEvent *sql.BridgeEvent, swapEvent *sql.SwapEvent) error {
	ret := _m.Called(ctx, bridgeEvent, swapEvent)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *sql.BridgeEvent, *sql.SwapEvent) error); ok {
		r0 = rf(ctx, bridgeEvent, swapEvent)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// StoreLastBlock provides a mock function with given fields: ctx, chainID, blockNumber
func (_m *ConsumerDB) StoreLastBlock(ctx context.Context, chainID uint32, blockNumber uint64) error {
	ret := _m.Called(ctx, chainID, blockNumber)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uint32, uint64) error); ok {
		r0 = rf(ctx, chainID, blockNumber)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UNSAFE_DB provides a mock function with given fields:
func (_m *ConsumerDB) UNSAFE_DB() *gorm.DB {
	ret := _m.Called()

	var r0 *gorm.DB
	if rf, ok := ret.Get(0).(func() *gorm.DB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	return r0
}

type mockConstructorTestingTNewConsumerDB interface {
	mock.TestingT
	Cleanup(func())
}

// NewConsumerDB creates a new instance of ConsumerDB. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewConsumerDB(t mockConstructorTestingTNewConsumerDB) *ConsumerDB {
	mock := &ConsumerDB{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
