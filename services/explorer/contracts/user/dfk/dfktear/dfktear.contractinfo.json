{"solidity/TearBridge.sol:Context":{"code":"0x","runtime-code":"0x","info":{"source":"\n\n//\ninterface ISynMessagingReceiver {\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    // mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    /**\n     * @notice Called by MessageBus\n     * @dev MUST be permissioned to trusted source apps via trustedRemote\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external;\n}\n\n//\ninterface IMessageBus {\n    /**\n     * @notice Sends a message to a receiving contract address on another chain.\n     * Sender must make sure that the message is unique and not a duplicate message.\n     * @param _receiver The bytes32 address of the destination contract to be called\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _message The arbitrary payload to pass to the destination chain receiver\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits\n     */\n    function sendMessage(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) external payable;\n\n    /**\n     * @notice Relayer executes messages through an authenticated method to the destination receiver based on the originating transaction on source chain\n     * @param _srcChainId Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\n     * @param _srcAddress Originating bytes address of the message sender on the srcChain\n     * @param _dstAddress Destination address that the arbitrary message will be passed to\n     * @param _gasLimit Gas limit to be passed alongside the message, depending on the fee paid on srcChain\n     * @param _nonce Nonce from origin chain\n     * @param _message Arbitrary message payload to pass to the destination chain receiver\n     * @param _messageId MessageId for uniqueness of messages (alongisde nonce)\n     */\n    function executeMessage(\n        uint256 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint256 _gasLimit,\n        uint256 _nonce,\n        bytes calldata _message,\n        bytes32 _messageId\n    ) external;\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateFee(uint256 _dstChainId, bytes calldata _options) external returns (uint256);\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     */\n    function withdrawFee(address _account) external;\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n//\nabstract contract SynMessagingReceiver is ISynMessagingReceiver, Ownable {\n    address public messageBus;\n\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    event SetTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress);\n\n    /**\n     * @notice Executes a message called by MessageBus (MessageBusReceiver)\n     * @dev Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external {\n        // Must be called by the MessageBus/MessageBus for security\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        // Must also be from a trusted source app\n        require(_srcAddress == trustedRemoteLookup[_srcChainId], \"Invalid source sending app\");\n\n        _handleMessage(_srcAddress, _srcChainId, _message, _executor);\n    }\n\n    // Logic here handling messsage contents\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal virtual;\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal virtual {\n        require(trustedRemoteLookup[_dstChainId] != bytes32(0), \"Receiver not trusted remote\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    //** Config Functions */\n    function setMessageBus(address _messageBus) public onlyOwner {\n        messageBus = _messageBus;\n    }\n\n    // allow owner to set trusted addresses allowed to be source senders\n    function setTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //** View functions */\n    function getTrustedRemote(uint256 _chainId) external view returns (bytes32 trustedRemote) {\n        return trustedRemoteLookup[_chainId];\n    }\n}\n\n//\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n//\n/**\n * @dev Interface of Inventory Items.\n */\ninterface IInventoryItem is IERC20 {\n    /**\n     * @dev Burns tokens.\n     */\n    function burnFrom(address from, uint256 amount) external;\n\n    function mint(address to, uint256 amount) external;\n}\n\n//\ncontract TearBridge is SynMessagingReceiver {\n    address public immutable gaiaTears;\n    uint256 public msgGasLimit;\n\n    struct MessageFormat {\n        address dstUser;\n        uint256 dstTearAmount;\n    }\n\n    event GaiaSent(address indexed dstUser, uint256 arrivalChainId);\n    event GaiaArrived(address indexed dstUser, uint256 arrivalChainId);\n\n    constructor(address _messageBus, address _gaiaTear) {\n        messageBus = _messageBus;\n        gaiaTears = _gaiaTear;\n    }\n\n    function _createMessage(address _dstUserAddress, uint256 _dstTearAmount) internal pure returns (bytes memory) {\n        // create the message here from the nested struct\n        MessageFormat memory msgFormat = MessageFormat({dstUser: _dstUserAddress, dstTearAmount: _dstTearAmount});\n        return abi.encode(msgFormat);\n    }\n\n    function _decodeMessage(bytes memory _message) internal pure returns (MessageFormat memory) {\n        MessageFormat memory decodedMessage = abi.decode(_message, (MessageFormat));\n        return decodedMessage;\n    }\n\n    function decodeMessage(bytes memory _message) external pure returns (MessageFormat memory) {\n        return _decodeMessage(_message);\n    }\n\n\n    function _createOptions() internal view returns (bytes memory) {\n        return abi.encodePacked(uint16(1), msgGasLimit);\n    }\n\n    function sendTear(uint256 _tearsAmount, uint256 _dstChainId) external payable {\n        uint256 tearsAmount = _tearsAmount;\n        uint256 dstChainId = _dstChainId;\n        // Tears now burnt, equivalent amount will be bridged to dstChainId\n        IInventoryItem(gaiaTears).burnFrom(msg.sender, tearsAmount);\n\n        bytes32 receiver = trustedRemoteLookup[dstChainId];\n        bytes memory message = _createMessage(msg.sender, tearsAmount);\n        bytes memory options = _createOptions();\n\n        _send(receiver, dstChainId, message, options);\n        emit GaiaSent(msg.sender, tearsAmount);\n    }\n\n    // Function called by executeMessage() - handleMessage will handle the gaia tear mint\n    // executeMessage() handles permissioning checks\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal override {\n        MessageFormat memory passedMsg = _decodeMessage(_message);\n        address dstUser = passedMsg.dstUser;\n        uint256 dstTearAmount = passedMsg.dstTearAmount;\n        IInventoryItem(gaiaTears).mint(dstUser, dstTearAmount);\n        emit GaiaArrived(dstUser, dstTearAmount);\n    }\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal override {\n        bytes32 trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote != bytes32(0), \"No remote app set for dst chain\");\n        require(trustedRemote == _receiver, \"Receiver is not in trusted remote apps\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    function setMsgGasLimit(uint256 _msgGasLimit) external onlyOwner {\n        msgGasLimit = _msgGasLimit;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.","kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"details\":\"Provides information about the current execution context, including the sender of the transaction and its data. While these are generally available via msg.sender and msg.data, they should not be accessed in such a direct manner, since when dealing with meta-transactions the account sending and paying for execution may not be the actual sender (as far as an application is concerned). This contract is only required for intermediate, library-like contracts.\",\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TearBridge.sol\":\"Context\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TearBridge.sol\":{\"keccak256\":\"0x7a7a5e375ca994e2037e477a31dce5c30a7607f3af2e2b34eb9dac2facbc3748\",\"urls\":[\"bzz-raw://8572be8c0a68120a7ddb61d39e2ceb75d6e07b37b04b8fa9654d87215ac94775\",\"dweb:/ipfs/QmYabWxXUCYW9QZwjRVQd8kQKG9ynmTsJ48kTXast2qxhS\"]}},\"version\":1}"},"hashes":{}},"solidity/TearBridge.sol:IERC20":{"code":"0x","runtime-code":"0x","info":{"source":"\n\n//\ninterface ISynMessagingReceiver {\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    // mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    /**\n     * @notice Called by MessageBus\n     * @dev MUST be permissioned to trusted source apps via trustedRemote\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external;\n}\n\n//\ninterface IMessageBus {\n    /**\n     * @notice Sends a message to a receiving contract address on another chain.\n     * Sender must make sure that the message is unique and not a duplicate message.\n     * @param _receiver The bytes32 address of the destination contract to be called\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _message The arbitrary payload to pass to the destination chain receiver\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits\n     */\n    function sendMessage(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) external payable;\n\n    /**\n     * @notice Relayer executes messages through an authenticated method to the destination receiver based on the originating transaction on source chain\n     * @param _srcChainId Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\n     * @param _srcAddress Originating bytes address of the message sender on the srcChain\n     * @param _dstAddress Destination address that the arbitrary message will be passed to\n     * @param _gasLimit Gas limit to be passed alongside the message, depending on the fee paid on srcChain\n     * @param _nonce Nonce from origin chain\n     * @param _message Arbitrary message payload to pass to the destination chain receiver\n     * @param _messageId MessageId for uniqueness of messages (alongisde nonce)\n     */\n    function executeMessage(\n        uint256 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint256 _gasLimit,\n        uint256 _nonce,\n        bytes calldata _message,\n        bytes32 _messageId\n    ) external;\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateFee(uint256 _dstChainId, bytes calldata _options) external returns (uint256);\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     */\n    function withdrawFee(address _account) external;\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n//\nabstract contract SynMessagingReceiver is ISynMessagingReceiver, Ownable {\n    address public messageBus;\n\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    event SetTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress);\n\n    /**\n     * @notice Executes a message called by MessageBus (MessageBusReceiver)\n     * @dev Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external {\n        // Must be called by the MessageBus/MessageBus for security\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        // Must also be from a trusted source app\n        require(_srcAddress == trustedRemoteLookup[_srcChainId], \"Invalid source sending app\");\n\n        _handleMessage(_srcAddress, _srcChainId, _message, _executor);\n    }\n\n    // Logic here handling messsage contents\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal virtual;\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal virtual {\n        require(trustedRemoteLookup[_dstChainId] != bytes32(0), \"Receiver not trusted remote\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    //** Config Functions */\n    function setMessageBus(address _messageBus) public onlyOwner {\n        messageBus = _messageBus;\n    }\n\n    // allow owner to set trusted addresses allowed to be source senders\n    function setTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //** View functions */\n    function getTrustedRemote(uint256 _chainId) external view returns (bytes32 trustedRemote) {\n        return trustedRemoteLookup[_chainId];\n    }\n}\n\n//\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n//\n/**\n * @dev Interface of Inventory Items.\n */\ninterface IInventoryItem is IERC20 {\n    /**\n     * @dev Burns tokens.\n     */\n    function burnFrom(address from, uint256 amount) external;\n\n    function mint(address to, uint256 amount) external;\n}\n\n//\ncontract TearBridge is SynMessagingReceiver {\n    address public immutable gaiaTears;\n    uint256 public msgGasLimit;\n\n    struct MessageFormat {\n        address dstUser;\n        uint256 dstTearAmount;\n    }\n\n    event GaiaSent(address indexed dstUser, uint256 arrivalChainId);\n    event GaiaArrived(address indexed dstUser, uint256 arrivalChainId);\n\n    constructor(address _messageBus, address _gaiaTear) {\n        messageBus = _messageBus;\n        gaiaTears = _gaiaTear;\n    }\n\n    function _createMessage(address _dstUserAddress, uint256 _dstTearAmount) internal pure returns (bytes memory) {\n        // create the message here from the nested struct\n        MessageFormat memory msgFormat = MessageFormat({dstUser: _dstUserAddress, dstTearAmount: _dstTearAmount});\n        return abi.encode(msgFormat);\n    }\n\n    function _decodeMessage(bytes memory _message) internal pure returns (MessageFormat memory) {\n        MessageFormat memory decodedMessage = abi.decode(_message, (MessageFormat));\n        return decodedMessage;\n    }\n\n    function decodeMessage(bytes memory _message) external pure returns (MessageFormat memory) {\n        return _decodeMessage(_message);\n    }\n\n\n    function _createOptions() internal view returns (bytes memory) {\n        return abi.encodePacked(uint16(1), msgGasLimit);\n    }\n\n    function sendTear(uint256 _tearsAmount, uint256 _dstChainId) external payable {\n        uint256 tearsAmount = _tearsAmount;\n        uint256 dstChainId = _dstChainId;\n        // Tears now burnt, equivalent amount will be bridged to dstChainId\n        IInventoryItem(gaiaTears).burnFrom(msg.sender, tearsAmount);\n\n        bytes32 receiver = trustedRemoteLookup[dstChainId];\n        bytes memory message = _createMessage(msg.sender, tearsAmount);\n        bytes memory options = _createOptions();\n\n        _send(receiver, dstChainId, message, options);\n        emit GaiaSent(msg.sender, tearsAmount);\n    }\n\n    // Function called by executeMessage() - handleMessage will handle the gaia tear mint\n    // executeMessage() handles permissioning checks\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal override {\n        MessageFormat memory passedMsg = _decodeMessage(_message);\n        address dstUser = passedMsg.dstUser;\n        uint256 dstTearAmount = passedMsg.dstTearAmount;\n        IInventoryItem(gaiaTears).mint(dstUser, dstTearAmount);\n        emit GaiaArrived(dstUser, dstTearAmount);\n    }\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal override {\n        bytes32 trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote != bytes32(0), \"No remote app set for dst chain\");\n        require(trustedRemote == _receiver, \"Receiver is not in trusted remote apps\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    function setMsgGasLimit(uint256 _msgGasLimit) external onlyOwner {\n        msgGasLimit = _msgGasLimit;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Interface of the ERC20 standard as defined in the EIP.","events":{"Approval(address,address,uint256)":{"details":"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{"details":"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},"kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{"details":"Returns the amount of tokens owned by `account`."},"totalSupply()":{"details":"Returns the amount of tokens in existence."},"transfer(address,uint256)":{"details":"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{"details":"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of the ERC20 standard as defined in the EIP.\",\"events\":{\"Approval(address,address,uint256)\":{\"details\":\"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance.\"},\"Transfer(address,address,uint256)\":{\"details\":\"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero.\"}},\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the amount of tokens owned by `account`.\"},\"totalSupply()\":{\"details\":\"Returns the amount of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TearBridge.sol\":\"IERC20\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TearBridge.sol\":{\"keccak256\":\"0x7a7a5e375ca994e2037e477a31dce5c30a7607f3af2e2b34eb9dac2facbc3748\",\"urls\":[\"bzz-raw://8572be8c0a68120a7ddb61d39e2ceb75d6e07b37b04b8fa9654d87215ac94775\",\"dweb:/ipfs/QmYabWxXUCYW9QZwjRVQd8kQKG9ynmTsJ48kTXast2qxhS\"]}},\"version\":1}"},"hashes":{"allowance(address,address)":"dd62ed3e","approve(address,uint256)":"095ea7b3","balanceOf(address)":"70a08231","totalSupply()":"18160ddd","transfer(address,uint256)":"a9059cbb","transferFrom(address,address,uint256)":"23b872dd"}},"solidity/TearBridge.sol:IInventoryItem":{"code":"0x","runtime-code":"0x","info":{"source":"\n\n//\ninterface ISynMessagingReceiver {\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    // mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    /**\n     * @notice Called by MessageBus\n     * @dev MUST be permissioned to trusted source apps via trustedRemote\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external;\n}\n\n//\ninterface IMessageBus {\n    /**\n     * @notice Sends a message to a receiving contract address on another chain.\n     * Sender must make sure that the message is unique and not a duplicate message.\n     * @param _receiver The bytes32 address of the destination contract to be called\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _message The arbitrary payload to pass to the destination chain receiver\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits\n     */\n    function sendMessage(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) external payable;\n\n    /**\n     * @notice Relayer executes messages through an authenticated method to the destination receiver based on the originating transaction on source chain\n     * @param _srcChainId Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\n     * @param _srcAddress Originating bytes address of the message sender on the srcChain\n     * @param _dstAddress Destination address that the arbitrary message will be passed to\n     * @param _gasLimit Gas limit to be passed alongside the message, depending on the fee paid on srcChain\n     * @param _nonce Nonce from origin chain\n     * @param _message Arbitrary message payload to pass to the destination chain receiver\n     * @param _messageId MessageId for uniqueness of messages (alongisde nonce)\n     */\n    function executeMessage(\n        uint256 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint256 _gasLimit,\n        uint256 _nonce,\n        bytes calldata _message,\n        bytes32 _messageId\n    ) external;\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateFee(uint256 _dstChainId, bytes calldata _options) external returns (uint256);\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     */\n    function withdrawFee(address _account) external;\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n//\nabstract contract SynMessagingReceiver is ISynMessagingReceiver, Ownable {\n    address public messageBus;\n\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    event SetTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress);\n\n    /**\n     * @notice Executes a message called by MessageBus (MessageBusReceiver)\n     * @dev Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external {\n        // Must be called by the MessageBus/MessageBus for security\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        // Must also be from a trusted source app\n        require(_srcAddress == trustedRemoteLookup[_srcChainId], \"Invalid source sending app\");\n\n        _handleMessage(_srcAddress, _srcChainId, _message, _executor);\n    }\n\n    // Logic here handling messsage contents\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal virtual;\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal virtual {\n        require(trustedRemoteLookup[_dstChainId] != bytes32(0), \"Receiver not trusted remote\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    //** Config Functions */\n    function setMessageBus(address _messageBus) public onlyOwner {\n        messageBus = _messageBus;\n    }\n\n    // allow owner to set trusted addresses allowed to be source senders\n    function setTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //** View functions */\n    function getTrustedRemote(uint256 _chainId) external view returns (bytes32 trustedRemote) {\n        return trustedRemoteLookup[_chainId];\n    }\n}\n\n//\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n//\n/**\n * @dev Interface of Inventory Items.\n */\ninterface IInventoryItem is IERC20 {\n    /**\n     * @dev Burns tokens.\n     */\n    function burnFrom(address from, uint256 amount) external;\n\n    function mint(address to, uint256 amount) external;\n}\n\n//\ncontract TearBridge is SynMessagingReceiver {\n    address public immutable gaiaTears;\n    uint256 public msgGasLimit;\n\n    struct MessageFormat {\n        address dstUser;\n        uint256 dstTearAmount;\n    }\n\n    event GaiaSent(address indexed dstUser, uint256 arrivalChainId);\n    event GaiaArrived(address indexed dstUser, uint256 arrivalChainId);\n\n    constructor(address _messageBus, address _gaiaTear) {\n        messageBus = _messageBus;\n        gaiaTears = _gaiaTear;\n    }\n\n    function _createMessage(address _dstUserAddress, uint256 _dstTearAmount) internal pure returns (bytes memory) {\n        // create the message here from the nested struct\n        MessageFormat memory msgFormat = MessageFormat({dstUser: _dstUserAddress, dstTearAmount: _dstTearAmount});\n        return abi.encode(msgFormat);\n    }\n\n    function _decodeMessage(bytes memory _message) internal pure returns (MessageFormat memory) {\n        MessageFormat memory decodedMessage = abi.decode(_message, (MessageFormat));\n        return decodedMessage;\n    }\n\n    function decodeMessage(bytes memory _message) external pure returns (MessageFormat memory) {\n        return _decodeMessage(_message);\n    }\n\n\n    function _createOptions() internal view returns (bytes memory) {\n        return abi.encodePacked(uint16(1), msgGasLimit);\n    }\n\n    function sendTear(uint256 _tearsAmount, uint256 _dstChainId) external payable {\n        uint256 tearsAmount = _tearsAmount;\n        uint256 dstChainId = _dstChainId;\n        // Tears now burnt, equivalent amount will be bridged to dstChainId\n        IInventoryItem(gaiaTears).burnFrom(msg.sender, tearsAmount);\n\n        bytes32 receiver = trustedRemoteLookup[dstChainId];\n        bytes memory message = _createMessage(msg.sender, tearsAmount);\n        bytes memory options = _createOptions();\n\n        _send(receiver, dstChainId, message, options);\n        emit GaiaSent(msg.sender, tearsAmount);\n    }\n\n    // Function called by executeMessage() - handleMessage will handle the gaia tear mint\n    // executeMessage() handles permissioning checks\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal override {\n        MessageFormat memory passedMsg = _decodeMessage(_message);\n        address dstUser = passedMsg.dstUser;\n        uint256 dstTearAmount = passedMsg.dstTearAmount;\n        IInventoryItem(gaiaTears).mint(dstUser, dstTearAmount);\n        emit GaiaArrived(dstUser, dstTearAmount);\n    }\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal override {\n        bytes32 trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote != bytes32(0), \"No remote app set for dst chain\");\n        require(trustedRemote == _receiver, \"Receiver is not in trusted remote apps\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    function setMsgGasLimit(uint256 _msgGasLimit) external onlyOwner {\n        msgGasLimit = _msgGasLimit;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"burnFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"mint","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"amount","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Interface of Inventory Items.","kind":"dev","methods":{"allowance(address,address)":{"details":"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{"details":"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{"details":"Returns the amount of tokens owned by `account`."},"burnFrom(address,uint256)":{"details":"Burns tokens."},"totalSupply()":{"details":"Returns the amount of tokens in existence."},"transfer(address,uint256)":{"details":"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{"details":"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Interface of Inventory Items.\",\"kind\":\"dev\",\"methods\":{\"allowance(address,address)\":{\"details\":\"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.\"},\"approve(address,uint256)\":{\"details\":\"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.\"},\"balanceOf(address)\":{\"details\":\"Returns the amount of tokens owned by `account`.\"},\"burnFrom(address,uint256)\":{\"details\":\"Burns tokens.\"},\"totalSupply()\":{\"details\":\"Returns the amount of tokens in existence.\"},\"transfer(address,uint256)\":{\"details\":\"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"},\"transferFrom(address,address,uint256)\":{\"details\":\"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TearBridge.sol\":\"IInventoryItem\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TearBridge.sol\":{\"keccak256\":\"0x7a7a5e375ca994e2037e477a31dce5c30a7607f3af2e2b34eb9dac2facbc3748\",\"urls\":[\"bzz-raw://8572be8c0a68120a7ddb61d39e2ceb75d6e07b37b04b8fa9654d87215ac94775\",\"dweb:/ipfs/QmYabWxXUCYW9QZwjRVQd8kQKG9ynmTsJ48kTXast2qxhS\"]}},\"version\":1}"},"hashes":{"allowance(address,address)":"dd62ed3e","approve(address,uint256)":"095ea7b3","balanceOf(address)":"70a08231","burnFrom(address,uint256)":"79cc6790","mint(address,uint256)":"40c10f19","totalSupply()":"18160ddd","transfer(address,uint256)":"a9059cbb","transferFrom(address,address,uint256)":"23b872dd"}},"solidity/TearBridge.sol:IMessageBus":{"code":"0x","runtime-code":"0x","info":{"source":"\n\n//\ninterface ISynMessagingReceiver {\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    // mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    /**\n     * @notice Called by MessageBus\n     * @dev MUST be permissioned to trusted source apps via trustedRemote\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external;\n}\n\n//\ninterface IMessageBus {\n    /**\n     * @notice Sends a message to a receiving contract address on another chain.\n     * Sender must make sure that the message is unique and not a duplicate message.\n     * @param _receiver The bytes32 address of the destination contract to be called\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _message The arbitrary payload to pass to the destination chain receiver\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits\n     */\n    function sendMessage(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) external payable;\n\n    /**\n     * @notice Relayer executes messages through an authenticated method to the destination receiver based on the originating transaction on source chain\n     * @param _srcChainId Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\n     * @param _srcAddress Originating bytes address of the message sender on the srcChain\n     * @param _dstAddress Destination address that the arbitrary message will be passed to\n     * @param _gasLimit Gas limit to be passed alongside the message, depending on the fee paid on srcChain\n     * @param _nonce Nonce from origin chain\n     * @param _message Arbitrary message payload to pass to the destination chain receiver\n     * @param _messageId MessageId for uniqueness of messages (alongisde nonce)\n     */\n    function executeMessage(\n        uint256 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint256 _gasLimit,\n        uint256 _nonce,\n        bytes calldata _message,\n        bytes32 _messageId\n    ) external;\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateFee(uint256 _dstChainId, bytes calldata _options) external returns (uint256);\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     */\n    function withdrawFee(address _account) external;\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n//\nabstract contract SynMessagingReceiver is ISynMessagingReceiver, Ownable {\n    address public messageBus;\n\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    event SetTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress);\n\n    /**\n     * @notice Executes a message called by MessageBus (MessageBusReceiver)\n     * @dev Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external {\n        // Must be called by the MessageBus/MessageBus for security\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        // Must also be from a trusted source app\n        require(_srcAddress == trustedRemoteLookup[_srcChainId], \"Invalid source sending app\");\n\n        _handleMessage(_srcAddress, _srcChainId, _message, _executor);\n    }\n\n    // Logic here handling messsage contents\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal virtual;\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal virtual {\n        require(trustedRemoteLookup[_dstChainId] != bytes32(0), \"Receiver not trusted remote\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    //** Config Functions */\n    function setMessageBus(address _messageBus) public onlyOwner {\n        messageBus = _messageBus;\n    }\n\n    // allow owner to set trusted addresses allowed to be source senders\n    function setTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //** View functions */\n    function getTrustedRemote(uint256 _chainId) external view returns (bytes32 trustedRemote) {\n        return trustedRemoteLookup[_chainId];\n    }\n}\n\n//\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n//\n/**\n * @dev Interface of Inventory Items.\n */\ninterface IInventoryItem is IERC20 {\n    /**\n     * @dev Burns tokens.\n     */\n    function burnFrom(address from, uint256 amount) external;\n\n    function mint(address to, uint256 amount) external;\n}\n\n//\ncontract TearBridge is SynMessagingReceiver {\n    address public immutable gaiaTears;\n    uint256 public msgGasLimit;\n\n    struct MessageFormat {\n        address dstUser;\n        uint256 dstTearAmount;\n    }\n\n    event GaiaSent(address indexed dstUser, uint256 arrivalChainId);\n    event GaiaArrived(address indexed dstUser, uint256 arrivalChainId);\n\n    constructor(address _messageBus, address _gaiaTear) {\n        messageBus = _messageBus;\n        gaiaTears = _gaiaTear;\n    }\n\n    function _createMessage(address _dstUserAddress, uint256 _dstTearAmount) internal pure returns (bytes memory) {\n        // create the message here from the nested struct\n        MessageFormat memory msgFormat = MessageFormat({dstUser: _dstUserAddress, dstTearAmount: _dstTearAmount});\n        return abi.encode(msgFormat);\n    }\n\n    function _decodeMessage(bytes memory _message) internal pure returns (MessageFormat memory) {\n        MessageFormat memory decodedMessage = abi.decode(_message, (MessageFormat));\n        return decodedMessage;\n    }\n\n    function decodeMessage(bytes memory _message) external pure returns (MessageFormat memory) {\n        return _decodeMessage(_message);\n    }\n\n\n    function _createOptions() internal view returns (bytes memory) {\n        return abi.encodePacked(uint16(1), msgGasLimit);\n    }\n\n    function sendTear(uint256 _tearsAmount, uint256 _dstChainId) external payable {\n        uint256 tearsAmount = _tearsAmount;\n        uint256 dstChainId = _dstChainId;\n        // Tears now burnt, equivalent amount will be bridged to dstChainId\n        IInventoryItem(gaiaTears).burnFrom(msg.sender, tearsAmount);\n\n        bytes32 receiver = trustedRemoteLookup[dstChainId];\n        bytes memory message = _createMessage(msg.sender, tearsAmount);\n        bytes memory options = _createOptions();\n\n        _send(receiver, dstChainId, message, options);\n        emit GaiaSent(msg.sender, tearsAmount);\n    }\n\n    // Function called by executeMessage() - handleMessage will handle the gaia tear mint\n    // executeMessage() handles permissioning checks\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal override {\n        MessageFormat memory passedMsg = _decodeMessage(_message);\n        address dstUser = passedMsg.dstUser;\n        uint256 dstTearAmount = passedMsg.dstTearAmount;\n        IInventoryItem(gaiaTears).mint(dstUser, dstTearAmount);\n        emit GaiaArrived(dstUser, dstTearAmount);\n    }\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal override {\n        bytes32 trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote != bytes32(0), \"No remote app set for dst chain\");\n        require(trustedRemote == _receiver, \"Receiver is not in trusted remote apps\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    function setMsgGasLimit(uint256 _msgGasLimit) external onlyOwner {\n        msgGasLimit = _msgGasLimit;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"uint256","name":"_dstChainId","type":"uint256"},{"internalType":"bytes","name":"_options","type":"bytes"}],"name":"estimateFee","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_srcChainId","type":"uint256"},{"internalType":"bytes","name":"_srcAddress","type":"bytes"},{"internalType":"address","name":"_dstAddress","type":"address"},{"internalType":"uint256","name":"_gasLimit","type":"uint256"},{"internalType":"uint256","name":"_nonce","type":"uint256"},{"internalType":"bytes","name":"_message","type":"bytes"},{"internalType":"bytes32","name":"_messageId","type":"bytes32"}],"name":"executeMessage","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_receiver","type":"bytes32"},{"internalType":"uint256","name":"_dstChainId","type":"uint256"},{"internalType":"bytes","name":"_message","type":"bytes"},{"internalType":"bytes","name":"_options","type":"bytes"}],"name":"sendMessage","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"_account","type":"address"}],"name":"withdrawFee","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"estimateFee(uint256,bytes)":{"notice":"Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit"},"executeMessage(uint256,bytes,address,uint256,uint256,bytes,bytes32)":{"notice":"Relayer executes messages through an authenticated method to the destination receiver based on the originating transaction on source chain"},"sendMessage(bytes32,uint256,bytes,bytes)":{"notice":"Sends a message to a receiving contract address on another chain. Sender must make sure that the message is unique and not a duplicate message."},"withdrawFee(address)":{"notice":"Withdraws message fee in the form of native gas token."}},"version":1},"developerDoc":{"kind":"dev","methods":{"estimateFee(uint256,bytes)":{"params":{"_options":"Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with."}},"executeMessage(uint256,bytes,address,uint256,uint256,bytes,bytes32)":{"params":{"_dstAddress":"Destination address that the arbitrary message will be passed to","_gasLimit":"Gas limit to be passed alongside the message, depending on the fee paid on srcChain","_message":"Arbitrary message payload to pass to the destination chain receiver","_messageId":"MessageId for uniqueness of messages (alongisde nonce)","_nonce":"Nonce from origin chain","_srcAddress":"Originating bytes address of the message sender on the srcChain","_srcChainId":"Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains"}},"sendMessage(bytes32,uint256,bytes,bytes)":{"params":{"_dstChainId":"The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains","_message":"The arbitrary payload to pass to the destination chain receiver","_options":"Versioned struct used to instruct relayer on how to proceed with gas limits","_receiver":"The bytes32 address of the destination contract to be called"}},"withdrawFee(address)":{"params":{"_account":"The address receiving the fee."}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"}],\"name\":\"estimateFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_srcAddress\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_dstAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_gasLimit\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_nonce\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"bytes32\",\"name\":\"_messageId\",\"type\":\"bytes32\"}],\"name\":\"executeMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_receiver\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_dstChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_options\",\"type\":\"bytes\"}],\"name\":\"sendMessage\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"withdrawFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"estimateFee(uint256,bytes)\":{\"params\":{\"_options\":\"Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\"}},\"executeMessage(uint256,bytes,address,uint256,uint256,bytes,bytes32)\":{\"params\":{\"_dstAddress\":\"Destination address that the arbitrary message will be passed to\",\"_gasLimit\":\"Gas limit to be passed alongside the message, depending on the fee paid on srcChain\",\"_message\":\"Arbitrary message payload to pass to the destination chain receiver\",\"_messageId\":\"MessageId for uniqueness of messages (alongisde nonce)\",\"_nonce\":\"Nonce from origin chain\",\"_srcAddress\":\"Originating bytes address of the message sender on the srcChain\",\"_srcChainId\":\"Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\"}},\"sendMessage(bytes32,uint256,bytes,bytes)\":{\"params\":{\"_dstChainId\":\"The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\",\"_message\":\"The arbitrary payload to pass to the destination chain receiver\",\"_options\":\"Versioned struct used to instruct relayer on how to proceed with gas limits\",\"_receiver\":\"The bytes32 address of the destination contract to be called\"}},\"withdrawFee(address)\":{\"params\":{\"_account\":\"The address receiving the fee.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"estimateFee(uint256,bytes)\":{\"notice\":\"Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\"},\"executeMessage(uint256,bytes,address,uint256,uint256,bytes,bytes32)\":{\"notice\":\"Relayer executes messages through an authenticated method to the destination receiver based on the originating transaction on source chain\"},\"sendMessage(bytes32,uint256,bytes,bytes)\":{\"notice\":\"Sends a message to a receiving contract address on another chain. Sender must make sure that the message is unique and not a duplicate message.\"},\"withdrawFee(address)\":{\"notice\":\"Withdraws message fee in the form of native gas token.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TearBridge.sol\":\"IMessageBus\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TearBridge.sol\":{\"keccak256\":\"0x7a7a5e375ca994e2037e477a31dce5c30a7607f3af2e2b34eb9dac2facbc3748\",\"urls\":[\"bzz-raw://8572be8c0a68120a7ddb61d39e2ceb75d6e07b37b04b8fa9654d87215ac94775\",\"dweb:/ipfs/QmYabWxXUCYW9QZwjRVQd8kQKG9ynmTsJ48kTXast2qxhS\"]}},\"version\":1}"},"hashes":{"estimateFee(uint256,bytes)":"5da6d2c4","executeMessage(uint256,bytes,address,uint256,uint256,bytes,bytes32)":"21730efc","sendMessage(bytes32,uint256,bytes,bytes)":"ac8a4c1b","withdrawFee(address)":"1ac3ddeb"}},"solidity/TearBridge.sol:ISynMessagingReceiver":{"code":"0x","runtime-code":"0x","info":{"source":"\n\n//\ninterface ISynMessagingReceiver {\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    // mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    /**\n     * @notice Called by MessageBus\n     * @dev MUST be permissioned to trusted source apps via trustedRemote\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external;\n}\n\n//\ninterface IMessageBus {\n    /**\n     * @notice Sends a message to a receiving contract address on another chain.\n     * Sender must make sure that the message is unique and not a duplicate message.\n     * @param _receiver The bytes32 address of the destination contract to be called\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _message The arbitrary payload to pass to the destination chain receiver\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits\n     */\n    function sendMessage(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) external payable;\n\n    /**\n     * @notice Relayer executes messages through an authenticated method to the destination receiver based on the originating transaction on source chain\n     * @param _srcChainId Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\n     * @param _srcAddress Originating bytes address of the message sender on the srcChain\n     * @param _dstAddress Destination address that the arbitrary message will be passed to\n     * @param _gasLimit Gas limit to be passed alongside the message, depending on the fee paid on srcChain\n     * @param _nonce Nonce from origin chain\n     * @param _message Arbitrary message payload to pass to the destination chain receiver\n     * @param _messageId MessageId for uniqueness of messages (alongisde nonce)\n     */\n    function executeMessage(\n        uint256 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint256 _gasLimit,\n        uint256 _nonce,\n        bytes calldata _message,\n        bytes32 _messageId\n    ) external;\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateFee(uint256 _dstChainId, bytes calldata _options) external returns (uint256);\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     */\n    function withdrawFee(address _account) external;\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n//\nabstract contract SynMessagingReceiver is ISynMessagingReceiver, Ownable {\n    address public messageBus;\n\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    event SetTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress);\n\n    /**\n     * @notice Executes a message called by MessageBus (MessageBusReceiver)\n     * @dev Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external {\n        // Must be called by the MessageBus/MessageBus for security\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        // Must also be from a trusted source app\n        require(_srcAddress == trustedRemoteLookup[_srcChainId], \"Invalid source sending app\");\n\n        _handleMessage(_srcAddress, _srcChainId, _message, _executor);\n    }\n\n    // Logic here handling messsage contents\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal virtual;\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal virtual {\n        require(trustedRemoteLookup[_dstChainId] != bytes32(0), \"Receiver not trusted remote\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    //** Config Functions */\n    function setMessageBus(address _messageBus) public onlyOwner {\n        messageBus = _messageBus;\n    }\n\n    // allow owner to set trusted addresses allowed to be source senders\n    function setTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //** View functions */\n    function getTrustedRemote(uint256 _chainId) external view returns (bytes32 trustedRemote) {\n        return trustedRemoteLookup[_chainId];\n    }\n}\n\n//\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n//\n/**\n * @dev Interface of Inventory Items.\n */\ninterface IInventoryItem is IERC20 {\n    /**\n     * @dev Burns tokens.\n     */\n    function burnFrom(address from, uint256 amount) external;\n\n    function mint(address to, uint256 amount) external;\n}\n\n//\ncontract TearBridge is SynMessagingReceiver {\n    address public immutable gaiaTears;\n    uint256 public msgGasLimit;\n\n    struct MessageFormat {\n        address dstUser;\n        uint256 dstTearAmount;\n    }\n\n    event GaiaSent(address indexed dstUser, uint256 arrivalChainId);\n    event GaiaArrived(address indexed dstUser, uint256 arrivalChainId);\n\n    constructor(address _messageBus, address _gaiaTear) {\n        messageBus = _messageBus;\n        gaiaTears = _gaiaTear;\n    }\n\n    function _createMessage(address _dstUserAddress, uint256 _dstTearAmount) internal pure returns (bytes memory) {\n        // create the message here from the nested struct\n        MessageFormat memory msgFormat = MessageFormat({dstUser: _dstUserAddress, dstTearAmount: _dstTearAmount});\n        return abi.encode(msgFormat);\n    }\n\n    function _decodeMessage(bytes memory _message) internal pure returns (MessageFormat memory) {\n        MessageFormat memory decodedMessage = abi.decode(_message, (MessageFormat));\n        return decodedMessage;\n    }\n\n    function decodeMessage(bytes memory _message) external pure returns (MessageFormat memory) {\n        return _decodeMessage(_message);\n    }\n\n\n    function _createOptions() internal view returns (bytes memory) {\n        return abi.encodePacked(uint16(1), msgGasLimit);\n    }\n\n    function sendTear(uint256 _tearsAmount, uint256 _dstChainId) external payable {\n        uint256 tearsAmount = _tearsAmount;\n        uint256 dstChainId = _dstChainId;\n        // Tears now burnt, equivalent amount will be bridged to dstChainId\n        IInventoryItem(gaiaTears).burnFrom(msg.sender, tearsAmount);\n\n        bytes32 receiver = trustedRemoteLookup[dstChainId];\n        bytes memory message = _createMessage(msg.sender, tearsAmount);\n        bytes memory options = _createOptions();\n\n        _send(receiver, dstChainId, message, options);\n        emit GaiaSent(msg.sender, tearsAmount);\n    }\n\n    // Function called by executeMessage() - handleMessage will handle the gaia tear mint\n    // executeMessage() handles permissioning checks\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal override {\n        MessageFormat memory passedMsg = _decodeMessage(_message);\n        address dstUser = passedMsg.dstUser;\n        uint256 dstTearAmount = passedMsg.dstTearAmount;\n        IInventoryItem(gaiaTears).mint(dstUser, dstTearAmount);\n        emit GaiaArrived(dstUser, dstTearAmount);\n    }\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal override {\n        bytes32 trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote != bytes32(0), \"No remote app set for dst chain\");\n        require(trustedRemote == _receiver, \"Receiver is not in trusted remote apps\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    function setMsgGasLimit(uint256 _msgGasLimit) external onlyOwner {\n        msgGasLimit = _msgGasLimit;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"inputs":[{"internalType":"bytes32","name":"_srcAddress","type":"bytes32"},{"internalType":"uint256","name":"_srcChainId","type":"uint256"},{"internalType":"bytes","name":"_message","type":"bytes"},{"internalType":"address","name":"_executor","type":"address"}],"name":"executeMessage","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"executeMessage(bytes32,uint256,bytes,address)":{"notice":"Called by MessageBus"}},"version":1},"developerDoc":{"kind":"dev","methods":{"executeMessage(bytes32,uint256,bytes,address)":{"details":"MUST be permissioned to trusted source apps via trustedRemote","params":{"_executor":"Address who called the MessageBus execution function","_message":"Arbitrary message bytes originated from and encoded by the source app contract","_srcAddress":"The bytes32 address of the source app contract","_srcChainId":"The source chain ID where the transfer is originated from"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_srcAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"executeMessage(bytes32,uint256,bytes,address)\":{\"details\":\"MUST be permissioned to trusted source apps via trustedRemote\",\"params\":{\"_executor\":\"Address who called the MessageBus execution function\",\"_message\":\"Arbitrary message bytes originated from and encoded by the source app contract\",\"_srcAddress\":\"The bytes32 address of the source app contract\",\"_srcChainId\":\"The source chain ID where the transfer is originated from\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"executeMessage(bytes32,uint256,bytes,address)\":{\"notice\":\"Called by MessageBus\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TearBridge.sol\":\"ISynMessagingReceiver\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TearBridge.sol\":{\"keccak256\":\"0x7a7a5e375ca994e2037e477a31dce5c30a7607f3af2e2b34eb9dac2facbc3748\",\"urls\":[\"bzz-raw://8572be8c0a68120a7ddb61d39e2ceb75d6e07b37b04b8fa9654d87215ac94775\",\"dweb:/ipfs/QmYabWxXUCYW9QZwjRVQd8kQKG9ynmTsJ48kTXast2qxhS\"]}},\"version\":1}"},"hashes":{"executeMessage(bytes32,uint256,bytes,address)":"a6060871"}},"solidity/TearBridge.sol:Ownable":{"code":"0x","runtime-code":"0x","info":{"source":"\n\n//\ninterface ISynMessagingReceiver {\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    // mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    /**\n     * @notice Called by MessageBus\n     * @dev MUST be permissioned to trusted source apps via trustedRemote\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external;\n}\n\n//\ninterface IMessageBus {\n    /**\n     * @notice Sends a message to a receiving contract address on another chain.\n     * Sender must make sure that the message is unique and not a duplicate message.\n     * @param _receiver The bytes32 address of the destination contract to be called\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _message The arbitrary payload to pass to the destination chain receiver\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits\n     */\n    function sendMessage(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) external payable;\n\n    /**\n     * @notice Relayer executes messages through an authenticated method to the destination receiver based on the originating transaction on source chain\n     * @param _srcChainId Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\n     * @param _srcAddress Originating bytes address of the message sender on the srcChain\n     * @param _dstAddress Destination address that the arbitrary message will be passed to\n     * @param _gasLimit Gas limit to be passed alongside the message, depending on the fee paid on srcChain\n     * @param _nonce Nonce from origin chain\n     * @param _message Arbitrary message payload to pass to the destination chain receiver\n     * @param _messageId MessageId for uniqueness of messages (alongisde nonce)\n     */\n    function executeMessage(\n        uint256 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint256 _gasLimit,\n        uint256 _nonce,\n        bytes calldata _message,\n        bytes32 _messageId\n    ) external;\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateFee(uint256 _dstChainId, bytes calldata _options) external returns (uint256);\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     */\n    function withdrawFee(address _account) external;\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n//\nabstract contract SynMessagingReceiver is ISynMessagingReceiver, Ownable {\n    address public messageBus;\n\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    event SetTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress);\n\n    /**\n     * @notice Executes a message called by MessageBus (MessageBusReceiver)\n     * @dev Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external {\n        // Must be called by the MessageBus/MessageBus for security\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        // Must also be from a trusted source app\n        require(_srcAddress == trustedRemoteLookup[_srcChainId], \"Invalid source sending app\");\n\n        _handleMessage(_srcAddress, _srcChainId, _message, _executor);\n    }\n\n    // Logic here handling messsage contents\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal virtual;\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal virtual {\n        require(trustedRemoteLookup[_dstChainId] != bytes32(0), \"Receiver not trusted remote\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    //** Config Functions */\n    function setMessageBus(address _messageBus) public onlyOwner {\n        messageBus = _messageBus;\n    }\n\n    // allow owner to set trusted addresses allowed to be source senders\n    function setTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //** View functions */\n    function getTrustedRemote(uint256 _chainId) external view returns (bytes32 trustedRemote) {\n        return trustedRemoteLookup[_chainId];\n    }\n}\n\n//\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n//\n/**\n * @dev Interface of Inventory Items.\n */\ninterface IInventoryItem is IERC20 {\n    /**\n     * @dev Burns tokens.\n     */\n    function burnFrom(address from, uint256 amount) external;\n\n    function mint(address to, uint256 amount) external;\n}\n\n//\ncontract TearBridge is SynMessagingReceiver {\n    address public immutable gaiaTears;\n    uint256 public msgGasLimit;\n\n    struct MessageFormat {\n        address dstUser;\n        uint256 dstTearAmount;\n    }\n\n    event GaiaSent(address indexed dstUser, uint256 arrivalChainId);\n    event GaiaArrived(address indexed dstUser, uint256 arrivalChainId);\n\n    constructor(address _messageBus, address _gaiaTear) {\n        messageBus = _messageBus;\n        gaiaTears = _gaiaTear;\n    }\n\n    function _createMessage(address _dstUserAddress, uint256 _dstTearAmount) internal pure returns (bytes memory) {\n        // create the message here from the nested struct\n        MessageFormat memory msgFormat = MessageFormat({dstUser: _dstUserAddress, dstTearAmount: _dstTearAmount});\n        return abi.encode(msgFormat);\n    }\n\n    function _decodeMessage(bytes memory _message) internal pure returns (MessageFormat memory) {\n        MessageFormat memory decodedMessage = abi.decode(_message, (MessageFormat));\n        return decodedMessage;\n    }\n\n    function decodeMessage(bytes memory _message) external pure returns (MessageFormat memory) {\n        return _decodeMessage(_message);\n    }\n\n\n    function _createOptions() internal view returns (bytes memory) {\n        return abi.encodePacked(uint16(1), msgGasLimit);\n    }\n\n    function sendTear(uint256 _tearsAmount, uint256 _dstChainId) external payable {\n        uint256 tearsAmount = _tearsAmount;\n        uint256 dstChainId = _dstChainId;\n        // Tears now burnt, equivalent amount will be bridged to dstChainId\n        IInventoryItem(gaiaTears).burnFrom(msg.sender, tearsAmount);\n\n        bytes32 receiver = trustedRemoteLookup[dstChainId];\n        bytes memory message = _createMessage(msg.sender, tearsAmount);\n        bytes memory options = _createOptions();\n\n        _send(receiver, dstChainId, message, options);\n        emit GaiaSent(msg.sender, tearsAmount);\n    }\n\n    // Function called by executeMessage() - handleMessage will handle the gaia tear mint\n    // executeMessage() handles permissioning checks\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal override {\n        MessageFormat memory passedMsg = _decodeMessage(_message);\n        address dstUser = passedMsg.dstUser;\n        uint256 dstTearAmount = passedMsg.dstTearAmount;\n        IInventoryItem(gaiaTears).mint(dstUser, dstTearAmount);\n        emit GaiaArrived(dstUser, dstTearAmount);\n    }\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal override {\n        bytes32 trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote != bytes32(0), \"No remote app set for dst chain\");\n        require(trustedRemote == _receiver, \"Receiver is not in trusted remote apps\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    function setMsgGasLimit(uint256 _msgGasLimit) external onlyOwner {\n        msgGasLimit = _msgGasLimit;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"details":"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.","kind":"dev","methods":{"constructor":{"details":"Initializes the contract setting the deployer as the initial owner."},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"details\":\"Contract module which provides a basic access control mechanism, where there is an account (an owner) that can be granted exclusive access to specific functions. By default, the owner account will be the one that deploys the contract. This can later be changed with {transferOwnership}. This module is used through inheritance. It will make available the modifier `onlyOwner`, which can be applied to your functions to restrict their use to the owner.\",\"kind\":\"dev\",\"methods\":{\"constructor\":{\"details\":\"Initializes the contract setting the deployer as the initial owner.\"},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TearBridge.sol\":\"Ownable\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TearBridge.sol\":{\"keccak256\":\"0x7a7a5e375ca994e2037e477a31dce5c30a7607f3af2e2b34eb9dac2facbc3748\",\"urls\":[\"bzz-raw://8572be8c0a68120a7ddb61d39e2ceb75d6e07b37b04b8fa9654d87215ac94775\",\"dweb:/ipfs/QmYabWxXUCYW9QZwjRVQd8kQKG9ynmTsJ48kTXast2qxhS\"]}},\"version\":1}"},"hashes":{"owner()":"8da5cb5b","renounceOwnership()":"715018a6","transferOwnership(address)":"f2fde38b"}},"solidity/TearBridge.sol:SynMessagingReceiver":{"code":"0x","runtime-code":"0x","info":{"source":"\n\n//\ninterface ISynMessagingReceiver {\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    // mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    /**\n     * @notice Called by MessageBus\n     * @dev MUST be permissioned to trusted source apps via trustedRemote\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external;\n}\n\n//\ninterface IMessageBus {\n    /**\n     * @notice Sends a message to a receiving contract address on another chain.\n     * Sender must make sure that the message is unique and not a duplicate message.\n     * @param _receiver The bytes32 address of the destination contract to be called\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _message The arbitrary payload to pass to the destination chain receiver\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits\n     */\n    function sendMessage(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) external payable;\n\n    /**\n     * @notice Relayer executes messages through an authenticated method to the destination receiver based on the originating transaction on source chain\n     * @param _srcChainId Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\n     * @param _srcAddress Originating bytes address of the message sender on the srcChain\n     * @param _dstAddress Destination address that the arbitrary message will be passed to\n     * @param _gasLimit Gas limit to be passed alongside the message, depending on the fee paid on srcChain\n     * @param _nonce Nonce from origin chain\n     * @param _message Arbitrary message payload to pass to the destination chain receiver\n     * @param _messageId MessageId for uniqueness of messages (alongisde nonce)\n     */\n    function executeMessage(\n        uint256 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint256 _gasLimit,\n        uint256 _nonce,\n        bytes calldata _message,\n        bytes32 _messageId\n    ) external;\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateFee(uint256 _dstChainId, bytes calldata _options) external returns (uint256);\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     */\n    function withdrawFee(address _account) external;\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n//\nabstract contract SynMessagingReceiver is ISynMessagingReceiver, Ownable {\n    address public messageBus;\n\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    event SetTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress);\n\n    /**\n     * @notice Executes a message called by MessageBus (MessageBusReceiver)\n     * @dev Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external {\n        // Must be called by the MessageBus/MessageBus for security\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        // Must also be from a trusted source app\n        require(_srcAddress == trustedRemoteLookup[_srcChainId], \"Invalid source sending app\");\n\n        _handleMessage(_srcAddress, _srcChainId, _message, _executor);\n    }\n\n    // Logic here handling messsage contents\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal virtual;\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal virtual {\n        require(trustedRemoteLookup[_dstChainId] != bytes32(0), \"Receiver not trusted remote\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    //** Config Functions */\n    function setMessageBus(address _messageBus) public onlyOwner {\n        messageBus = _messageBus;\n    }\n\n    // allow owner to set trusted addresses allowed to be source senders\n    function setTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //** View functions */\n    function getTrustedRemote(uint256 _chainId) external view returns (bytes32 trustedRemote) {\n        return trustedRemoteLookup[_chainId];\n    }\n}\n\n//\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n//\n/**\n * @dev Interface of Inventory Items.\n */\ninterface IInventoryItem is IERC20 {\n    /**\n     * @dev Burns tokens.\n     */\n    function burnFrom(address from, uint256 amount) external;\n\n    function mint(address to, uint256 amount) external;\n}\n\n//\ncontract TearBridge is SynMessagingReceiver {\n    address public immutable gaiaTears;\n    uint256 public msgGasLimit;\n\n    struct MessageFormat {\n        address dstUser;\n        uint256 dstTearAmount;\n    }\n\n    event GaiaSent(address indexed dstUser, uint256 arrivalChainId);\n    event GaiaArrived(address indexed dstUser, uint256 arrivalChainId);\n\n    constructor(address _messageBus, address _gaiaTear) {\n        messageBus = _messageBus;\n        gaiaTears = _gaiaTear;\n    }\n\n    function _createMessage(address _dstUserAddress, uint256 _dstTearAmount) internal pure returns (bytes memory) {\n        // create the message here from the nested struct\n        MessageFormat memory msgFormat = MessageFormat({dstUser: _dstUserAddress, dstTearAmount: _dstTearAmount});\n        return abi.encode(msgFormat);\n    }\n\n    function _decodeMessage(bytes memory _message) internal pure returns (MessageFormat memory) {\n        MessageFormat memory decodedMessage = abi.decode(_message, (MessageFormat));\n        return decodedMessage;\n    }\n\n    function decodeMessage(bytes memory _message) external pure returns (MessageFormat memory) {\n        return _decodeMessage(_message);\n    }\n\n\n    function _createOptions() internal view returns (bytes memory) {\n        return abi.encodePacked(uint16(1), msgGasLimit);\n    }\n\n    function sendTear(uint256 _tearsAmount, uint256 _dstChainId) external payable {\n        uint256 tearsAmount = _tearsAmount;\n        uint256 dstChainId = _dstChainId;\n        // Tears now burnt, equivalent amount will be bridged to dstChainId\n        IInventoryItem(gaiaTears).burnFrom(msg.sender, tearsAmount);\n\n        bytes32 receiver = trustedRemoteLookup[dstChainId];\n        bytes memory message = _createMessage(msg.sender, tearsAmount);\n        bytes memory options = _createOptions();\n\n        _send(receiver, dstChainId, message, options);\n        emit GaiaSent(msg.sender, tearsAmount);\n    }\n\n    // Function called by executeMessage() - handleMessage will handle the gaia tear mint\n    // executeMessage() handles permissioning checks\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal override {\n        MessageFormat memory passedMsg = _decodeMessage(_message);\n        address dstUser = passedMsg.dstUser;\n        uint256 dstTearAmount = passedMsg.dstTearAmount;\n        IInventoryItem(gaiaTears).mint(dstUser, dstTearAmount);\n        emit GaiaArrived(dstUser, dstTearAmount);\n    }\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal override {\n        bytes32 trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote != bytes32(0), \"No remote app set for dst chain\");\n        require(trustedRemote == _receiver, \"Receiver is not in trusted remote apps\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    function setMsgGasLimit(uint256 _msgGasLimit) external onlyOwner {\n        msgGasLimit = _msgGasLimit;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"","srcMapRuntime":"","abiDefinition":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"_srcAddress","type":"bytes32"}],"name":"SetTrustedRemote","type":"event"},{"inputs":[{"internalType":"bytes32","name":"_srcAddress","type":"bytes32"},{"internalType":"uint256","name":"_srcChainId","type":"uint256"},{"internalType":"bytes","name":"_message","type":"bytes"},{"internalType":"address","name":"_executor","type":"address"}],"name":"executeMessage","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"}],"name":"getTrustedRemote","outputs":[{"internalType":"bytes32","name":"trustedRemote","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"messageBus","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"_messageBus","type":"address"}],"name":"setMessageBus","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_srcChainId","type":"uint256"},{"internalType":"bytes32","name":"_srcAddress","type":"bytes32"}],"name":"setTrustedRemote","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"executeMessage(bytes32,uint256,bytes,address)":{"notice":"Executes a message called by MessageBus (MessageBusReceiver)"}},"version":1},"developerDoc":{"kind":"dev","methods":{"executeMessage(bytes32,uint256,bytes,address)":{"details":"Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp","params":{"_executor":"Address who called the MessageBus execution function","_message":"Arbitrary message bytes originated from and encoded by the source app contract","_srcAddress":"The bytes32 address of the source app contract","_srcChainId":"The source chain ID where the transfer is originated from"}},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_srcAddress\",\"type\":\"bytes32\"}],\"name\":\"SetTrustedRemote\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_srcAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getTrustedRemote\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"trustedRemote\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageBus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_messageBus\",\"type\":\"address\"}],\"name\":\"setMessageBus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_srcAddress\",\"type\":\"bytes32\"}],\"name\":\"setTrustedRemote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"executeMessage(bytes32,uint256,bytes,address)\":{\"details\":\"Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp\",\"params\":{\"_executor\":\"Address who called the MessageBus execution function\",\"_message\":\"Arbitrary message bytes originated from and encoded by the source app contract\",\"_srcAddress\":\"The bytes32 address of the source app contract\",\"_srcChainId\":\"The source chain ID where the transfer is originated from\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"executeMessage(bytes32,uint256,bytes,address)\":{\"notice\":\"Executes a message called by MessageBus (MessageBusReceiver)\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TearBridge.sol\":\"SynMessagingReceiver\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TearBridge.sol\":{\"keccak256\":\"0x7a7a5e375ca994e2037e477a31dce5c30a7607f3af2e2b34eb9dac2facbc3748\",\"urls\":[\"bzz-raw://8572be8c0a68120a7ddb61d39e2ceb75d6e07b37b04b8fa9654d87215ac94775\",\"dweb:/ipfs/QmYabWxXUCYW9QZwjRVQd8kQKG9ynmTsJ48kTXast2qxhS\"]}},\"version\":1}"},"hashes":{"executeMessage(bytes32,uint256,bytes,address)":"a6060871","getTrustedRemote(uint256)":"84a12b0f","messageBus()":"a1a227fa","owner()":"8da5cb5b","renounceOwnership()":"715018a6","setMessageBus(address)":"547cad12","setTrustedRemote(uint256,bytes32)":"bd3583ae","transferOwnership(address)":"f2fde38b"}},"solidity/TearBridge.sol:TearBridge":{"code":"0x60a060405234801561001057600080fd5b5060405161116e38038061116e83398101604081905261002f916100c9565b6100383361005d565b600180546001600160a01b0319166001600160a01b03938416179055166080526100fc565b600080546001600160a01b038381166001600160a01b0319831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b80516001600160a01b03811681146100c457600080fd5b919050565b600080604083850312156100dc57600080fd5b6100e5836100ad565b91506100f3602084016100ad565b90509250929050565b6080516110496101256000396000818161025d015281816104ab0152610c5b01526110496000f3fe6080604052600436106100d25760003560e01c8063a1a227fa1161007f578063bd3583ae11610059578063bd3583ae1461027f578063c0e07f281461029f578063f2fde38b146102b5578063f9ecc6f5146102d557600080fd5b8063a1a227fa146101fe578063a60608711461022b578063acac4bdd1461024b57600080fd5b806382731903116100b0578063827319031461016457806384a12b0f146101775780638da5cb5b146101b257600080fd5b8063547cad12146100d7578063634d45b2146100f9578063715018a61461014f575b600080fd5b3480156100e357600080fd5b506100f76100f2366004610d23565b6102f5565b005b34801561010557600080fd5b50610119610114366004610d6f565b6103c2565b60408051825173ffffffffffffffffffffffffffffffffffffffff16815260209283015192810192909252015b60405180910390f35b34801561015b57600080fd5b506100f76103e5565b6100f7610172366004610e3e565b610472565b34801561018357600080fd5b506101a4610192366004610e60565b60009081526002602052604090205490565b604051908152602001610146565b3480156101be57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff165b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610146565b34801561020a57600080fd5b506001546101d99073ffffffffffffffffffffffffffffffffffffffff1681565b34801561023757600080fd5b506100f7610246366004610e79565b6105ec565b34801561025757600080fd5b506101d97f000000000000000000000000000000000000000000000000000000000000000081565b34801561028b57600080fd5b506100f761029a366004610e3e565b61072e565b3480156102ab57600080fd5b506101a460035481565b3480156102c157600080fd5b506100f76102d0366004610d23565b6107fe565b3480156102e157600080fd5b506100f76102f0366004610e60565b61092e565b60005473ffffffffffffffffffffffffffffffffffffffff16331461037b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60408051808201909152600080825260208201526103df826109b4565b92915050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610466576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610372565b61047060006109e5565b565b6040517f79cc679000000000000000000000000000000000000000000000000000000000815233600482015260248101839052829082907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906379cc679090604401600060405180830381600087803b15801561050457600080fd5b505af1158015610518573d6000803e3d6000fd5b50505060008281526002602090815260409182902054825180840184523380825290830187815284519384019190915251828401528251808303840181526060830184526003547e0100000000000000000000000000000000000000000000000000000000000060808501526082808501919091528451808503909101815260a290930190935292506105ad83858484610a5a565b60405185815233907fe82273e05845454dcf88823968e5c722028bc4cb17ed03bdc06eaa32cc58ee66906020015b60405180910390a250505050505050565b60015473ffffffffffffffffffffffffffffffffffffffff16331461066d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f63616c6c6572206973206e6f74206d65737361676520627573000000000000006044820152606401610372565b60008481526002602052604090205485146106e4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f496e76616c696420736f757263652073656e64696e67206170700000000000006044820152606401610372565b610727858585858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250879250610bf6915050565b5050505050565b60005473ffffffffffffffffffffffffffffffffffffffff1633146107af576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610372565b60008281526002602090815260409182902083905581518481529081018390527f642e74356c0610a9f944fb1a2d88d2fb82c6b74921566eee8bc0f9bb30f74f03910160405180910390a15050565b60005473ffffffffffffffffffffffffffffffffffffffff16331461087f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610372565b73ffffffffffffffffffffffffffffffffffffffff8116610922576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610372565b61092b816109e5565b50565b60005473ffffffffffffffffffffffffffffffffffffffff1633146109af576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610372565b600355565b60408051808201909152600080825260208201526000828060200190518101906109de9190610f14565b9392505050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60008381526002602052604090205480610ad0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f4e6f2072656d6f7465206170702073657420666f722064737420636861696e006044820152606401610372565b848114610b5f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f5265636569766572206973206e6f7420696e20747275737465642072656d6f7460448201527f65206170707300000000000000000000000000000000000000000000000000006064820152608401610372565b6001546040517fac8a4c1b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063ac8a4c1b903490610bbd908990899089908990600401610fd7565b6000604051808303818588803b158015610bd657600080fd5b505af1158015610bea573d6000803e3d6000fd5b50505050505050505050565b6000610c01836109b4565b805160208201516040517f40c10f1900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808416600483015260248201839052939450919290917f0000000000000000000000000000000000000000000000000000000000000000909116906340c10f1990604401600060405180830381600087803b158015610ca157600080fd5b505af1158015610cb5573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff167f07b815cd29685803e7213231371fa19ce2e23221109bf847d949305e6b7464a4826040516105db91815260200190565b73ffffffffffffffffffffffffffffffffffffffff8116811461092b57600080fd5b600060208284031215610d3557600080fd5b81356109de81610d01565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610d8157600080fd5b813567ffffffffffffffff80821115610d9957600080fd5b818401915084601f830112610dad57600080fd5b813581811115610dbf57610dbf610d40565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610e0557610e05610d40565b81604052828152876020848701011115610e1e57600080fd5b826020860160208301376000928101602001929092525095945050505050565b60008060408385031215610e5157600080fd5b50508035926020909101359150565b600060208284031215610e7257600080fd5b5035919050565b600080600080600060808688031215610e9157600080fd5b8535945060208601359350604086013567ffffffffffffffff80821115610eb757600080fd5b818801915088601f830112610ecb57600080fd5b813581811115610eda57600080fd5b896020828501011115610eec57600080fd5b6020830195508094505050506060860135610f0681610d01565b809150509295509295909350565b600060408284031215610f2657600080fd5b6040516040810181811067ffffffffffffffff82111715610f4957610f49610d40565b6040528251610f5781610d01565b81526020928301519281019290925250919050565b6000815180845260005b81811015610f9257602081850181015186830182015201610f76565b81811115610fa4576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b848152836020820152608060408201526000610ff66080830185610f6c565b82810360608401526110088185610f6c565b97965050505050505056fea2646970667358221220cea6277f9f212d1506db098e9253d5cf9a52097aa7864aca3d8e1cacf1659e3964736f6c634300080d0033","runtime-code":"0x6080604052600436106100d25760003560e01c8063a1a227fa1161007f578063bd3583ae11610059578063bd3583ae1461027f578063c0e07f281461029f578063f2fde38b146102b5578063f9ecc6f5146102d557600080fd5b8063a1a227fa146101fe578063a60608711461022b578063acac4bdd1461024b57600080fd5b806382731903116100b0578063827319031461016457806384a12b0f146101775780638da5cb5b146101b257600080fd5b8063547cad12146100d7578063634d45b2146100f9578063715018a61461014f575b600080fd5b3480156100e357600080fd5b506100f76100f2366004610d23565b6102f5565b005b34801561010557600080fd5b50610119610114366004610d6f565b6103c2565b60408051825173ffffffffffffffffffffffffffffffffffffffff16815260209283015192810192909252015b60405180910390f35b34801561015b57600080fd5b506100f76103e5565b6100f7610172366004610e3e565b610472565b34801561018357600080fd5b506101a4610192366004610e60565b60009081526002602052604090205490565b604051908152602001610146565b3480156101be57600080fd5b5060005473ffffffffffffffffffffffffffffffffffffffff165b60405173ffffffffffffffffffffffffffffffffffffffff9091168152602001610146565b34801561020a57600080fd5b506001546101d99073ffffffffffffffffffffffffffffffffffffffff1681565b34801561023757600080fd5b506100f7610246366004610e79565b6105ec565b34801561025757600080fd5b506101d97f000000000000000000000000000000000000000000000000000000000000000081565b34801561028b57600080fd5b506100f761029a366004610e3e565b61072e565b3480156102ab57600080fd5b506101a460035481565b3480156102c157600080fd5b506100f76102d0366004610d23565b6107fe565b3480156102e157600080fd5b506100f76102f0366004610e60565b61092e565b60005473ffffffffffffffffffffffffffffffffffffffff16331461037b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e657260448201526064015b60405180910390fd5b600180547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff92909216919091179055565b60408051808201909152600080825260208201526103df826109b4565b92915050565b60005473ffffffffffffffffffffffffffffffffffffffff163314610466576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610372565b61047060006109e5565b565b6040517f79cc679000000000000000000000000000000000000000000000000000000000815233600482015260248101839052829082907f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16906379cc679090604401600060405180830381600087803b15801561050457600080fd5b505af1158015610518573d6000803e3d6000fd5b50505060008281526002602090815260409182902054825180840184523380825290830187815284519384019190915251828401528251808303840181526060830184526003547e0100000000000000000000000000000000000000000000000000000000000060808501526082808501919091528451808503909101815260a290930190935292506105ad83858484610a5a565b60405185815233907fe82273e05845454dcf88823968e5c722028bc4cb17ed03bdc06eaa32cc58ee66906020015b60405180910390a250505050505050565b60015473ffffffffffffffffffffffffffffffffffffffff16331461066d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601960248201527f63616c6c6572206973206e6f74206d65737361676520627573000000000000006044820152606401610372565b60008481526002602052604090205485146106e4576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601a60248201527f496e76616c696420736f757263652073656e64696e67206170700000000000006044820152606401610372565b610727858585858080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250879250610bf6915050565b5050505050565b60005473ffffffffffffffffffffffffffffffffffffffff1633146107af576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610372565b60008281526002602090815260409182902083905581518481529081018390527f642e74356c0610a9f944fb1a2d88d2fb82c6b74921566eee8bc0f9bb30f74f03910160405180910390a15050565b60005473ffffffffffffffffffffffffffffffffffffffff16331461087f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610372565b73ffffffffffffffffffffffffffffffffffffffff8116610922576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160448201527f64647265737300000000000000000000000000000000000000000000000000006064820152608401610372565b61092b816109e5565b50565b60005473ffffffffffffffffffffffffffffffffffffffff1633146109af576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820181905260248201527f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e65726044820152606401610372565b600355565b60408051808201909152600080825260208201526000828060200190518101906109de9190610f14565b9392505050565b6000805473ffffffffffffffffffffffffffffffffffffffff8381167fffffffffffffffffffffffff0000000000000000000000000000000000000000831681178455604051919092169283917f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e09190a35050565b60008381526002602052604090205480610ad0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601f60248201527f4e6f2072656d6f7465206170702073657420666f722064737420636861696e006044820152606401610372565b848114610b5f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602660248201527f5265636569766572206973206e6f7420696e20747275737465642072656d6f7460448201527f65206170707300000000000000000000000000000000000000000000000000006064820152608401610372565b6001546040517fac8a4c1b00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff9091169063ac8a4c1b903490610bbd908990899089908990600401610fd7565b6000604051808303818588803b158015610bd657600080fd5b505af1158015610bea573d6000803e3d6000fd5b50505050505050505050565b6000610c01836109b4565b805160208201516040517f40c10f1900000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff808416600483015260248201839052939450919290917f0000000000000000000000000000000000000000000000000000000000000000909116906340c10f1990604401600060405180830381600087803b158015610ca157600080fd5b505af1158015610cb5573d6000803e3d6000fd5b505050508173ffffffffffffffffffffffffffffffffffffffff167f07b815cd29685803e7213231371fa19ce2e23221109bf847d949305e6b7464a4826040516105db91815260200190565b73ffffffffffffffffffffffffffffffffffffffff8116811461092b57600080fd5b600060208284031215610d3557600080fd5b81356109de81610d01565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610d8157600080fd5b813567ffffffffffffffff80821115610d9957600080fd5b818401915084601f830112610dad57600080fd5b813581811115610dbf57610dbf610d40565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610e0557610e05610d40565b81604052828152876020848701011115610e1e57600080fd5b826020860160208301376000928101602001929092525095945050505050565b60008060408385031215610e5157600080fd5b50508035926020909101359150565b600060208284031215610e7257600080fd5b5035919050565b600080600080600060808688031215610e9157600080fd5b8535945060208601359350604086013567ffffffffffffffff80821115610eb757600080fd5b818801915088601f830112610ecb57600080fd5b813581811115610eda57600080fd5b896020828501011115610eec57600080fd5b6020830195508094505050506060860135610f0681610d01565b809150509295509295909350565b600060408284031215610f2657600080fd5b6040516040810181811067ffffffffffffffff82111715610f4957610f49610d40565b6040528251610f5781610d01565b81526020928301519281019290925250919050565b6000815180845260005b81811015610f9257602081850181015186830182015201610f76565b81811115610fa4576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b848152836020820152608060408201526000610ff66080830185610f6c565b82810360608401526110088185610f6c565b97965050505050505056fea2646970667358221220cea6277f9f212d1506db098e9253d5cf9a52097aa7864aca3d8e1cacf1659e3964736f6c634300080d0033","info":{"source":"\n\n//\ninterface ISynMessagingReceiver {\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    // mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    /**\n     * @notice Called by MessageBus\n     * @dev MUST be permissioned to trusted source apps via trustedRemote\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external;\n}\n\n//\ninterface IMessageBus {\n    /**\n     * @notice Sends a message to a receiving contract address on another chain.\n     * Sender must make sure that the message is unique and not a duplicate message.\n     * @param _receiver The bytes32 address of the destination contract to be called\n     * @param _dstChainId The destination chain ID - typically, standard EVM chain ID, but differs on nonEVM chains\n     * @param _message The arbitrary payload to pass to the destination chain receiver\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits\n     */\n    function sendMessage(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes calldata _message,\n        bytes calldata _options\n    ) external payable;\n\n    /**\n     * @notice Relayer executes messages through an authenticated method to the destination receiver based on the originating transaction on source chain\n     * @param _srcChainId Originating chain ID - typically a standard EVM chain ID, but may refer to a Synapse-specific chain ID on nonEVM chains\n     * @param _srcAddress Originating bytes address of the message sender on the srcChain\n     * @param _dstAddress Destination address that the arbitrary message will be passed to\n     * @param _gasLimit Gas limit to be passed alongside the message, depending on the fee paid on srcChain\n     * @param _nonce Nonce from origin chain\n     * @param _message Arbitrary message payload to pass to the destination chain receiver\n     * @param _messageId MessageId for uniqueness of messages (alongisde nonce)\n     */\n    function executeMessage(\n        uint256 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint256 _gasLimit,\n        uint256 _nonce,\n        bytes calldata _message,\n        bytes32 _messageId\n    ) external;\n\n    /**\n     * @notice Returns srcGasToken fee to charge in wei for the cross-chain message based on the gas limit\n     * @param _options Versioned struct used to instruct relayer on how to proceed with gas limits. Contains data on gas limit to submit tx with.\n     */\n    function estimateFee(uint256 _dstChainId, bytes calldata _options) external returns (uint256);\n\n    /**\n     * @notice Withdraws message fee in the form of native gas token.\n     * @param _account The address receiving the fee.\n     */\n    function withdrawFee(address _account) external;\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n\n//\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n//\nabstract contract SynMessagingReceiver is ISynMessagingReceiver, Ownable {\n    address public messageBus;\n\n    // Maps chain ID to the bytes32 trusted addresses allowed to be source senders\n    mapping(uint256 =\u003e bytes32) internal trustedRemoteLookup;\n\n    event SetTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress);\n\n    /**\n     * @notice Executes a message called by MessageBus (MessageBusReceiver)\n     * @dev Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp\n     * @param _srcAddress The bytes32 address of the source app contract\n     * @param _srcChainId The source chain ID where the transfer is originated from\n     * @param _message Arbitrary message bytes originated from and encoded by the source app contract\n     * @param _executor Address who called the MessageBus execution function\n     */\n    function executeMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes calldata _message,\n        address _executor\n    ) external {\n        // Must be called by the MessageBus/MessageBus for security\n        require(msg.sender == messageBus, \"caller is not message bus\");\n        // Must also be from a trusted source app\n        require(_srcAddress == trustedRemoteLookup[_srcChainId], \"Invalid source sending app\");\n\n        _handleMessage(_srcAddress, _srcChainId, _message, _executor);\n    }\n\n    // Logic here handling messsage contents\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal virtual;\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal virtual {\n        require(trustedRemoteLookup[_dstChainId] != bytes32(0), \"Receiver not trusted remote\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    //** Config Functions */\n    function setMessageBus(address _messageBus) public onlyOwner {\n        messageBus = _messageBus;\n    }\n\n    // allow owner to set trusted addresses allowed to be source senders\n    function setTrustedRemote(uint256 _srcChainId, bytes32 _srcAddress) external onlyOwner {\n        trustedRemoteLookup[_srcChainId] = _srcAddress;\n        emit SetTrustedRemote(_srcChainId, _srcAddress);\n    }\n\n    //** View functions */\n    function getTrustedRemote(uint256 _chainId) external view returns (bytes32 trustedRemote) {\n        return trustedRemoteLookup[_chainId];\n    }\n}\n\n//\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n//\n/**\n * @dev Interface of Inventory Items.\n */\ninterface IInventoryItem is IERC20 {\n    /**\n     * @dev Burns tokens.\n     */\n    function burnFrom(address from, uint256 amount) external;\n\n    function mint(address to, uint256 amount) external;\n}\n\n//\ncontract TearBridge is SynMessagingReceiver {\n    address public immutable gaiaTears;\n    uint256 public msgGasLimit;\n\n    struct MessageFormat {\n        address dstUser;\n        uint256 dstTearAmount;\n    }\n\n    event GaiaSent(address indexed dstUser, uint256 arrivalChainId);\n    event GaiaArrived(address indexed dstUser, uint256 arrivalChainId);\n\n    constructor(address _messageBus, address _gaiaTear) {\n        messageBus = _messageBus;\n        gaiaTears = _gaiaTear;\n    }\n\n    function _createMessage(address _dstUserAddress, uint256 _dstTearAmount) internal pure returns (bytes memory) {\n        // create the message here from the nested struct\n        MessageFormat memory msgFormat = MessageFormat({dstUser: _dstUserAddress, dstTearAmount: _dstTearAmount});\n        return abi.encode(msgFormat);\n    }\n\n    function _decodeMessage(bytes memory _message) internal pure returns (MessageFormat memory) {\n        MessageFormat memory decodedMessage = abi.decode(_message, (MessageFormat));\n        return decodedMessage;\n    }\n\n    function decodeMessage(bytes memory _message) external pure returns (MessageFormat memory) {\n        return _decodeMessage(_message);\n    }\n\n\n    function _createOptions() internal view returns (bytes memory) {\n        return abi.encodePacked(uint16(1), msgGasLimit);\n    }\n\n    function sendTear(uint256 _tearsAmount, uint256 _dstChainId) external payable {\n        uint256 tearsAmount = _tearsAmount;\n        uint256 dstChainId = _dstChainId;\n        // Tears now burnt, equivalent amount will be bridged to dstChainId\n        IInventoryItem(gaiaTears).burnFrom(msg.sender, tearsAmount);\n\n        bytes32 receiver = trustedRemoteLookup[dstChainId];\n        bytes memory message = _createMessage(msg.sender, tearsAmount);\n        bytes memory options = _createOptions();\n\n        _send(receiver, dstChainId, message, options);\n        emit GaiaSent(msg.sender, tearsAmount);\n    }\n\n    // Function called by executeMessage() - handleMessage will handle the gaia tear mint\n    // executeMessage() handles permissioning checks\n    function _handleMessage(\n        bytes32 _srcAddress,\n        uint256 _srcChainId,\n        bytes memory _message,\n        address _executor\n    ) internal override {\n        MessageFormat memory passedMsg = _decodeMessage(_message);\n        address dstUser = passedMsg.dstUser;\n        uint256 dstTearAmount = passedMsg.dstTearAmount;\n        IInventoryItem(gaiaTears).mint(dstUser, dstTearAmount);\n        emit GaiaArrived(dstUser, dstTearAmount);\n    }\n\n    function _send(\n        bytes32 _receiver,\n        uint256 _dstChainId,\n        bytes memory _message,\n        bytes memory _options\n    ) internal override {\n        bytes32 trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote != bytes32(0), \"No remote app set for dst chain\");\n        require(trustedRemote == _receiver, \"Receiver is not in trusted remote apps\");\n        IMessageBus(messageBus).sendMessage{value: msg.value}(_receiver, _dstChainId, _message, _options);\n    }\n\n    function setMsgGasLimit(uint256 _msgGasLimit) external onlyOwner {\n        msgGasLimit = _msgGasLimit;\n    }\n}\n","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"11903:3151:0:-:0;;;12258:124;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;4844:32;3884:10;4844:18;:32::i;:::-;12320:10;:24;;-1:-1:-1;;;;;;12320:24:0;-1:-1:-1;;;;;12320:24:0;;;;;;12354:21;;;11903:3151;;6193:187;6266:16;6285:6;;-1:-1:-1;;;;;6301:17:0;;;-1:-1:-1;;;;;;6301:17:0;;;;;;6333:40;;6285:6;;;;;;;6333:40;;6266:16;6333:40;6256:124;6193:187;:::o;14:177:1:-;93:13;;-1:-1:-1;;;;;135:31:1;;125:42;;115:70;;181:1;178;171:12;115:70;14:177;;;:::o;196:293::-;275:6;283;336:2;324:9;315:7;311:23;307:32;304:52;;;352:1;349;342:12;304:52;375:40;405:9;375:40;:::i;:::-;365:50;;434:49;479:2;468:9;464:18;434:49;:::i;:::-;424:59;;196:293;;;;;:::o;:::-;11903:3151:0;;;;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"11903:3151:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8369:102;;;;;;;;;;-1:-1:-1;8369:102:0;;;;;:::i;:::-;;:::i;:::-;;12943:139;;;;;;;;;;-1:-1:-1;12943:139:0;;;;;:::i;:::-;;:::i;:::-;;;;1827:13:1;;1842:42;1823:62;1805:81;;1942:4;1930:17;;;1924:24;1902:20;;;1895:54;;;;1778:18;12943:139:0;;;;;;;;5591:101;;;;;;;;;;;;;:::i;13222:602::-;;;;;;:::i;:::-;;:::i;8790:143::-;;;;;;;;;;-1:-1:-1;8790:143:0;;;;;:::i;:::-;8857:21;8897:29;;;:19;:29;;;;;;;8790:143;;;;2544:25:1;;;2532:2;2517:18;8790:143:0;2398:177:1;4959:85:0;;;;;;;;;;-1:-1:-1;5005:7:0;5031:6;;;4959:85;;;2756:42:1;2744:55;;;2726:74;;2714:2;2699:18;4959:85:0;2580:226:1;6466:25:0;;;;;;;;;;-1:-1:-1;6466:25:0;;;;;;;;7226:522;;;;;;;;;;-1:-1:-1;7226:522:0;;;;;:::i;:::-;;:::i;11953:34::-;;;;;;;;;;;;;;;8550:207;;;;;;;;;;-1:-1:-1;8550:207:0;;;;;:::i;:::-;;:::i;11993:26::-;;;;;;;;;;;;;;;;5841:198;;;;;;;;;;-1:-1:-1;5841:198:0;;;;;:::i;:::-;;:::i;14944:108::-;;;;;;;;;;-1:-1:-1;14944:108:0;;;;;:::i;:::-;;:::i;8369:102::-;5005:7;5031:6;5171:23;5031:6;3884:10;5171:23;5163:68;;;;;;;4316:2:1;5163:68:0;;;4298:21:1;;;4335:18;;;4328:30;4394:34;4374:18;;;4367:62;4446:18;;5163:68:0;;;;;;;;;8440:10:::1;:24:::0;;;::::1;;::::0;;;::::1;::::0;;;::::1;::::0;;8369:102::o;12943:139::-;-1:-1:-1;;;;;;;;;;;;;;;;;13051:24:0;13066:8;13051:14;:24::i;:::-;13044:31;12943:139;-1:-1:-1;;12943:139:0:o;5591:101::-;5005:7;5031:6;5171:23;5031:6;3884:10;5171:23;5163:68;;;;;;;4316:2:1;5163:68:0;;;4298:21:1;;;4335:18;;;4328:30;4394:34;4374:18;;;4367:62;4446:18;;5163:68:0;4114:356:1;5163:68:0;5655:30:::1;5682:1;5655:18;:30::i;:::-;5591:101::o:0;13222:602::-;13472:59;;;;;13507:10;13472:59;;;4649:74:1;4739:18;;;4732:34;;;13332:12:0;;13375:11;;13487:9;13472:34;;;;;4622:18:1;;13472:59:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;;13542:16:0;13561:31;;;:19;:31;;;;;;;;;;12599:72;;;;;;;13640:10;12599:72;;;;;;;;;12688:21;;;;;1805:81:1;;;;1924:24;1902:20;;;1895:54;12688:21:0;;;;;;;;;12484:12;1778:18:1;;12688:21:0;;13197:11;;6895:16:1;13169:40:0;;;6879:102:1;6997:11;;;;6990:27;;;;13169:40:0;;;;;;;;;;7033:12:1;;;;13169:40:0;;;13561:31;-1:-1:-1;13724:45:0;13561:31;;12688:21;13169:40;13724:5;:45::i;:::-;13784:33;;2544:25:1;;;13793:10:0;;13784:33;;2532:2:1;2517:18;13784:33:0;;;;;;;;13300:524;;;;;13222:602;;:::o;7226:522::-;7483:10;;;;7469;:24;7461:62;;;;;;;4979:2:1;7461:62:0;;;4961:21:1;5018:2;4998:18;;;4991:30;5057:27;5037:18;;;5030:55;5102:18;;7461:62:0;4777:349:1;7461:62:0;7606:32;;;;:19;:32;;;;;;7591:47;;7583:86;;;;;;;5333:2:1;7583:86:0;;;5315:21:1;5372:2;5352:18;;;5345:30;5411:28;5391:18;;;5384:56;5457:18;;7583:86:0;5131:350:1;7583:86:0;7680:61;7695:11;7708;7721:8;;7680:61;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;7731:9:0;;-1:-1:-1;7680:14:0;;-1:-1:-1;;7680:61:0:i;:::-;7226:522;;;;;:::o;8550:207::-;5005:7;5031:6;5171:23;5031:6;3884:10;5171:23;5163:68;;;;;;;4316:2:1;5163:68:0;;;4298:21:1;;;4335:18;;;4328:30;4394:34;4374:18;;;4367:62;4446:18;;5163:68:0;4114:356:1;5163:68:0;8647:32:::1;::::0;;;:19:::1;:32;::::0;;;;;;;;:46;;;8708:42;;5660:25:1;;;5701:18;;;5694:34;;;8708:42:0::1;::::0;5633:18:1;8708:42:0::1;;;;;;;8550:207:::0;;:::o;5841:198::-;5005:7;5031:6;5171:23;5031:6;3884:10;5171:23;5163:68;;;;;;;4316:2:1;5163:68:0;;;4298:21:1;;;4335:18;;;4328:30;4394:34;4374:18;;;4367:62;4446:18;;5163:68:0;4114:356:1;5163:68:0;5929:22:::1;::::0;::::1;5921:73;;;::::0;::::1;::::0;;5941:2:1;5921:73:0::1;::::0;::::1;5923:21:1::0;5980:2;5960:18;;;5953:30;6019:34;5999:18;;;5992:62;6090:8;6070:18;;;6063:36;6116:19;;5921:73:0::1;5739:402:1::0;5921:73:0::1;6004:28;6023:8;6004:18;:28::i;:::-;5841:198:::0;:::o;14944:108::-;5005:7;5031:6;5171:23;5031:6;3884:10;5171:23;5163:68;;;;;;;4316:2:1;5163:68:0;;;4298:21:1;;;4335:18;;;4328:30;4394:34;4374:18;;;4367:62;4446:18;;5163:68:0;4114:356:1;5163:68:0;15019:11:::1;:26:::0;14944:108::o;12722:215::-;-1:-1:-1;;;;;;;;;;;;;;;;;12824:35:0;12873:8;12862:37;;;;;;;;;;;;:::i;:::-;12824:75;12722:215;-1:-1:-1;;;12722:215:0:o;6193:187::-;6266:16;6285:6;;;6301:17;;;;;;;;;;6333:40;;6285:6;;;;;;;6333:40;;6266:16;6333:40;6256:124;6193:187;:::o;14433:505::-;14600:21;14624:32;;;:19;:32;;;;;;;14666:71;;;;;;;7258:2:1;14666:71:0;;;7240:21:1;7297:2;7277:18;;;7270:30;7336:33;7316:18;;;7309:61;7387:18;;14666:71:0;7056:355:1;14666:71:0;14772:9;14755:13;:26;14747:77;;;;;;;7618:2:1;14747:77:0;;;7600:21:1;7657:2;7637:18;;;7630:30;7696:34;7676:18;;;7669:62;7767:8;7747:18;;;7740:36;7793:19;;14747:77:0;7416:402:1;14747:77:0;14846:10;;14834:97;;;;;14846:10;;;;;14834:35;;14877:9;;14834:97;;14888:9;;14899:11;;14912:8;;14922;;14834:97;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;14590:348;14433:505;;;;:::o;13973:454::-;14147:30;14180:24;14195:8;14180:14;:24::i;:::-;14232:17;;14283:23;;;;14316:54;;;;;:30;4667:55:1;;;14316:54:0;;;4649:74:1;4739:18;;;4732:34;;;14232:17:0;;-1:-1:-1;14232:17:0;;14283:23;;14331:9;14316:30;;;;;;4622:18:1;;14316:54:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;14397:7;14385:35;;;14406:13;14385:35;;;;2544:25:1;;2532:2;2517:18;;2398:177;14:154;100:42;93:5;89:54;82:5;79:65;69:93;;158:1;155;148:12;173:247;232:6;285:2;273:9;264:7;260:23;256:32;253:52;;;301:1;298;291:12;253:52;340:9;327:23;359:31;384:5;359:31;:::i;425:184::-;477:77;474:1;467:88;574:4;571:1;564:15;598:4;595:1;588:15;614:980;682:6;735:2;723:9;714:7;710:23;706:32;703:52;;;751:1;748;741:12;703:52;791:9;778:23;820:18;861:2;853:6;850:14;847:34;;;877:1;874;867:12;847:34;915:6;904:9;900:22;890:32;;960:7;953:4;949:2;945:13;941:27;931:55;;982:1;979;972:12;931:55;1018:2;1005:16;1040:2;1036;1033:10;1030:36;;;1046:18;;:::i;:::-;1180:2;1174:9;1242:4;1234:13;;1085:66;1230:22;;;1254:2;1226:31;1222:40;1210:53;;;1278:18;;;1298:22;;;1275:46;1272:72;;;1324:18;;:::i;:::-;1364:10;1360:2;1353:22;1399:2;1391:6;1384:18;1439:7;1434:2;1429;1425;1421:11;1417:20;1414:33;1411:53;;;1460:1;1457;1450:12;1411:53;1516:2;1511;1507;1503:11;1498:2;1490:6;1486:15;1473:46;1561:1;1539:15;;;1556:2;1535:24;1528:35;;;;-1:-1:-1;1543:6:1;614:980;-1:-1:-1;;;;;614:980:1:o;1960:248::-;2028:6;2036;2089:2;2077:9;2068:7;2064:23;2060:32;2057:52;;;2105:1;2102;2095:12;2057:52;-1:-1:-1;;2128:23:1;;;2198:2;2183:18;;;2170:32;;-1:-1:-1;1960:248:1:o;2213:180::-;2272:6;2325:2;2313:9;2304:7;2300:23;2296:32;2293:52;;;2341:1;2338;2331:12;2293:52;-1:-1:-1;2364:23:1;;2213:180;-1:-1:-1;2213:180:1:o;2811:863::-;2908:6;2916;2924;2932;2940;2993:3;2981:9;2972:7;2968:23;2964:33;2961:53;;;3010:1;3007;3000:12;2961:53;3046:9;3033:23;3023:33;;3103:2;3092:9;3088:18;3075:32;3065:42;;3158:2;3147:9;3143:18;3130:32;3181:18;3222:2;3214:6;3211:14;3208:34;;;3238:1;3235;3228:12;3208:34;3276:6;3265:9;3261:22;3251:32;;3321:7;3314:4;3310:2;3306:13;3302:27;3292:55;;3343:1;3340;3333:12;3292:55;3383:2;3370:16;3409:2;3401:6;3398:14;3395:34;;;3425:1;3422;3415:12;3395:34;3470:7;3465:2;3456:6;3452:2;3448:15;3444:24;3441:37;3438:57;;;3491:1;3488;3481:12;3438:57;3522:2;3518;3514:11;3504:21;;3544:6;3534:16;;;;;3600:2;3589:9;3585:18;3572:32;3613:31;3638:5;3613:31;:::i;:::-;3663:5;3653:15;;;2811:863;;;;;;;;:::o;6146:573::-;6246:6;6299:2;6287:9;6278:7;6274:23;6270:32;6267:52;;;6315:1;6312;6305:12;6267:52;6348:2;6342:9;6390:2;6382:6;6378:15;6459:6;6447:10;6444:22;6423:18;6411:10;6408:34;6405:62;6402:88;;;6470:18;;:::i;:::-;6506:2;6499:22;6543:16;;6568:31;6543:16;6568:31;:::i;:::-;6608:21;;6683:2;6668:18;;;6662:25;6645:15;;;6638:50;;;;-1:-1:-1;6615:6:1;6146:573;-1:-1:-1;6146:573:1:o;7823:530::-;7864:3;7902:5;7896:12;7929:6;7924:3;7917:19;7954:1;7964:162;7978:6;7975:1;7972:13;7964:162;;;8040:4;8096:13;;;8092:22;;8086:29;8068:11;;;8064:20;;8057:59;7993:12;7964:162;;;8144:6;8141:1;8138:13;8135:87;;;8210:1;8203:4;8194:6;8189:3;8185:16;8181:27;8174:38;8135:87;-1:-1:-1;8267:2:1;8255:15;8272:66;8251:88;8242:98;;;;8342:4;8238:109;;7823:530;-1:-1:-1;;7823:530:1:o;8358:521::-;8607:6;8596:9;8589:25;8650:6;8645:2;8634:9;8630:18;8623:34;8693:3;8688:2;8677:9;8673:18;8666:31;8570:4;8720:45;8760:3;8749:9;8745:19;8737:6;8720:45;:::i;:::-;8813:9;8805:6;8801:22;8796:2;8785:9;8781:18;8774:50;8841:32;8866:6;8858;8841:32;:::i;:::-;8833:40;8358:521;-1:-1:-1;;;;;;;8358:521:1:o","abiDefinition":[{"inputs":[{"internalType":"address","name":"_messageBus","type":"address"},{"internalType":"address","name":"_gaiaTear","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"dstUser","type":"address"},{"indexed":false,"internalType":"uint256","name":"arrivalChainId","type":"uint256"}],"name":"GaiaArrived","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"dstUser","type":"address"},{"indexed":false,"internalType":"uint256","name":"arrivalChainId","type":"uint256"}],"name":"GaiaSent","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint256","name":"_srcChainId","type":"uint256"},{"indexed":false,"internalType":"bytes32","name":"_srcAddress","type":"bytes32"}],"name":"SetTrustedRemote","type":"event"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"decodeMessage","outputs":[{"components":[{"internalType":"address","name":"dstUser","type":"address"},{"internalType":"uint256","name":"dstTearAmount","type":"uint256"}],"internalType":"struct TearBridge.MessageFormat","name":"","type":"tuple"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_srcAddress","type":"bytes32"},{"internalType":"uint256","name":"_srcChainId","type":"uint256"},{"internalType":"bytes","name":"_message","type":"bytes"},{"internalType":"address","name":"_executor","type":"address"}],"name":"executeMessage","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"gaiaTears","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"_chainId","type":"uint256"}],"name":"getTrustedRemote","outputs":[{"internalType":"bytes32","name":"trustedRemote","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"messageBus","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"msgGasLimit","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_tearsAmount","type":"uint256"},{"internalType":"uint256","name":"_dstChainId","type":"uint256"}],"name":"sendTear","outputs":[],"stateMutability":"payable","type":"function"},{"inputs":[{"internalType":"address","name":"_messageBus","type":"address"}],"name":"setMessageBus","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_msgGasLimit","type":"uint256"}],"name":"setMsgGasLimit","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"_srcChainId","type":"uint256"},{"internalType":"bytes32","name":"_srcAddress","type":"bytes32"}],"name":"setTrustedRemote","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"userDoc":{"kind":"user","methods":{"executeMessage(bytes32,uint256,bytes,address)":{"notice":"Executes a message called by MessageBus (MessageBusReceiver)"}},"version":1},"developerDoc":{"kind":"dev","methods":{"executeMessage(bytes32,uint256,bytes,address)":{"details":"Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp","params":{"_executor":"Address who called the MessageBus execution function","_message":"Arbitrary message bytes originated from and encoded by the source app contract","_srcAddress":"The bytes32 address of the source app contract","_srcChainId":"The source chain ID where the transfer is originated from"}},"owner()":{"details":"Returns the address of the current owner."},"renounceOwnership()":{"details":"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner."},"transferOwnership(address)":{"details":"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_messageBus\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_gaiaTear\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstUser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"arrivalChainId\",\"type\":\"uint256\"}],\"name\":\"GaiaArrived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"dstUser\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"arrivalChainId\",\"type\":\"uint256\"}],\"name\":\"GaiaSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_srcChainId\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"bytes32\",\"name\":\"_srcAddress\",\"type\":\"bytes32\"}],\"name\":\"SetTrustedRemote\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"decodeMessage\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"dstUser\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"dstTearAmount\",\"type\":\"uint256\"}],\"internalType\":\"struct TearBridge.MessageFormat\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_srcAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"},{\"internalType\":\"address\",\"name\":\"_executor\",\"type\":\"address\"}],\"name\":\"executeMessage\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gaiaTears\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_chainId\",\"type\":\"uint256\"}],\"name\":\"getTrustedRemote\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"trustedRemote\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageBus\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"msgGasLimit\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_tearsAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_dstChainId\",\"type\":\"uint256\"}],\"name\":\"sendTear\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_messageBus\",\"type\":\"address\"}],\"name\":\"setMessageBus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_msgGasLimit\",\"type\":\"uint256\"}],\"name\":\"setMsgGasLimit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_srcChainId\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"_srcAddress\",\"type\":\"bytes32\"}],\"name\":\"setTrustedRemote\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"executeMessage(bytes32,uint256,bytes,address)\":{\"details\":\"Must be called by MessageBug \u0026 sent from src chain by a trusted srcApp\",\"params\":{\"_executor\":\"Address who called the MessageBus execution function\",\"_message\":\"Arbitrary message bytes originated from and encoded by the source app contract\",\"_srcAddress\":\"The bytes32 address of the source app contract\",\"_srcChainId\":\"The source chain ID where the transfer is originated from\"}},\"owner()\":{\"details\":\"Returns the address of the current owner.\"},\"renounceOwnership()\":{\"details\":\"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions anymore. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby removing any functionality that is only available to the owner.\"},\"transferOwnership(address)\":{\"details\":\"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner.\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"executeMessage(bytes32,uint256,bytes,address)\":{\"notice\":\"Executes a message called by MessageBus (MessageBusReceiver)\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TearBridge.sol\":\"TearBridge\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TearBridge.sol\":{\"keccak256\":\"0x7a7a5e375ca994e2037e477a31dce5c30a7607f3af2e2b34eb9dac2facbc3748\",\"urls\":[\"bzz-raw://8572be8c0a68120a7ddb61d39e2ceb75d6e07b37b04b8fa9654d87215ac94775\",\"dweb:/ipfs/QmYabWxXUCYW9QZwjRVQd8kQKG9ynmTsJ48kTXast2qxhS\"]}},\"version\":1}"},"hashes":{"decodeMessage(bytes)":"634d45b2","executeMessage(bytes32,uint256,bytes,address)":"a6060871","gaiaTears()":"acac4bdd","getTrustedRemote(uint256)":"84a12b0f","messageBus()":"a1a227fa","msgGasLimit()":"c0e07f28","owner()":"8da5cb5b","renounceOwnership()":"715018a6","sendTear(uint256,uint256)":"82731903","setMessageBus(address)":"547cad12","setMsgGasLimit(uint256)":"f9ecc6f5","setTrustedRemote(uint256,bytes32)":"bd3583ae","transferOwnership(address)":"f2fde38b"}}}