package main

import (
	"fmt"
	"github.com/synapsecns/sanguine/sin-executor/contracts/interchainclient"
	"os"
	"reflect"
	"unicode"
)

//go:generate go run github.com/synapsecns/sanguine/services/sin-explorer/graphql/schema

// gqlgen takes a "schema-first" approach rather than a "code first" approach. This is normally good, but
// in our case, we already have the code from events in our contracts through abigen. Rather than code these
// schemas by hand, we use the already generated structs created in abigen and convert them to graphql types.
// because of the way this is done, this is "package main" and it should be the only go functionality in this package.

// here, we define the models we're going to convert to gql objects
func main() {
	out := GenerateGraphQLSchema(interchainclient.InterchainClientV1InterchainTransactionSent{}, interchainclient.InterchainClientV1InterchainTransactionReceived{})

	file, err := os.Create("generated.graphql")
	if err != nil {
		panic(err)
	}

	_, err = file.WriteString(out)
	if err != nil {
		panic(err)
	}

	err = file.Close()
	if err != nil {
		panic(err)
	}
}

// GenerateGraphQLSchema takes any struct and generates a GraphQL schema string
func GenerateGraphQLSchema(models ...interface{}) string {
	schema := "# This file is generated from the GraphQL schema. Do not edit this file.\n\n"
	for _, s := range models {
		t := reflect.TypeOf(s)
		typeName := t.Name()
		if typeName == "" {
			typeName = "YourStructName"
		}

		schema += fmt.Sprintf("type %s {\n", typeName)
		for i := 0; i < t.NumField(); i++ {
			field := t.Field(i)
			graphqlType := goTypeToGraphQLType(field.Type)
			schema += fmt.Sprintf("  %s: %s\n", toLowerCamelCase(field.Name), graphqlType)
		}
		schema += "}\n\n"
	}
	return schema
}

// goTypeToGraphQLType maps Go types to GraphQL types
func goTypeToGraphQLType(t reflect.Type) string {
	switch t.Kind() {
	case reflect.Array, reflect.Slice:
		if t.Elem().Kind() == reflect.Uint8 { // Assuming it's a byte slice or array
			return "String"
		}
	case reflect.Ptr:
		// Assuming it's a pointer to a big integer or similar
		return "String"
	}

	// Simplified mapping, expand as needed
	switch t.Name() {
	case "[32]byte":
		return "String"
	case "big.Int":
		return "String"
	}

	return "String" // Default mapping for simplicity
}

// toLowerCamelCase converts a string to lower camel case
func toLowerCamelCase(s string) string {
	for i, v := range s {
		return string(unicode.ToLower(v)) + s[i+1:]
	}
	return ""
}
