type CacheContent = {
  value: any
  timestamp: number
}

export const MS_TIMES = {
  ONE_SECOND: 1000,
  THIRTY_SECONDS: 30 * 1000,
  ONE_MINUTE: 60 * 1000,
  FIVE_MINUTES: 5 * 60 * 1000,
  TEN_MINUTES: 10 * 60 * 1000,
  ONE_HOUR: 60 * 60 * 1000,
  ONE_DAY: 24 * 60 * 60 * 1000,
  ONE_WEEK: 7 * 24 * 60 * 60 * 1000,
}
/**
 * A decorator function that caches the result of a method call for a specified duration (`maxAge`).
 * The cache is unique per set of arguments passed to the method. If a method is called again with the same
 * arguments within the `maxAge` period, the cached result is returned instead of executing the method again.
 *
 * @param {number} maxAge - The duration in milliseconds for which the cache is valid.
 * @returns {Function} - A decorator function that takes three parameters:
 *             - `target`: The class that the method belongs to.
 *             - `propertyKey`: The name of the method being decorated.
 *             - `descriptor`: The property descriptor for the method.
 *             This function modifies the `descriptor.value` to include caching logic.
 *
 * Usage:
 * - To use, apply `@SimpleCache(maxAge)` above a class method.
 * - `maxAge` should be provided in milliseconds.
 *
 * Example:
 * ```
 * class MonkeService {
 *   @SimpleCache(30000) // Cache for 30 seconds
 *   fetchBananas(params) {
 *   // Fetch data logic...
 *   }
 * }
 * ```
 *
 * How it works:
 * - On the first method call with a set of arguments,
 *   the result is computed and stored in the cache along
 *   with the current timestamp.
 * - If the method is called again with the same arguments
 *   before `maxAge` has passed, the cached result is returned.
 * - If `maxAge` has passed or the method is called with
 *   different arguments, the method is executed again and the
 *   cache is updated.
 *
 * Note:
 * - The cache key is generated by serializing the method's
 *   arguments, so it's important that the arguments are
 *   consistently serializable.
 * - This implementation uses console logging to indicate
 *   whether a cached result is returned or a new result is
 *   computed.
 */
export function SimpleCache(maxAge: number) {
  /* @ts-ignore */
  return function(
    _: Object, // target
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value
    const cache: Record<string, CacheContent> = {}

    descriptor.value = function(...args: any[]) {
      const key = JSON.stringify(args)
      const now = Date.now()

      if (cache[key] && now - cache[key].timestamp < maxAge) {
        console.log(`Returning cached result for ${propertyKey}`)
        return cache[key].value
      }

      console.log(`Calculating result for ${propertyKey}`)
      const result = originalMethod.apply(this, args)
      cache[key] = {
        value: result,
        timestamp: Date.now()
      }
      return result
    }
  }
}

// export function SimpleAsyncCache(maxAge: number) {
//   console.log("SimpleAsyncCache")
//   return function(target: Object, propertyKey: string, descriptor: PropertyDescriptor) {
//     console.log(target)
//     const originalMethod = descriptor.value;
//     const cache: Record<string, CacheContent> = {};

//     descriptor.value = async function(...args: any[]) {
//       const key = JSON.stringify(args);
//       const now = Date.now();

//       if (cache[key] && now - cache[key].timestamp < maxAge) {
//         console.log(`Returning cached result for ${propertyKey}`);
//         return Promise.resolve(cache[key].value);
//       }

//       console.log(`Calculating result for ${propertyKey}`);
//       const result = await originalMethod.apply(this, args);
//       cache[key] = { value: result, timestamp: Date.now() };
//       return result;
//     }
//   }
// }