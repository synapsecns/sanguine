/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */

import {
    ethers,
    EventFilter,
    Signer,
    BigNumber,
    BigNumberish,
    PopulatedTransaction,
    BaseContract,
    ContractTransaction,
    Overrides,
    PayableOverrides,
    CallOverrides,
  } from "ethers";
  import { BytesLike } from "@ethersproject/bytes";
  import { Listener, Provider } from "@ethersproject/providers";
  import { FunctionFragment, EventFragment, Result } from "@ethersproject/abi";
  import { TypedEventFilter, TypedEvent, TypedListener } from "./commons";
  
  interface SynapseRouterInterface extends ethers.utils.Interface {
    functions: {
      "adapterSwap(address,address,uint256,address,bytes)": FunctionFragment;
      "addToken(string,address,uint8,address,uint256,uint256,uint256)": FunctionFragment;
      "addTokens(tuple[])": FunctionFragment;
      "allPools()": FunctionFragment;
      "bridge(address,uint256,address,uint256,tuple,tuple)": FunctionFragment;
      "bridgeTokens()": FunctionFragment;
      "bridgeTokensAmount()": FunctionFragment;
      "calculateAddLiquidity(address,uint256[])": FunctionFragment;
      "calculateBridgeFee(address,uint256)": FunctionFragment;
      "calculateRemoveLiquidity(address,uint256)": FunctionFragment;
      "calculateSwap(address,uint8,uint8,uint256)": FunctionFragment;
      "calculateWithdrawOneToken(address,uint256,uint8)": FunctionFragment;
      "config(address)": FunctionFragment;
      "fee(address)": FunctionFragment;
      "getAmountOut(address,address,uint256)": FunctionFragment;
      "getConnectedBridgeTokens(address)": FunctionFragment;
      "getDestinationAmountOut(tuple[],address)": FunctionFragment;
      "getOriginAmountOut(address,string[],uint256)": FunctionFragment;
      "owner()": FunctionFragment;
      "poolInfo(address)": FunctionFragment;
      "poolTokens(address)": FunctionFragment;
      "poolsAmount()": FunctionFragment;
      "removeToken(address)": FunctionFragment;
      "removeTokens(address[])": FunctionFragment;
      "renounceOwnership()": FunctionFragment;
      "setAllowance(address,address,uint256)": FunctionFragment;
      "setSwapQuoter(address)": FunctionFragment;
      "setTokenConfig(address,uint8,address)": FunctionFragment;
      "setTokenFee(address,uint256,uint256,uint256)": FunctionFragment;
      "swap(address,address,uint256,tuple)": FunctionFragment;
      "swapQuoter()": FunctionFragment;
      "symbolToToken(string)": FunctionFragment;
      "synapseBridge()": FunctionFragment;
      "tokenToSymbol(address)": FunctionFragment;
      "transferOwnership(address)": FunctionFragment;
    };
  
    encodeFunctionData(
      functionFragment: "adapterSwap",
      values: [string, string, BigNumberish, string, BytesLike]
    ): string;
    encodeFunctionData(
      functionFragment: "addToken",
      values: [
        string,
        string,
        BigNumberish,
        string,
        BigNumberish,
        BigNumberish,
        BigNumberish
      ]
    ): string;
    encodeFunctionData(
      functionFragment: "addTokens",
      values: [
        {
          id: string;
          token: string;
          tokenType: BigNumberish;
          bridgeToken: string;
          bridgeFee: BigNumberish;
          minFee: BigNumberish;
          maxFee: BigNumberish;
        }[]
      ]
    ): string;
    encodeFunctionData(functionFragment: "allPools", values?: undefined): string;
    encodeFunctionData(
      functionFragment: "bridge",
      values: [
        string,
        BigNumberish,
        string,
        BigNumberish,
        {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        }
      ]
    ): string;
    encodeFunctionData(
      functionFragment: "bridgeTokens",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "bridgeTokensAmount",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "calculateAddLiquidity",
      values: [string, BigNumberish[]]
    ): string;
    encodeFunctionData(
      functionFragment: "calculateBridgeFee",
      values: [string, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "calculateRemoveLiquidity",
      values: [string, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "calculateSwap",
      values: [string, BigNumberish, BigNumberish, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "calculateWithdrawOneToken",
      values: [string, BigNumberish, BigNumberish]
    ): string;
    encodeFunctionData(functionFragment: "config", values: [string]): string;
    encodeFunctionData(functionFragment: "fee", values: [string]): string;
    encodeFunctionData(
      functionFragment: "getAmountOut",
      values: [string, string, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "getConnectedBridgeTokens",
      values: [string]
    ): string;
    encodeFunctionData(
      functionFragment: "getDestinationAmountOut",
      values: [{ symbol: string; amountIn: BigNumberish }[], string]
    ): string;
    encodeFunctionData(
      functionFragment: "getOriginAmountOut",
      values: [string, string[], BigNumberish]
    ): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "poolInfo", values: [string]): string;
    encodeFunctionData(functionFragment: "poolTokens", values: [string]): string;
    encodeFunctionData(
      functionFragment: "poolsAmount",
      values?: undefined
    ): string;
    encodeFunctionData(functionFragment: "removeToken", values: [string]): string;
    encodeFunctionData(
      functionFragment: "removeTokens",
      values: [string[]]
    ): string;
    encodeFunctionData(
      functionFragment: "renounceOwnership",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "setAllowance",
      values: [string, string, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "setSwapQuoter",
      values: [string]
    ): string;
    encodeFunctionData(
      functionFragment: "setTokenConfig",
      values: [string, BigNumberish, string]
    ): string;
    encodeFunctionData(
      functionFragment: "setTokenFee",
      values: [string, BigNumberish, BigNumberish, BigNumberish]
    ): string;
    encodeFunctionData(
      functionFragment: "swap",
      values: [
        string,
        string,
        BigNumberish,
        {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        }
      ]
    ): string;
    encodeFunctionData(
      functionFragment: "swapQuoter",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "symbolToToken",
      values: [string]
    ): string;
    encodeFunctionData(
      functionFragment: "synapseBridge",
      values?: undefined
    ): string;
    encodeFunctionData(
      functionFragment: "tokenToSymbol",
      values: [string]
    ): string;
    encodeFunctionData(
      functionFragment: "transferOwnership",
      values: [string]
    ): string;
  
    decodeFunctionResult(
      functionFragment: "adapterSwap",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "addToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "addTokens", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "allPools", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "bridge", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "bridgeTokens",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "bridgeTokensAmount",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "calculateAddLiquidity",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "calculateBridgeFee",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "calculateRemoveLiquidity",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "calculateSwap",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "calculateWithdrawOneToken",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "config", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "fee", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "getAmountOut",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "getConnectedBridgeTokens",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "getDestinationAmountOut",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "getOriginAmountOut",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "poolInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "poolTokens", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "poolsAmount",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "removeToken",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "removeTokens",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "renounceOwnership",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "setAllowance",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "setSwapQuoter",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "setTokenConfig",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "setTokenFee",
      data: BytesLike
    ): Result;
    decodeFunctionResult(functionFragment: "swap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "swapQuoter", data: BytesLike): Result;
    decodeFunctionResult(
      functionFragment: "symbolToToken",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "synapseBridge",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "tokenToSymbol",
      data: BytesLike
    ): Result;
    decodeFunctionResult(
      functionFragment: "transferOwnership",
      data: BytesLike
    ): Result;
  
    events: {
      "OwnershipTransferred(address,address)": EventFragment;
    };
  
    getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  }
  
  export class SynapseRouter extends BaseContract {
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
  
    listeners<EventArgsArray extends Array<any>, EventArgsObject>(
      eventFilter?: TypedEventFilter<EventArgsArray, EventArgsObject>
    ): Array<TypedListener<EventArgsArray, EventArgsObject>>;
    off<EventArgsArray extends Array<any>, EventArgsObject>(
      eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
      listener: TypedListener<EventArgsArray, EventArgsObject>
    ): this;
    on<EventArgsArray extends Array<any>, EventArgsObject>(
      eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
      listener: TypedListener<EventArgsArray, EventArgsObject>
    ): this;
    once<EventArgsArray extends Array<any>, EventArgsObject>(
      eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
      listener: TypedListener<EventArgsArray, EventArgsObject>
    ): this;
    removeListener<EventArgsArray extends Array<any>, EventArgsObject>(
      eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>,
      listener: TypedListener<EventArgsArray, EventArgsObject>
    ): this;
    removeAllListeners<EventArgsArray extends Array<any>, EventArgsObject>(
      eventFilter: TypedEventFilter<EventArgsArray, EventArgsObject>
    ): this;
  
    listeners(eventName?: string): Array<Listener>;
    off(eventName: string, listener: Listener): this;
    on(eventName: string, listener: Listener): this;
    once(eventName: string, listener: Listener): this;
    removeListener(eventName: string, listener: Listener): this;
    removeAllListeners(eventName?: string): this;
  
    queryFilter<EventArgsArray extends Array<any>, EventArgsObject>(
      event: TypedEventFilter<EventArgsArray, EventArgsObject>,
      fromBlockOrBlockhash?: string | number | undefined,
      toBlock?: string | number | undefined
    ): Promise<Array<TypedEvent<EventArgsArray & EventArgsObject>>>;
  
    interface: SynapseRouterInterface;
  
    functions: {
      adapterSwap(
        to: string,
        tokenIn: string,
        amountIn: BigNumberish,
        tokenOut: string,
        rawParams: BytesLike,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      addToken(
        symbol: string,
        token: string,
        tokenType: BigNumberish,
        bridgeToken: string,
        bridgeFee: BigNumberish,
        minFee: BigNumberish,
        maxFee: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      addTokens(
        tokens: {
          id: string;
          token: string;
          tokenType: BigNumberish;
          bridgeToken: string;
          bridgeFee: BigNumberish;
          minFee: BigNumberish;
          maxFee: BigNumberish;
        }[],
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      allPools(
        overrides?: CallOverrides
      ): Promise<
        [
          ([
            string,
            string,
            ([boolean, string] & { isWeth: boolean; token: string })[]
          ] & {
            pool: string;
            lpToken: string;
            tokens: ([boolean, string] & { isWeth: boolean; token: string })[];
          })[]
        ] & {
          pools: ([
            string,
            string,
            ([boolean, string] & { isWeth: boolean; token: string })[]
          ] & {
            pool: string;
            lpToken: string;
            tokens: ([boolean, string] & { isWeth: boolean; token: string })[];
          })[];
        }
      >;
  
      bridge(
        to: string,
        chainId: BigNumberish,
        token: string,
        amount: BigNumberish,
        originQuery: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        destQuery: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      bridgeTokens(
        overrides?: CallOverrides
      ): Promise<[string[]] & { tokens: string[] }>;
  
      bridgeTokensAmount(
        overrides?: CallOverrides
      ): Promise<[BigNumber] & { amount: BigNumber }>;
  
      calculateAddLiquidity(
        pool: string,
        amounts: BigNumberish[],
        overrides?: CallOverrides
      ): Promise<[BigNumber]>;
  
      calculateBridgeFee(
        token: string,
        amount: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[BigNumber] & { feeAmount: BigNumber }>;
  
      calculateRemoveLiquidity(
        pool: string,
        amount: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[BigNumber[]] & { amountsOut: BigNumber[] }>;
  
      calculateSwap(
        pool: string,
        tokenIndexFrom: BigNumberish,
        tokenIndexTo: BigNumberish,
        dx: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[BigNumber] & { amountOut: BigNumber }>;
  
      calculateWithdrawOneToken(
        pool: string,
        tokenAmount: BigNumberish,
        tokenIndex: BigNumberish,
        overrides?: CallOverrides
      ): Promise<[BigNumber] & { amountOut: BigNumber }>;
  
      config(
        arg0: string,
        overrides?: CallOverrides
      ): Promise<[number, string] & { tokenType: number; bridgeToken: string }>;
  
      fee(
        arg0: string,
        overrides?: CallOverrides
      ): Promise<
        [number, BigNumber, BigNumber] & {
          bridgeFee: number;
          minFee: BigNumber;
          maxFee: BigNumber;
        }
      >;
  
      getAmountOut(
        tokenIn: string,
        tokenOut: string,
        amountIn: BigNumberish,
        overrides?: CallOverrides
      ): Promise<
        [
          [string, string, BigNumber, BigNumber, string] & {
            swapAdapter: string;
            tokenOut: string;
            minAmountOut: BigNumber;
            deadline: BigNumber;
            rawParams: string;
          }
        ]
      >;
  
      getConnectedBridgeTokens(
        tokenOut: string,
        overrides?: CallOverrides
      ): Promise<
        [([string, string] & { symbol: string; token: string })[]] & {
          tokens: ([string, string] & { symbol: string; token: string })[];
        }
      >;
  
      getDestinationAmountOut(
        requests: { symbol: string; amountIn: BigNumberish }[],
        tokenOut: string,
        overrides?: CallOverrides
      ): Promise<
        [
          ([string, string, BigNumber, BigNumber, string] & {
            swapAdapter: string;
            tokenOut: string;
            minAmountOut: BigNumber;
            deadline: BigNumber;
            rawParams: string;
          })[]
        ] & {
          destQueries: ([string, string, BigNumber, BigNumber, string] & {
            swapAdapter: string;
            tokenOut: string;
            minAmountOut: BigNumber;
            deadline: BigNumber;
            rawParams: string;
          })[];
        }
      >;
  
      getOriginAmountOut(
        tokenIn: string,
        tokenSymbols: string[],
        amountIn: BigNumberish,
        overrides?: CallOverrides
      ): Promise<
        [
          ([string, string, BigNumber, BigNumber, string] & {
            swapAdapter: string;
            tokenOut: string;
            minAmountOut: BigNumber;
            deadline: BigNumber;
            rawParams: string;
          })[]
        ] & {
          originQueries: ([string, string, BigNumber, BigNumber, string] & {
            swapAdapter: string;
            tokenOut: string;
            minAmountOut: BigNumber;
            deadline: BigNumber;
            rawParams: string;
          })[];
        }
      >;
  
      owner(overrides?: CallOverrides): Promise<[string]>;
  
      poolInfo(
        pool: string,
        overrides?: CallOverrides
      ): Promise<[BigNumber, string]>;
  
      poolTokens(
        pool: string,
        overrides?: CallOverrides
      ): Promise<
        [([boolean, string] & { isWeth: boolean; token: string })[]] & {
          tokens: ([boolean, string] & { isWeth: boolean; token: string })[];
        }
      >;
  
      poolsAmount(
        overrides?: CallOverrides
      ): Promise<[BigNumber] & { amount: BigNumber }>;
  
      removeToken(
        token: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      removeTokens(
        tokens: string[],
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      renounceOwnership(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      setAllowance(
        token: string,
        spender: string,
        amount: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      setSwapQuoter(
        _swapQuoter: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      setTokenConfig(
        token: string,
        tokenType: BigNumberish,
        bridgeToken: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      setTokenFee(
        token: string,
        bridgeFee: BigNumberish,
        minFee: BigNumberish,
        maxFee: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      swap(
        to: string,
        token: string,
        amount: BigNumberish,
        query: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
  
      swapQuoter(overrides?: CallOverrides): Promise<[string]>;
  
      symbolToToken(arg0: string, overrides?: CallOverrides): Promise<[string]>;
  
      synapseBridge(overrides?: CallOverrides): Promise<[string]>;
  
      tokenToSymbol(arg0: string, overrides?: CallOverrides): Promise<[string]>;
  
      transferOwnership(
        newOwner: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<ContractTransaction>;
    };
  
    adapterSwap(
      to: string,
      tokenIn: string,
      amountIn: BigNumberish,
      tokenOut: string,
      rawParams: BytesLike,
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    addToken(
      symbol: string,
      token: string,
      tokenType: BigNumberish,
      bridgeToken: string,
      bridgeFee: BigNumberish,
      minFee: BigNumberish,
      maxFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    addTokens(
      tokens: {
        id: string;
        token: string;
        tokenType: BigNumberish;
        bridgeToken: string;
        bridgeFee: BigNumberish;
        minFee: BigNumberish;
        maxFee: BigNumberish;
      }[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    allPools(
      overrides?: CallOverrides
    ): Promise<
      ([
        string,
        string,
        ([boolean, string] & { isWeth: boolean; token: string })[]
      ] & {
        pool: string;
        lpToken: string;
        tokens: ([boolean, string] & { isWeth: boolean; token: string })[];
      })[]
    >;
  
    bridge(
      to: string,
      chainId: BigNumberish,
      token: string,
      amount: BigNumberish,
      originQuery: {
        swapAdapter: string;
        tokenOut: string;
        minAmountOut: BigNumberish;
        deadline: BigNumberish;
        rawParams: BytesLike;
      },
      destQuery: {
        swapAdapter: string;
        tokenOut: string;
        minAmountOut: BigNumberish;
        deadline: BigNumberish;
        rawParams: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    bridgeTokens(overrides?: CallOverrides): Promise<string[]>;
  
    bridgeTokensAmount(overrides?: CallOverrides): Promise<BigNumber>;
  
    calculateAddLiquidity(
      pool: string,
      amounts: BigNumberish[],
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  
    calculateBridgeFee(
      token: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  
    calculateRemoveLiquidity(
      pool: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber[]>;
  
    calculateSwap(
      pool: string,
      tokenIndexFrom: BigNumberish,
      tokenIndexTo: BigNumberish,
      dx: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  
    calculateWithdrawOneToken(
      pool: string,
      tokenAmount: BigNumberish,
      tokenIndex: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;
  
    config(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<[number, string] & { tokenType: number; bridgeToken: string }>;
  
    fee(
      arg0: string,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber] & {
        bridgeFee: number;
        minFee: BigNumber;
        maxFee: BigNumber;
      }
    >;
  
    getAmountOut(
      tokenIn: string,
      tokenOut: string,
      amountIn: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, string, BigNumber, BigNumber, string] & {
        swapAdapter: string;
        tokenOut: string;
        minAmountOut: BigNumber;
        deadline: BigNumber;
        rawParams: string;
      }
    >;
  
    getConnectedBridgeTokens(
      tokenOut: string,
      overrides?: CallOverrides
    ): Promise<([string, string] & { symbol: string; token: string })[]>;
  
    getDestinationAmountOut(
      requests: { symbol: string; amountIn: BigNumberish }[],
      tokenOut: string,
      overrides?: CallOverrides
    ): Promise<
      ([string, string, BigNumber, BigNumber, string] & {
        swapAdapter: string;
        tokenOut: string;
        minAmountOut: BigNumber;
        deadline: BigNumber;
        rawParams: string;
      })[]
    >;
  
    getOriginAmountOut(
      tokenIn: string,
      tokenSymbols: string[],
      amountIn: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      ([string, string, BigNumber, BigNumber, string] & {
        swapAdapter: string;
        tokenOut: string;
        minAmountOut: BigNumber;
        deadline: BigNumber;
        rawParams: string;
      })[]
    >;
  
    owner(overrides?: CallOverrides): Promise<string>;
  
    poolInfo(
      pool: string,
      overrides?: CallOverrides
    ): Promise<[BigNumber, string]>;
  
    poolTokens(
      pool: string,
      overrides?: CallOverrides
    ): Promise<([boolean, string] & { isWeth: boolean; token: string })[]>;
  
    poolsAmount(overrides?: CallOverrides): Promise<BigNumber>;
  
    removeToken(
      token: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    removeTokens(
      tokens: string[],
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    renounceOwnership(
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    setAllowance(
      token: string,
      spender: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    setSwapQuoter(
      _swapQuoter: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    setTokenConfig(
      token: string,
      tokenType: BigNumberish,
      bridgeToken: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    setTokenFee(
      token: string,
      bridgeFee: BigNumberish,
      minFee: BigNumberish,
      maxFee: BigNumberish,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    swap(
      to: string,
      token: string,
      amount: BigNumberish,
      query: {
        swapAdapter: string;
        tokenOut: string;
        minAmountOut: BigNumberish;
        deadline: BigNumberish;
        rawParams: BytesLike;
      },
      overrides?: PayableOverrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    swapQuoter(overrides?: CallOverrides): Promise<string>;
  
    symbolToToken(arg0: string, overrides?: CallOverrides): Promise<string>;
  
    synapseBridge(overrides?: CallOverrides): Promise<string>;
  
    tokenToSymbol(arg0: string, overrides?: CallOverrides): Promise<string>;
  
    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string | Promise<string> }
    ): Promise<ContractTransaction>;
  
    callStatic: {
      adapterSwap(
        to: string,
        tokenIn: string,
        amountIn: BigNumberish,
        tokenOut: string,
        rawParams: BytesLike,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      addToken(
        symbol: string,
        token: string,
        tokenType: BigNumberish,
        bridgeToken: string,
        bridgeFee: BigNumberish,
        minFee: BigNumberish,
        maxFee: BigNumberish,
        overrides?: CallOverrides
      ): Promise<boolean>;
  
      addTokens(
        tokens: {
          id: string;
          token: string;
          tokenType: BigNumberish;
          bridgeToken: string;
          bridgeFee: BigNumberish;
          minFee: BigNumberish;
          maxFee: BigNumberish;
        }[],
        overrides?: CallOverrides
      ): Promise<void>;
  
      allPools(
        overrides?: CallOverrides
      ): Promise<
        ([
          string,
          string,
          ([boolean, string] & { isWeth: boolean; token: string })[]
        ] & {
          pool: string;
          lpToken: string;
          tokens: ([boolean, string] & { isWeth: boolean; token: string })[];
        })[]
      >;
  
      bridge(
        to: string,
        chainId: BigNumberish,
        token: string,
        amount: BigNumberish,
        originQuery: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        destQuery: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        overrides?: CallOverrides
      ): Promise<void>;
  
      bridgeTokens(overrides?: CallOverrides): Promise<string[]>;
  
      bridgeTokensAmount(overrides?: CallOverrides): Promise<BigNumber>;
  
      calculateAddLiquidity(
        pool: string,
        amounts: BigNumberish[],
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      calculateBridgeFee(
        token: string,
        amount: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      calculateRemoveLiquidity(
        pool: string,
        amount: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber[]>;
  
      calculateSwap(
        pool: string,
        tokenIndexFrom: BigNumberish,
        tokenIndexTo: BigNumberish,
        dx: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      calculateWithdrawOneToken(
        pool: string,
        tokenAmount: BigNumberish,
        tokenIndex: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      config(
        arg0: string,
        overrides?: CallOverrides
      ): Promise<[number, string] & { tokenType: number; bridgeToken: string }>;
  
      fee(
        arg0: string,
        overrides?: CallOverrides
      ): Promise<
        [number, BigNumber, BigNumber] & {
          bridgeFee: number;
          minFee: BigNumber;
          maxFee: BigNumber;
        }
      >;
  
      getAmountOut(
        tokenIn: string,
        tokenOut: string,
        amountIn: BigNumberish,
        overrides?: CallOverrides
      ): Promise<
        [string, string, BigNumber, BigNumber, string] & {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumber;
          deadline: BigNumber;
          rawParams: string;
        }
      >;
  
      getConnectedBridgeTokens(
        tokenOut: string,
        overrides?: CallOverrides
      ): Promise<([string, string] & { symbol: string; token: string })[]>;
  
      getDestinationAmountOut(
        requests: { symbol: string; amountIn: BigNumberish }[],
        tokenOut: string,
        overrides?: CallOverrides
      ): Promise<
        ([string, string, BigNumber, BigNumber, string] & {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumber;
          deadline: BigNumber;
          rawParams: string;
        })[]
      >;
  
      getOriginAmountOut(
        tokenIn: string,
        tokenSymbols: string[],
        amountIn: BigNumberish,
        overrides?: CallOverrides
      ): Promise<
        ([string, string, BigNumber, BigNumber, string] & {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumber;
          deadline: BigNumber;
          rawParams: string;
        })[]
      >;
  
      owner(overrides?: CallOverrides): Promise<string>;
  
      poolInfo(
        pool: string,
        overrides?: CallOverrides
      ): Promise<[BigNumber, string]>;
  
      poolTokens(
        pool: string,
        overrides?: CallOverrides
      ): Promise<([boolean, string] & { isWeth: boolean; token: string })[]>;
  
      poolsAmount(overrides?: CallOverrides): Promise<BigNumber>;
  
      removeToken(token: string, overrides?: CallOverrides): Promise<boolean>;
  
      removeTokens(tokens: string[], overrides?: CallOverrides): Promise<void>;
  
      renounceOwnership(overrides?: CallOverrides): Promise<void>;
  
      setAllowance(
        token: string,
        spender: string,
        amount: BigNumberish,
        overrides?: CallOverrides
      ): Promise<void>;
  
      setSwapQuoter(
        _swapQuoter: string,
        overrides?: CallOverrides
      ): Promise<void>;
  
      setTokenConfig(
        token: string,
        tokenType: BigNumberish,
        bridgeToken: string,
        overrides?: CallOverrides
      ): Promise<void>;
  
      setTokenFee(
        token: string,
        bridgeFee: BigNumberish,
        minFee: BigNumberish,
        maxFee: BigNumberish,
        overrides?: CallOverrides
      ): Promise<void>;
  
      swap(
        to: string,
        token: string,
        amount: BigNumberish,
        query: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      swapQuoter(overrides?: CallOverrides): Promise<string>;
  
      symbolToToken(arg0: string, overrides?: CallOverrides): Promise<string>;
  
      synapseBridge(overrides?: CallOverrides): Promise<string>;
  
      tokenToSymbol(arg0: string, overrides?: CallOverrides): Promise<string>;
  
      transferOwnership(
        newOwner: string,
        overrides?: CallOverrides
      ): Promise<void>;
    };
  
    filters: {
      OwnershipTransferred(
        previousOwner?: string | null,
        newOwner?: string | null
      ): TypedEventFilter<
        [string, string],
        { previousOwner: string; newOwner: string }
      >;
    };
  
    estimateGas: {
      adapterSwap(
        to: string,
        tokenIn: string,
        amountIn: BigNumberish,
        tokenOut: string,
        rawParams: BytesLike,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      addToken(
        symbol: string,
        token: string,
        tokenType: BigNumberish,
        bridgeToken: string,
        bridgeFee: BigNumberish,
        minFee: BigNumberish,
        maxFee: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      addTokens(
        tokens: {
          id: string;
          token: string;
          tokenType: BigNumberish;
          bridgeToken: string;
          bridgeFee: BigNumberish;
          minFee: BigNumberish;
          maxFee: BigNumberish;
        }[],
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      allPools(overrides?: CallOverrides): Promise<BigNumber>;
  
      bridge(
        to: string,
        chainId: BigNumberish,
        token: string,
        amount: BigNumberish,
        originQuery: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        destQuery: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      bridgeTokens(overrides?: CallOverrides): Promise<BigNumber>;
  
      bridgeTokensAmount(overrides?: CallOverrides): Promise<BigNumber>;
  
      calculateAddLiquidity(
        pool: string,
        amounts: BigNumberish[],
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      calculateBridgeFee(
        token: string,
        amount: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      calculateRemoveLiquidity(
        pool: string,
        amount: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      calculateSwap(
        pool: string,
        tokenIndexFrom: BigNumberish,
        tokenIndexTo: BigNumberish,
        dx: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      calculateWithdrawOneToken(
        pool: string,
        tokenAmount: BigNumberish,
        tokenIndex: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      config(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
  
      fee(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
  
      getAmountOut(
        tokenIn: string,
        tokenOut: string,
        amountIn: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      getConnectedBridgeTokens(
        tokenOut: string,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      getDestinationAmountOut(
        requests: { symbol: string; amountIn: BigNumberish }[],
        tokenOut: string,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      getOriginAmountOut(
        tokenIn: string,
        tokenSymbols: string[],
        amountIn: BigNumberish,
        overrides?: CallOverrides
      ): Promise<BigNumber>;
  
      owner(overrides?: CallOverrides): Promise<BigNumber>;
  
      poolInfo(pool: string, overrides?: CallOverrides): Promise<BigNumber>;
  
      poolTokens(pool: string, overrides?: CallOverrides): Promise<BigNumber>;
  
      poolsAmount(overrides?: CallOverrides): Promise<BigNumber>;
  
      removeToken(
        token: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      removeTokens(
        tokens: string[],
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      renounceOwnership(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      setAllowance(
        token: string,
        spender: string,
        amount: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      setSwapQuoter(
        _swapQuoter: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      setTokenConfig(
        token: string,
        tokenType: BigNumberish,
        bridgeToken: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      setTokenFee(
        token: string,
        bridgeFee: BigNumberish,
        minFee: BigNumberish,
        maxFee: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      swap(
        to: string,
        token: string,
        amount: BigNumberish,
        query: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
  
      swapQuoter(overrides?: CallOverrides): Promise<BigNumber>;
  
      symbolToToken(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
  
      synapseBridge(overrides?: CallOverrides): Promise<BigNumber>;
  
      tokenToSymbol(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
  
      transferOwnership(
        newOwner: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<BigNumber>;
    };
  
    populateTransaction: {
      adapterSwap(
        to: string,
        tokenIn: string,
        amountIn: BigNumberish,
        tokenOut: string,
        rawParams: BytesLike,
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      addToken(
        symbol: string,
        token: string,
        tokenType: BigNumberish,
        bridgeToken: string,
        bridgeFee: BigNumberish,
        minFee: BigNumberish,
        maxFee: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      addTokens(
        tokens: {
          id: string;
          token: string;
          tokenType: BigNumberish;
          bridgeToken: string;
          bridgeFee: BigNumberish;
          minFee: BigNumberish;
          maxFee: BigNumberish;
        }[],
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      allPools(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      bridge(
        to: string,
        chainId: BigNumberish,
        token: string,
        amount: BigNumberish,
        originQuery: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        destQuery: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      bridgeTokens(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      bridgeTokensAmount(
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      calculateAddLiquidity(
        pool: string,
        amounts: BigNumberish[],
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      calculateBridgeFee(
        token: string,
        amount: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      calculateRemoveLiquidity(
        pool: string,
        amount: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      calculateSwap(
        pool: string,
        tokenIndexFrom: BigNumberish,
        tokenIndexTo: BigNumberish,
        dx: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      calculateWithdrawOneToken(
        pool: string,
        tokenAmount: BigNumberish,
        tokenIndex: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      config(
        arg0: string,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      fee(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      getAmountOut(
        tokenIn: string,
        tokenOut: string,
        amountIn: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      getConnectedBridgeTokens(
        tokenOut: string,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      getDestinationAmountOut(
        requests: { symbol: string; amountIn: BigNumberish }[],
        tokenOut: string,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      getOriginAmountOut(
        tokenIn: string,
        tokenSymbols: string[],
        amountIn: BigNumberish,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      poolInfo(
        pool: string,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      poolTokens(
        pool: string,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      poolsAmount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      removeToken(
        token: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      removeTokens(
        tokens: string[],
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      renounceOwnership(
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      setAllowance(
        token: string,
        spender: string,
        amount: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      setSwapQuoter(
        _swapQuoter: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      setTokenConfig(
        token: string,
        tokenType: BigNumberish,
        bridgeToken: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      setTokenFee(
        token: string,
        bridgeFee: BigNumberish,
        minFee: BigNumberish,
        maxFee: BigNumberish,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      swap(
        to: string,
        token: string,
        amount: BigNumberish,
        query: {
          swapAdapter: string;
          tokenOut: string;
          minAmountOut: BigNumberish;
          deadline: BigNumberish;
          rawParams: BytesLike;
        },
        overrides?: PayableOverrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
  
      swapQuoter(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      symbolToToken(
        arg0: string,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      synapseBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;
  
      tokenToSymbol(
        arg0: string,
        overrides?: CallOverrides
      ): Promise<PopulatedTransaction>;
  
      transferOwnership(
        newOwner: string,
        overrides?: Overrides & { from?: string | Promise<string> }
      ): Promise<PopulatedTransaction>;
    };
  }
  