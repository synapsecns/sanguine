/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers'
import type { FunctionFragment, Result } from '@ethersproject/abi'
import type { Listener, Provider } from '@ethersproject/providers'
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from './common'

export type SwapQueryStruct = {
  routerAdapter: string
  tokenOut: string
  minAmountOut: BigNumberish
  deadline: BigNumberish
  rawParams: BytesLike
}

export type SwapQueryStructOutput = [
  string,
  string,
  BigNumber,
  BigNumber,
  string
] & {
  routerAdapter: string
  tokenOut: string
  minAmountOut: BigNumber
  deadline: BigNumber
  rawParams: string
}

export type BridgeTokenStruct = { symbol: string; token: string }

export type BridgeTokenStructOutput = [string, string] & {
  symbol: string
  token: string
}

export type DestRequestStruct = { symbol: string; amountIn: BigNumberish }

export type DestRequestStructOutput = [string, BigNumber] & {
  symbol: string
  amountIn: BigNumber
}

export interface SynapseCCTPRouterInterface extends utils.Interface {
  functions: {
    'adapterSwap(address,address,uint256,address,bytes)': FunctionFragment
    'bridge(address,uint256,address,uint256,(address,address,uint256,uint256,bytes),(address,address,uint256,uint256,bytes))': FunctionFragment
    'calculateFeeAmount(address,uint256,bool)': FunctionFragment
    'feeStructures(address)': FunctionFragment
    'getConnectedBridgeTokens(address)': FunctionFragment
    'getDestinationAmountOut((string,uint256)[],address)': FunctionFragment
    'getOriginAmountOut(address,string[],uint256)': FunctionFragment
    'synapseCCTP()': FunctionFragment
  }

  getFunction(
    nameOrSignatureOrTopic:
      | 'adapterSwap'
      | 'bridge'
      | 'calculateFeeAmount'
      | 'feeStructures'
      | 'getConnectedBridgeTokens'
      | 'getDestinationAmountOut'
      | 'getOriginAmountOut'
      | 'synapseCCTP'
  ): FunctionFragment

  encodeFunctionData(
    functionFragment: 'adapterSwap',
    values: [string, string, BigNumberish, string, BytesLike]
  ): string
  encodeFunctionData(
    functionFragment: 'bridge',
    values: [
      string,
      BigNumberish,
      string,
      BigNumberish,
      SwapQueryStruct,
      SwapQueryStruct
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'calculateFeeAmount',
    values: [string, BigNumberish, boolean]
  ): string
  encodeFunctionData(
    functionFragment: 'feeStructures',
    values: [string]
  ): string
  encodeFunctionData(
    functionFragment: 'getConnectedBridgeTokens',
    values: [string]
  ): string
  encodeFunctionData(
    functionFragment: 'getDestinationAmountOut',
    values: [DestRequestStruct[], string]
  ): string
  encodeFunctionData(
    functionFragment: 'getOriginAmountOut',
    values: [string, string[], BigNumberish]
  ): string
  encodeFunctionData(
    functionFragment: 'synapseCCTP',
    values?: undefined
  ): string

  decodeFunctionResult(functionFragment: 'adapterSwap', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'bridge', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'calculateFeeAmount',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'feeStructures',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getConnectedBridgeTokens',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getDestinationAmountOut',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getOriginAmountOut',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'synapseCCTP', data: BytesLike): Result

  events: {}
}

export interface SynapseCCTPRouter extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  interface: SynapseCCTPRouterInterface

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>
  listeners(eventName?: string): Array<Listener>
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this
  removeAllListeners(eventName?: string): this
  off: OnEvent<this>
  on: OnEvent<this>
  once: OnEvent<this>
  removeListener: OnEvent<this>

  functions: {
    adapterSwap(
      recipient: string,
      tokenIn: string,
      amountIn: BigNumberish,
      tokenOut: string,
      rawParams: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>

    bridge(
      recipient: string,
      chainId: BigNumberish,
      token: string,
      amount: BigNumberish,
      originQuery: SwapQueryStruct,
      destQuery: SwapQueryStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>

    calculateFeeAmount(
      token: string,
      amount: BigNumberish,
      isSwap: boolean,
      overrides?: CallOverrides
    ): Promise<[BigNumber] & { fee: BigNumber }>

    feeStructures(
      token: string,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber] & {
        relayerFee: number
        minBaseFee: BigNumber
        minSwapFee: BigNumber
        maxFee: BigNumber
      }
    >

    getConnectedBridgeTokens(
      tokenOut: string,
      overrides?: CallOverrides
    ): Promise<
      [BridgeTokenStructOutput[]] & { tokens: BridgeTokenStructOutput[] }
    >

    getDestinationAmountOut(
      requests: DestRequestStruct[],
      tokenOut: string,
      overrides?: CallOverrides
    ): Promise<
      [SwapQueryStructOutput[]] & { destQueries: SwapQueryStructOutput[] }
    >

    getOriginAmountOut(
      tokenIn: string,
      tokenSymbols: string[],
      amountIn: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [SwapQueryStructOutput[]] & { originQueries: SwapQueryStructOutput[] }
    >

    synapseCCTP(overrides?: CallOverrides): Promise<[string]>
  }

  adapterSwap(
    recipient: string,
    tokenIn: string,
    amountIn: BigNumberish,
    tokenOut: string,
    rawParams: BytesLike,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>

  bridge(
    recipient: string,
    chainId: BigNumberish,
    token: string,
    amount: BigNumberish,
    originQuery: SwapQueryStruct,
    destQuery: SwapQueryStruct,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>

  calculateFeeAmount(
    token: string,
    amount: BigNumberish,
    isSwap: boolean,
    overrides?: CallOverrides
  ): Promise<BigNumber>

  feeStructures(
    token: string,
    overrides?: CallOverrides
  ): Promise<
    [number, BigNumber, BigNumber, BigNumber] & {
      relayerFee: number
      minBaseFee: BigNumber
      minSwapFee: BigNumber
      maxFee: BigNumber
    }
  >

  getConnectedBridgeTokens(
    tokenOut: string,
    overrides?: CallOverrides
  ): Promise<BridgeTokenStructOutput[]>

  getDestinationAmountOut(
    requests: DestRequestStruct[],
    tokenOut: string,
    overrides?: CallOverrides
  ): Promise<SwapQueryStructOutput[]>

  getOriginAmountOut(
    tokenIn: string,
    tokenSymbols: string[],
    amountIn: BigNumberish,
    overrides?: CallOverrides
  ): Promise<SwapQueryStructOutput[]>

  synapseCCTP(overrides?: CallOverrides): Promise<string>

  callStatic: {
    adapterSwap(
      recipient: string,
      tokenIn: string,
      amountIn: BigNumberish,
      tokenOut: string,
      rawParams: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    bridge(
      recipient: string,
      chainId: BigNumberish,
      token: string,
      amount: BigNumberish,
      originQuery: SwapQueryStruct,
      destQuery: SwapQueryStruct,
      overrides?: CallOverrides
    ): Promise<void>

    calculateFeeAmount(
      token: string,
      amount: BigNumberish,
      isSwap: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    feeStructures(
      token: string,
      overrides?: CallOverrides
    ): Promise<
      [number, BigNumber, BigNumber, BigNumber] & {
        relayerFee: number
        minBaseFee: BigNumber
        minSwapFee: BigNumber
        maxFee: BigNumber
      }
    >

    getConnectedBridgeTokens(
      tokenOut: string,
      overrides?: CallOverrides
    ): Promise<BridgeTokenStructOutput[]>

    getDestinationAmountOut(
      requests: DestRequestStruct[],
      tokenOut: string,
      overrides?: CallOverrides
    ): Promise<SwapQueryStructOutput[]>

    getOriginAmountOut(
      tokenIn: string,
      tokenSymbols: string[],
      amountIn: BigNumberish,
      overrides?: CallOverrides
    ): Promise<SwapQueryStructOutput[]>

    synapseCCTP(overrides?: CallOverrides): Promise<string>
  }

  filters: {}

  estimateGas: {
    adapterSwap(
      recipient: string,
      tokenIn: string,
      amountIn: BigNumberish,
      tokenOut: string,
      rawParams: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>

    bridge(
      recipient: string,
      chainId: BigNumberish,
      token: string,
      amount: BigNumberish,
      originQuery: SwapQueryStruct,
      destQuery: SwapQueryStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>

    calculateFeeAmount(
      token: string,
      amount: BigNumberish,
      isSwap: boolean,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    feeStructures(token: string, overrides?: CallOverrides): Promise<BigNumber>

    getConnectedBridgeTokens(
      tokenOut: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getDestinationAmountOut(
      requests: DestRequestStruct[],
      tokenOut: string,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getOriginAmountOut(
      tokenIn: string,
      tokenSymbols: string[],
      amountIn: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    synapseCCTP(overrides?: CallOverrides): Promise<BigNumber>
  }

  populateTransaction: {
    adapterSwap(
      recipient: string,
      tokenIn: string,
      amountIn: BigNumberish,
      tokenOut: string,
      rawParams: BytesLike,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>

    bridge(
      recipient: string,
      chainId: BigNumberish,
      token: string,
      amount: BigNumberish,
      originQuery: SwapQueryStruct,
      destQuery: SwapQueryStruct,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>

    calculateFeeAmount(
      token: string,
      amount: BigNumberish,
      isSwap: boolean,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    feeStructures(
      token: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getConnectedBridgeTokens(
      tokenOut: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getDestinationAmountOut(
      requests: DestRequestStruct[],
      tokenOut: string,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getOriginAmountOut(
      tokenIn: string,
      tokenSymbols: string[],
      amountIn: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    synapseCCTP(overrides?: CallOverrides): Promise<PopulatedTransaction>
  }
}
