// Code generated by mockery v2.9.4. DO NOT EDIT.

package mocks

import (
	big "math/big"

	bind "github.com/ethereum/go-ethereum/accounts/abi/bind"
	common "github.com/ethereum/go-ethereum/common"

	event "github.com/ethereum/go-ethereum/event"

	home "github.com/synapsecns/sanguine/core/contracts/home"

	mock "github.com/stretchr/testify/mock"

	types "github.com/ethereum/go-ethereum/core/types"
)

// IHome is an autogenerated mock type for the IHome type
type IHome struct {
	mock.Mock
}

// Address provides a mock function with given fields:
func (_m *IHome) Address() common.Address {
	ret := _m.Called()

	var r0 common.Address
	if rf, ok := ret.Get(0).(func() common.Address); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	return r0
}

// CommittedRoot provides a mock function with given fields: opts
func (_m *IHome) CommittedRoot(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	var r0 [32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Count provides a mock function with given fields: opts
func (_m *IHome) Count(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Dispatch provides a mock function with given fields: opts, _destinationDomain, _recipientAddress, _optimisticSeconds, _messageBody
func (_m *IHome) Dispatch(opts *bind.TransactOpts, _destinationDomain uint32, _recipientAddress [32]byte, _optimisticSeconds uint32, _messageBody []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, _destinationDomain, _recipientAddress, _optimisticSeconds, _messageBody)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, uint32, [32]byte, uint32, []byte) *types.Transaction); ok {
		r0 = rf(opts, _destinationDomain, _recipientAddress, _optimisticSeconds, _messageBody)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, uint32, [32]byte, uint32, []byte) error); ok {
		r1 = rf(opts, _destinationDomain, _recipientAddress, _optimisticSeconds, _messageBody)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DoubleUpdate provides a mock function with given fields: opts, _oldRoot, _newRoot, _signature, _signature2
func (_m *IHome) DoubleUpdate(opts *bind.TransactOpts, _oldRoot [32]byte, _newRoot [2][32]byte, _signature []byte, _signature2 []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, _oldRoot, _newRoot, _signature, _signature2)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, [2][32]byte, []byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, _oldRoot, _newRoot, _signature, _signature2)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte, [2][32]byte, []byte, []byte) error); ok {
		r1 = rf(opts, _oldRoot, _newRoot, _signature, _signature2)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterDispatch provides a mock function with given fields: opts, messageHash, leafIndex, destinationAndNonce
func (_m *IHome) FilterDispatch(opts *bind.FilterOpts, messageHash [][32]byte, leafIndex []*big.Int, destinationAndNonce []uint64) (*home.HomeDispatchIterator, error) {
	ret := _m.Called(opts, messageHash, leafIndex, destinationAndNonce)

	var r0 *home.HomeDispatchIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, [][32]byte, []*big.Int, []uint64) *home.HomeDispatchIterator); ok {
		r0 = rf(opts, messageHash, leafIndex, destinationAndNonce)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeDispatchIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, [][32]byte, []*big.Int, []uint64) error); ok {
		r1 = rf(opts, messageHash, leafIndex, destinationAndNonce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterDoubleUpdate provides a mock function with given fields: opts
func (_m *IHome) FilterDoubleUpdate(opts *bind.FilterOpts) (*home.HomeDoubleUpdateIterator, error) {
	ret := _m.Called(opts)

	var r0 *home.HomeDoubleUpdateIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *home.HomeDoubleUpdateIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeDoubleUpdateIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterImproperUpdate provides a mock function with given fields: opts
func (_m *IHome) FilterImproperUpdate(opts *bind.FilterOpts) (*home.HomeImproperUpdateIterator, error) {
	ret := _m.Called(opts)

	var r0 *home.HomeImproperUpdateIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *home.HomeImproperUpdateIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeImproperUpdateIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterInitialized provides a mock function with given fields: opts
func (_m *IHome) FilterInitialized(opts *bind.FilterOpts) (*home.HomeInitializedIterator, error) {
	ret := _m.Called(opts)

	var r0 *home.HomeInitializedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *home.HomeInitializedIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeInitializedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterNewUpdater provides a mock function with given fields: opts
func (_m *IHome) FilterNewUpdater(opts *bind.FilterOpts) (*home.HomeNewUpdaterIterator, error) {
	ret := _m.Called(opts)

	var r0 *home.HomeNewUpdaterIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *home.HomeNewUpdaterIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeNewUpdaterIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterNewUpdaterManager provides a mock function with given fields: opts
func (_m *IHome) FilterNewUpdaterManager(opts *bind.FilterOpts) (*home.HomeNewUpdaterManagerIterator, error) {
	ret := _m.Called(opts)

	var r0 *home.HomeNewUpdaterManagerIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts) *home.HomeNewUpdaterManagerIterator); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeNewUpdaterManagerIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterOwnershipTransferred provides a mock function with given fields: opts, previousOwner, newOwner
func (_m *IHome) FilterOwnershipTransferred(opts *bind.FilterOpts, previousOwner []common.Address, newOwner []common.Address) (*home.HomeOwnershipTransferredIterator, error) {
	ret := _m.Called(opts, previousOwner, newOwner)

	var r0 *home.HomeOwnershipTransferredIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *home.HomeOwnershipTransferredIterator); ok {
		r0 = rf(opts, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeOwnershipTransferredIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterUpdate provides a mock function with given fields: opts, homeDomain, oldRoot, newRoot
func (_m *IHome) FilterUpdate(opts *bind.FilterOpts, homeDomain []uint32, oldRoot [][32]byte, newRoot [][32]byte) (*home.HomeUpdateIterator, error) {
	ret := _m.Called(opts, homeDomain, oldRoot, newRoot)

	var r0 *home.HomeUpdateIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []uint32, [][32]byte, [][32]byte) *home.HomeUpdateIterator); ok {
		r0 = rf(opts, homeDomain, oldRoot, newRoot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeUpdateIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []uint32, [][32]byte, [][32]byte) error); ok {
		r1 = rf(opts, homeDomain, oldRoot, newRoot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FilterUpdaterSlashed provides a mock function with given fields: opts, updater, reporter
func (_m *IHome) FilterUpdaterSlashed(opts *bind.FilterOpts, updater []common.Address, reporter []common.Address) (*home.HomeUpdaterSlashedIterator, error) {
	ret := _m.Called(opts, updater, reporter)

	var r0 *home.HomeUpdaterSlashedIterator
	if rf, ok := ret.Get(0).(func(*bind.FilterOpts, []common.Address, []common.Address) *home.HomeUpdaterSlashedIterator); ok {
		r0 = rf(opts, updater, reporter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeUpdaterSlashedIterator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.FilterOpts, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, updater, reporter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// HomeDomainHash provides a mock function with given fields: opts
func (_m *IHome) HomeDomainHash(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	var r0 [32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ImproperUpdate provides a mock function with given fields: opts, _oldRoot, _newRoot, _signature
func (_m *IHome) ImproperUpdate(opts *bind.TransactOpts, _oldRoot [32]byte, _newRoot [32]byte, _signature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, _oldRoot, _newRoot, _signature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, [32]byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, _oldRoot, _newRoot, _signature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte, [32]byte, []byte) error); ok {
		r1 = rf(opts, _oldRoot, _newRoot, _signature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Initialize provides a mock function with given fields: opts, _updaterManager
func (_m *IHome) Initialize(opts *bind.TransactOpts, _updaterManager common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _updaterManager)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _updaterManager)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, _updaterManager)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LocalDomain provides a mock function with given fields: opts
func (_m *IHome) LocalDomain(opts *bind.CallOpts) (uint32, error) {
	ret := _m.Called(opts)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint32); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MAXMESSAGEBODYBYTES provides a mock function with given fields: opts
func (_m *IHome) MAXMESSAGEBODYBYTES(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Nonces provides a mock function with given fields: opts, arg0
func (_m *IHome) Nonces(opts *bind.CallOpts, arg0 uint32) (uint32, error) {
	ret := _m.Called(opts, arg0)

	var r0 uint32
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, uint32) uint32); ok {
		r0 = rf(opts, arg0)
	} else {
		r0 = ret.Get(0).(uint32)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, uint32) error); ok {
		r1 = rf(opts, arg0)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Owner provides a mock function with given fields: opts
func (_m *IHome) Owner(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseDispatch provides a mock function with given fields: log
func (_m *IHome) ParseDispatch(log types.Log) (*home.HomeDispatch, error) {
	ret := _m.Called(log)

	var r0 *home.HomeDispatch
	if rf, ok := ret.Get(0).(func(types.Log) *home.HomeDispatch); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeDispatch)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseDoubleUpdate provides a mock function with given fields: log
func (_m *IHome) ParseDoubleUpdate(log types.Log) (*home.HomeDoubleUpdate, error) {
	ret := _m.Called(log)

	var r0 *home.HomeDoubleUpdate
	if rf, ok := ret.Get(0).(func(types.Log) *home.HomeDoubleUpdate); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeDoubleUpdate)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseImproperUpdate provides a mock function with given fields: log
func (_m *IHome) ParseImproperUpdate(log types.Log) (*home.HomeImproperUpdate, error) {
	ret := _m.Called(log)

	var r0 *home.HomeImproperUpdate
	if rf, ok := ret.Get(0).(func(types.Log) *home.HomeImproperUpdate); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeImproperUpdate)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseInitialized provides a mock function with given fields: log
func (_m *IHome) ParseInitialized(log types.Log) (*home.HomeInitialized, error) {
	ret := _m.Called(log)

	var r0 *home.HomeInitialized
	if rf, ok := ret.Get(0).(func(types.Log) *home.HomeInitialized); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeInitialized)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseNewUpdater provides a mock function with given fields: log
func (_m *IHome) ParseNewUpdater(log types.Log) (*home.HomeNewUpdater, error) {
	ret := _m.Called(log)

	var r0 *home.HomeNewUpdater
	if rf, ok := ret.Get(0).(func(types.Log) *home.HomeNewUpdater); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeNewUpdater)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseNewUpdaterManager provides a mock function with given fields: log
func (_m *IHome) ParseNewUpdaterManager(log types.Log) (*home.HomeNewUpdaterManager, error) {
	ret := _m.Called(log)

	var r0 *home.HomeNewUpdaterManager
	if rf, ok := ret.Get(0).(func(types.Log) *home.HomeNewUpdaterManager); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeNewUpdaterManager)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseOwnershipTransferred provides a mock function with given fields: log
func (_m *IHome) ParseOwnershipTransferred(log types.Log) (*home.HomeOwnershipTransferred, error) {
	ret := _m.Called(log)

	var r0 *home.HomeOwnershipTransferred
	if rf, ok := ret.Get(0).(func(types.Log) *home.HomeOwnershipTransferred); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeOwnershipTransferred)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseUpdate provides a mock function with given fields: log
func (_m *IHome) ParseUpdate(log types.Log) (*home.HomeUpdate, error) {
	ret := _m.Called(log)

	var r0 *home.HomeUpdate
	if rf, ok := ret.Get(0).(func(types.Log) *home.HomeUpdate); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeUpdate)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ParseUpdaterSlashed provides a mock function with given fields: log
func (_m *IHome) ParseUpdaterSlashed(log types.Log) (*home.HomeUpdaterSlashed, error) {
	ret := _m.Called(log)

	var r0 *home.HomeUpdaterSlashed
	if rf, ok := ret.Get(0).(func(types.Log) *home.HomeUpdaterSlashed); ok {
		r0 = rf(log)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*home.HomeUpdaterSlashed)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(types.Log) error); ok {
		r1 = rf(log)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Parser provides a mock function with given fields:
func (_m *IHome) Parser() home.Parser {
	ret := _m.Called()

	var r0 home.Parser
	if rf, ok := ret.Get(0).(func() home.Parser); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(home.Parser)
		}
	}

	return r0
}

// QueueContains provides a mock function with given fields: opts, _item
func (_m *IHome) QueueContains(opts *bind.CallOpts, _item [32]byte) (bool, error) {
	ret := _m.Called(opts, _item)

	var r0 bool
	if rf, ok := ret.Get(0).(func(*bind.CallOpts, [32]byte) bool); ok {
		r0 = rf(opts, _item)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts, [32]byte) error); ok {
		r1 = rf(opts, _item)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueueEnd provides a mock function with given fields: opts
func (_m *IHome) QueueEnd(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	var r0 [32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueueLength provides a mock function with given fields: opts
func (_m *IHome) QueueLength(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RenounceOwnership provides a mock function with given fields: opts
func (_m *IHome) RenounceOwnership(opts *bind.TransactOpts) (*types.Transaction, error) {
	ret := _m.Called(opts)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts) *types.Transaction); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Root provides a mock function with given fields: opts
func (_m *IHome) Root(opts *bind.CallOpts) ([32]byte, error) {
	ret := _m.Called(opts)

	var r0 [32]byte
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) [32]byte); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([32]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetUpdater provides a mock function with given fields: opts, _updater
func (_m *IHome) SetUpdater(opts *bind.TransactOpts, _updater common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _updater)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _updater)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, _updater)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetUpdaterManager provides a mock function with given fields: opts, _updaterManager
func (_m *IHome) SetUpdaterManager(opts *bind.TransactOpts, _updaterManager common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, _updaterManager)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, _updaterManager)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, _updaterManager)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// State provides a mock function with given fields: opts
func (_m *IHome) State(opts *bind.CallOpts) (uint8, error) {
	ret := _m.Called(opts)

	var r0 uint8
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint8); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SuggestUpdate provides a mock function with given fields: opts
func (_m *IHome) SuggestUpdate(opts *bind.CallOpts) (struct {
	CommittedRoot [32]byte
	New           [32]byte
}, error) {
	ret := _m.Called(opts)

	var r0 struct {
		CommittedRoot [32]byte
		New           [32]byte
	}
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) struct {
		CommittedRoot [32]byte
		New           [32]byte
	}); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(struct {
			CommittedRoot [32]byte
			New           [32]byte
		})
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TransferOwnership provides a mock function with given fields: opts, newOwner
func (_m *IHome) TransferOwnership(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	ret := _m.Called(opts, newOwner)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, common.Address) *types.Transaction); ok {
		r0 = rf(opts, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, common.Address) error); ok {
		r1 = rf(opts, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Tree provides a mock function with given fields: opts
func (_m *IHome) Tree(opts *bind.CallOpts) (*big.Int, error) {
	ret := _m.Called(opts)

	var r0 *big.Int
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) *big.Int); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*big.Int)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: opts, _committedRoot, _newRoot, _signature
func (_m *IHome) Update(opts *bind.TransactOpts, _committedRoot [32]byte, _newRoot [32]byte, _signature []byte) (*types.Transaction, error) {
	ret := _m.Called(opts, _committedRoot, _newRoot, _signature)

	var r0 *types.Transaction
	if rf, ok := ret.Get(0).(func(*bind.TransactOpts, [32]byte, [32]byte, []byte) *types.Transaction); ok {
		r0 = rf(opts, _committedRoot, _newRoot, _signature)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*types.Transaction)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.TransactOpts, [32]byte, [32]byte, []byte) error); ok {
		r1 = rf(opts, _committedRoot, _newRoot, _signature)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Updater provides a mock function with given fields: opts
func (_m *IHome) Updater(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdaterManager provides a mock function with given fields: opts
func (_m *IHome) UpdaterManager(opts *bind.CallOpts) (common.Address, error) {
	ret := _m.Called(opts)

	var r0 common.Address
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) common.Address); ok {
		r0 = rf(opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(common.Address)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VERSION provides a mock function with given fields: opts
func (_m *IHome) VERSION(opts *bind.CallOpts) (uint8, error) {
	ret := _m.Called(opts)

	var r0 uint8
	if rf, ok := ret.Get(0).(func(*bind.CallOpts) uint8); ok {
		r0 = rf(opts)
	} else {
		r0 = ret.Get(0).(uint8)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.CallOpts) error); ok {
		r1 = rf(opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchDispatch provides a mock function with given fields: opts, sink, messageHash, leafIndex, destinationAndNonce
func (_m *IHome) WatchDispatch(opts *bind.WatchOpts, sink chan<- *home.HomeDispatch, messageHash [][32]byte, leafIndex []*big.Int, destinationAndNonce []uint64) (event.Subscription, error) {
	ret := _m.Called(opts, sink, messageHash, leafIndex, destinationAndNonce)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *home.HomeDispatch, [][32]byte, []*big.Int, []uint64) event.Subscription); ok {
		r0 = rf(opts, sink, messageHash, leafIndex, destinationAndNonce)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *home.HomeDispatch, [][32]byte, []*big.Int, []uint64) error); ok {
		r1 = rf(opts, sink, messageHash, leafIndex, destinationAndNonce)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchDoubleUpdate provides a mock function with given fields: opts, sink
func (_m *IHome) WatchDoubleUpdate(opts *bind.WatchOpts, sink chan<- *home.HomeDoubleUpdate) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *home.HomeDoubleUpdate) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *home.HomeDoubleUpdate) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchImproperUpdate provides a mock function with given fields: opts, sink
func (_m *IHome) WatchImproperUpdate(opts *bind.WatchOpts, sink chan<- *home.HomeImproperUpdate) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *home.HomeImproperUpdate) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *home.HomeImproperUpdate) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchInitialized provides a mock function with given fields: opts, sink
func (_m *IHome) WatchInitialized(opts *bind.WatchOpts, sink chan<- *home.HomeInitialized) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *home.HomeInitialized) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *home.HomeInitialized) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchNewUpdater provides a mock function with given fields: opts, sink
func (_m *IHome) WatchNewUpdater(opts *bind.WatchOpts, sink chan<- *home.HomeNewUpdater) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *home.HomeNewUpdater) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *home.HomeNewUpdater) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchNewUpdaterManager provides a mock function with given fields: opts, sink
func (_m *IHome) WatchNewUpdaterManager(opts *bind.WatchOpts, sink chan<- *home.HomeNewUpdaterManager) (event.Subscription, error) {
	ret := _m.Called(opts, sink)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *home.HomeNewUpdaterManager) event.Subscription); ok {
		r0 = rf(opts, sink)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *home.HomeNewUpdaterManager) error); ok {
		r1 = rf(opts, sink)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchOwnershipTransferred provides a mock function with given fields: opts, sink, previousOwner, newOwner
func (_m *IHome) WatchOwnershipTransferred(opts *bind.WatchOpts, sink chan<- *home.HomeOwnershipTransferred, previousOwner []common.Address, newOwner []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, previousOwner, newOwner)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *home.HomeOwnershipTransferred, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, previousOwner, newOwner)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *home.HomeOwnershipTransferred, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, previousOwner, newOwner)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchUpdate provides a mock function with given fields: opts, sink, homeDomain, oldRoot, newRoot
func (_m *IHome) WatchUpdate(opts *bind.WatchOpts, sink chan<- *home.HomeUpdate, homeDomain []uint32, oldRoot [][32]byte, newRoot [][32]byte) (event.Subscription, error) {
	ret := _m.Called(opts, sink, homeDomain, oldRoot, newRoot)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *home.HomeUpdate, []uint32, [][32]byte, [][32]byte) event.Subscription); ok {
		r0 = rf(opts, sink, homeDomain, oldRoot, newRoot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *home.HomeUpdate, []uint32, [][32]byte, [][32]byte) error); ok {
		r1 = rf(opts, sink, homeDomain, oldRoot, newRoot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchUpdaterSlashed provides a mock function with given fields: opts, sink, updater, reporter
func (_m *IHome) WatchUpdaterSlashed(opts *bind.WatchOpts, sink chan<- *home.HomeUpdaterSlashed, updater []common.Address, reporter []common.Address) (event.Subscription, error) {
	ret := _m.Called(opts, sink, updater, reporter)

	var r0 event.Subscription
	if rf, ok := ret.Get(0).(func(*bind.WatchOpts, chan<- *home.HomeUpdaterSlashed, []common.Address, []common.Address) event.Subscription); ok {
		r0 = rf(opts, sink, updater, reporter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(event.Subscription)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(*bind.WatchOpts, chan<- *home.HomeUpdaterSlashed, []common.Address, []common.Address) error); ok {
		r1 = rf(opts, sink, updater, reporter)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
