{"solidity/TipsHarness.sol:Header":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212202327507e9fa200e4dfafb1ae934f7317191c8d1d25c13b911783337eb981692564736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212202327507e9fa200e4dfafb1ae934f7317191c8d1d25c13b911783337eb981692564736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \n/**\n * @notice exposes tips methods for testing against golang\n*/\ncontract TipsHarness {\n    using Tips for bytes;\n    using Tips for bytes29;\n\n    function tipsVersion() public pure returns (uint16) {\n        return Tips.TIPS_VERSION;\n    }\n\n    function offsetUpdater() public pure returns (uint256) {\n        return Tips.OFFSET_UPDATER;\n    }\n\n    function offsetRelayer() public pure returns (uint256) {\n        return Tips.OFFSET_RELAYER;\n    }\n\n    function offsetProver() public pure returns (uint256) {\n        return Tips.OFFSET_PROVER;\n    }\n\n    function offsetProcessor() public pure returns (uint256) {\n        return Tips.OFFSET_PROCESSOR;\n    }\n\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) public pure returns (bytes memory) {\n        return Tips.formatTips(_updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    function emptyTips() external pure returns (bytes memory) {\n        return Tips.emptyTips();\n    }\n\n    function tipsView(bytes memory _tips) external pure returns (bytes29) {\n        return Tips.tipsView(_tips);\n    }\n\n    function tipsVersion(bytes29 _tips) external pure returns (uint16) {\n        return Tips.tipsVersion(_tips);\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.updaterTip(_tips);\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.relayerTip(_tips);\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.proverTip(_tips);\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.processorTip(_tips);\n    }\n\n    function totalTips(bytes29 _tips) external pure returns (uint96) {\n        return Tips.totalTips(_tips);\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"33386:3297:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;33386:3297:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"33386:3297:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_ORIGIN":{"details":"Header memory layout [000 .. 002): version            uint16   2 bytes [002 .. 006): originDomain       uint32   4 bytes [006 .. 038): sender             bytes32 32 bytes [038 .. 042): nonce              uint32   4 bytes [042 .. 046): destinationDomain  uint32   4 bytes [046 .. 078): recipient          bytes32 32 bytes [078 .. 082): optimisticSeconds  uint32   4 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_ORIGIN\":{\"details\":\"Header memory layout [000 .. 002): version            uint16   2 bytes [002 .. 006): originDomain       uint32   4 bytes [006 .. 038): sender             bytes32 32 bytes [038 .. 042): nonce              uint32   4 bytes [042 .. 046): destinationDomain  uint32   4 bytes [046 .. 078): recipient          bytes32 32 bytes [078 .. 082): optimisticSeconds  uint32   4 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.sol\":\"Header\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.sol\":{\"keccak256\":\"0xd4a0cae21b9995a7859da5d380597c60cacdf1d04b8a0aecff3e80a25fd34537\",\"urls\":[\"bzz-raw://c09e0256932a2ad21733d0048fcb674b27e9c0b419f8008ee654d42cd4fba150\",\"dweb:/ipfs/QmT7VNaBajgaFxM6SjET1TAZ8CXxfW53ix4MwxiQSzYJiu\"]}},\"version\":1}"},"hashes":{}},"solidity/TipsHarness.sol:Message":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212205e2f40898f1b764c36add16894996362012f5d10becc1b060ee5237c3557a87864736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212205e2f40898f1b764c36add16894996362012f5d10becc1b060ee5237c3557a87864736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \n/**\n * @notice exposes tips methods for testing against golang\n*/\ncontract TipsHarness {\n    using Tips for bytes;\n    using Tips for bytes29;\n\n    function tipsVersion() public pure returns (uint16) {\n        return Tips.TIPS_VERSION;\n    }\n\n    function offsetUpdater() public pure returns (uint256) {\n        return Tips.OFFSET_UPDATER;\n    }\n\n    function offsetRelayer() public pure returns (uint256) {\n        return Tips.OFFSET_RELAYER;\n    }\n\n    function offsetProver() public pure returns (uint256) {\n        return Tips.OFFSET_PROVER;\n    }\n\n    function offsetProcessor() public pure returns (uint256) {\n        return Tips.OFFSET_PROCESSOR;\n    }\n\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) public pure returns (bytes memory) {\n        return Tips.formatTips(_updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    function emptyTips() external pure returns (bytes memory) {\n        return Tips.emptyTips();\n    }\n\n    function tipsView(bytes memory _tips) external pure returns (bytes29) {\n        return Tips.tipsView(_tips);\n    }\n\n    function tipsVersion(bytes29 _tips) external pure returns (uint16) {\n        return Tips.tipsVersion(_tips);\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.updaterTip(_tips);\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.relayerTip(_tips);\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.proverTip(_tips);\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.processorTip(_tips);\n    }\n\n    function totalTips(bytes29 _tips) external pure returns (uint96) {\n        return Tips.totalTips(_tips);\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"36685:4971:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;36685:4971:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"36685:4971:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"HEADER_OFFSET":{"details":"This value reflects the header offset in the latest message version"},"MESSAGE_VERSION":{"details":"This is only updated if the whole message structure is changed,      i.e. if a new part is added.      If already existing part is changed, the message version does not get bumped."},"TWO_BYTES":{"details":"How much bytes is used for storing the version, or a single offset value"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"HEADER_OFFSET\":{\"details\":\"This value reflects the header offset in the latest message version\"},\"MESSAGE_VERSION\":{\"details\":\"This is only updated if the whole message structure is changed,      i.e. if a new part is added.      If already existing part is changed, the message version does not get bumped.\"},\"TWO_BYTES\":{\"details\":\"How much bytes is used for storing the version, or a single offset value\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.sol\":\"Message\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.sol\":{\"keccak256\":\"0xd4a0cae21b9995a7859da5d380597c60cacdf1d04b8a0aecff3e80a25fd34537\",\"urls\":[\"bzz-raw://c09e0256932a2ad21733d0048fcb674b27e9c0b419f8008ee654d42cd4fba150\",\"dweb:/ipfs/QmT7VNaBajgaFxM6SjET1TAZ8CXxfW53ix4MwxiQSzYJiu\"]}},\"version\":1}"},"hashes":{}},"solidity/TipsHarness.sol:Tips":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122067a6e388ce93f4b49e9ace4d29195460c2a827cc70a717baddb5372b0efc265e64736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea264697066735822122067a6e388ce93f4b49e9ace4d29195460c2a827cc70a717baddb5372b0efc265e64736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \n/**\n * @notice exposes tips methods for testing against golang\n*/\ncontract TipsHarness {\n    using Tips for bytes;\n    using Tips for bytes29;\n\n    function tipsVersion() public pure returns (uint16) {\n        return Tips.TIPS_VERSION;\n    }\n\n    function offsetUpdater() public pure returns (uint256) {\n        return Tips.OFFSET_UPDATER;\n    }\n\n    function offsetRelayer() public pure returns (uint256) {\n        return Tips.OFFSET_RELAYER;\n    }\n\n    function offsetProver() public pure returns (uint256) {\n        return Tips.OFFSET_PROVER;\n    }\n\n    function offsetProcessor() public pure returns (uint256) {\n        return Tips.OFFSET_PROCESSOR;\n    }\n\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) public pure returns (bytes memory) {\n        return Tips.formatTips(_updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    function emptyTips() external pure returns (bytes memory) {\n        return Tips.emptyTips();\n    }\n\n    function tipsView(bytes memory _tips) external pure returns (bytes29) {\n        return Tips.tipsView(_tips);\n    }\n\n    function tipsVersion(bytes29 _tips) external pure returns (uint16) {\n        return Tips.tipsVersion(_tips);\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.updaterTip(_tips);\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.relayerTip(_tips);\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.proverTip(_tips);\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.processorTip(_tips);\n    }\n\n    function totalTips(bytes29 _tips) external pure returns (uint96) {\n        return Tips.totalTips(_tips);\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"41658:2999:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;41658:2999:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"41658:2999:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_UPDATER":{"details":"Tips memory layout [000 .. 002): version            uint16\t 2 bytes [002 .. 014): updaterTip         uint96\t12 bytes [014 .. 026): relayerTip         uint96\t12 bytes [026 .. 038): proverTip          uint96\t12 bytes [038 .. 050): processorTip       uint96\t12 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_UPDATER\":{\"details\":\"Tips memory layout [000 .. 002): version            uint16\\t 2 bytes [002 .. 014): updaterTip         uint96\\t12 bytes [014 .. 026): relayerTip         uint96\\t12 bytes [026 .. 038): proverTip          uint96\\t12 bytes [038 .. 050): processorTip       uint96\\t12 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.sol\":\"Tips\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.sol\":{\"keccak256\":\"0xd4a0cae21b9995a7859da5d380597c60cacdf1d04b8a0aecff3e80a25fd34537\",\"urls\":[\"bzz-raw://c09e0256932a2ad21733d0048fcb674b27e9c0b419f8008ee654d42cd4fba150\",\"dweb:/ipfs/QmT7VNaBajgaFxM6SjET1TAZ8CXxfW53ix4MwxiQSzYJiu\"]}},\"version\":1}"},"hashes":{}},"solidity/TipsHarness.sol:TipsHarness":{"code":"0x608060405234801561001057600080fd5b50610f46806100206000396000f3fe608060405234801561001057600080fd5b50600436106100e95760003560e01c8063918648051161008c578063c46647e211610066578063c46647e2146101ad578063cc6a5c9b146101c0578063d024f867146101d3578063ec000108146101e657600080fd5b8063918648051461018057806398de855414610193578063aa02b2b21461019a57600080fd5b806360fb5709116100c857806360fb57091461013b5780637137088914610151578063725bd463146101585780638ff916f81461016d57600080fd5b806232b444146100ee57806301fab8df146101045780631c9caa041461010b575b600080fd5b600e5b6040519081526020015b60405180910390f35b60266100f1565b61011e610119366004610c36565b61020e565b6040516bffffffffffffffffffffffff90911681526020016100fb565b60015b60405161ffff90911681526020016100fb565b60026100f1565b61016061021f565b6040516100fb9190610cc7565b61011e61017b366004610c36565b610283565b61011e61018e366004610c36565b61028e565b601a6100f1565b61011e6101a8366004610c36565b610299565b61013e6101bb366004610c36565b6102a4565b61011e6101ce366004610c36565b6102af565b6101606101e1366004610cfb565b6102ba565b6101f96101f4366004610d7e565b61034c565b60405162ffffff1990911681526020016100fb565b600061021982610357565b92915050565b606061027e604080517e010000000000000000000000000000000000000000000000000000000000006020820152600060228201819052602e8201819052603a8201819052604682015281518082036032018152605290910190915290565b905090565b600061021982610390565b6000610219826103b1565b600061021982610408565b600061021982610429565b60006102198261044a565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffffffffffffffffffff000000000000000000000000000000000000000060a087811b8216602284015286811b8216602e84015285811b8216603a84015284901b1660468201528151808203603201815260529091019091526060905b95945050505050565b60006102198261046b565b60008161036d60025b62ffffff19831690610478565b5061038162ffffff1984166026600c61059c565b63ffffffff1691505b50919050565b60008161039d6002610360565b5061038162ffffff1984166002600c61059c565b6000816103be6002610360565b506103c883610357565b6103d18461044a565b6103da85610408565b6103e386610390565b6103ed9190610e7c565b6103f79190610e7c565b6104019190610e7c565b9392505050565b6000816104156002610360565b5061038162ffffff198416600e600c61059c565b6000816104366002610360565b5061040162ffffff1984166000600261059c565b6000816104576002610360565b5061038162ffffff198416601a600c61059c565b60006102198260026105cc565b600061048483836105e7565b6105955760006104a36104978560d81c90565b64ffffffffff1661060a565b91505060006104b88464ffffffffff1661060a565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161058c9190610cc7565b60405180910390fd5b5090919050565b60006105a9826020610eac565b6105b4906008610ecf565b60ff166105c28585856106f4565b901c949350505050565b81516000906020840161034364ffffffffff851682846108e6565b60008164ffffffffff166105fb8460d81c90565b64ffffffffff16149392505050565b600080601f5b600f8160ff16111561067d576000610629826008610ecf565b60ff1685901c905061063a8161092d565b61ffff16841793508160ff1660101461065557601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610610565b50600f5b60ff8160ff1610156106ee57600061069a826008610ecf565b60ff1685901c90506106ab8161092d565b61ffff16831792508160ff166000146106c657601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610681565b50915091565b60008160ff1660000361070957506000610401565b6107218460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1661073c60ff841685610ef8565b11156107ce5761079b61075d8560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff166107838660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff1661095f565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161058c9190610cc7565b60208260ff161115610862576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e203332206279746573000000000000606482015260840161058c565b6008820260006108808660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b6000806108f38385610ef8565b9050604051811115610903575060005b806000036109185762ffffff19915050610401565b5050606092831b9190911790911b1760181b90565b600061093f60048360ff16901c610aef565b60ff1661ffff919091161760081b61095682610aef565b60ff1617919050565b6060600061096c8661060a565b915050600061097a8661060a565b91505060006109888661060a565b91505060006109968661060a565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b600060f08083179060ff82169003610b0a5750603092915050565b8060ff1660f103610b1e5750603192915050565b8060ff1660f203610b325750603292915050565b8060ff1660f303610b465750603392915050565b8060ff1660f403610b5a5750603492915050565b8060ff1660f503610b6e5750603592915050565b8060ff1660f603610b825750603692915050565b8060ff1660f703610b965750603792915050565b8060ff1660f803610baa5750603892915050565b8060ff1660f903610bbe5750603992915050565b8060ff1660fa03610bd25750606192915050565b8060ff1660fb03610be65750606292915050565b8060ff1660fc03610bfa5750606392915050565b8060ff1660fd03610c0e5750606492915050565b8060ff1660fe03610c225750606592915050565b8060ff1660ff0361038a5750606692915050565b600060208284031215610c4857600080fd5b813562ffffff198116811461040157600080fd5b6000815180845260005b81811015610c8257602081850181015186830182015201610c66565b81811115610c94576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006104016020830184610c5c565b80356bffffffffffffffffffffffff81168114610cf657600080fd5b919050565b60008060008060808587031215610d1157600080fd5b610d1a85610cda565b9350610d2860208601610cda565b9250610d3660408601610cda565b9150610d4460608601610cda565b905092959194509250565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610d9057600080fd5b813567ffffffffffffffff80821115610da857600080fd5b818401915084601f830112610dbc57600080fd5b813581811115610dce57610dce610d4f565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610e1457610e14610d4f565b81604052828152876020848701011115610e2d57600080fd5b826020860160208301376000928101602001929092525095945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006bffffffffffffffffffffffff808316818516808303821115610ea357610ea3610e4d565b01949350505050565b600060ff821660ff841680821015610ec657610ec6610e4d565b90039392505050565b600060ff821660ff84168160ff0481118215151615610ef057610ef0610e4d565b029392505050565b60008219821115610f0b57610f0b610e4d565b50019056fea2646970667358221220dc439a974ef897208309713b2a571822aee94a27601b541a5fc9766f69ebffd264736f6c634300080d0033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100e95760003560e01c8063918648051161008c578063c46647e211610066578063c46647e2146101ad578063cc6a5c9b146101c0578063d024f867146101d3578063ec000108146101e657600080fd5b8063918648051461018057806398de855414610193578063aa02b2b21461019a57600080fd5b806360fb5709116100c857806360fb57091461013b5780637137088914610151578063725bd463146101585780638ff916f81461016d57600080fd5b806232b444146100ee57806301fab8df146101045780631c9caa041461010b575b600080fd5b600e5b6040519081526020015b60405180910390f35b60266100f1565b61011e610119366004610c36565b61020e565b6040516bffffffffffffffffffffffff90911681526020016100fb565b60015b60405161ffff90911681526020016100fb565b60026100f1565b61016061021f565b6040516100fb9190610cc7565b61011e61017b366004610c36565b610283565b61011e61018e366004610c36565b61028e565b601a6100f1565b61011e6101a8366004610c36565b610299565b61013e6101bb366004610c36565b6102a4565b61011e6101ce366004610c36565b6102af565b6101606101e1366004610cfb565b6102ba565b6101f96101f4366004610d7e565b61034c565b60405162ffffff1990911681526020016100fb565b600061021982610357565b92915050565b606061027e604080517e010000000000000000000000000000000000000000000000000000000000006020820152600060228201819052602e8201819052603a8201819052604682015281518082036032018152605290910190915290565b905090565b600061021982610390565b6000610219826103b1565b600061021982610408565b600061021982610429565b60006102198261044a565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffffffffffffffffffff000000000000000000000000000000000000000060a087811b8216602284015286811b8216602e84015285811b8216603a84015284901b1660468201528151808203603201815260529091019091526060905b95945050505050565b60006102198261046b565b60008161036d60025b62ffffff19831690610478565b5061038162ffffff1984166026600c61059c565b63ffffffff1691505b50919050565b60008161039d6002610360565b5061038162ffffff1984166002600c61059c565b6000816103be6002610360565b506103c883610357565b6103d18461044a565b6103da85610408565b6103e386610390565b6103ed9190610e7c565b6103f79190610e7c565b6104019190610e7c565b9392505050565b6000816104156002610360565b5061038162ffffff198416600e600c61059c565b6000816104366002610360565b5061040162ffffff1984166000600261059c565b6000816104576002610360565b5061038162ffffff198416601a600c61059c565b60006102198260026105cc565b600061048483836105e7565b6105955760006104a36104978560d81c90565b64ffffffffff1661060a565b91505060006104b88464ffffffffff1661060a565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161058c9190610cc7565b60405180910390fd5b5090919050565b60006105a9826020610eac565b6105b4906008610ecf565b60ff166105c28585856106f4565b901c949350505050565b81516000906020840161034364ffffffffff851682846108e6565b60008164ffffffffff166105fb8460d81c90565b64ffffffffff16149392505050565b600080601f5b600f8160ff16111561067d576000610629826008610ecf565b60ff1685901c905061063a8161092d565b61ffff16841793508160ff1660101461065557601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610610565b50600f5b60ff8160ff1610156106ee57600061069a826008610ecf565b60ff1685901c90506106ab8161092d565b61ffff16831792508160ff166000146106c657601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610681565b50915091565b60008160ff1660000361070957506000610401565b6107218460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1661073c60ff841685610ef8565b11156107ce5761079b61075d8560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff166107838660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff1661095f565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161058c9190610cc7565b60208260ff161115610862576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e203332206279746573000000000000606482015260840161058c565b6008820260006108808660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b6000806108f38385610ef8565b9050604051811115610903575060005b806000036109185762ffffff19915050610401565b5050606092831b9190911790911b1760181b90565b600061093f60048360ff16901c610aef565b60ff1661ffff919091161760081b61095682610aef565b60ff1617919050565b6060600061096c8661060a565b915050600061097a8661060a565b91505060006109888661060a565b91505060006109968661060a565b604080517f54797065644d656d566965772f696e646578202d204f76657272616e2074686560208201527f20766965772e20536c6963652069732061742030780000000000000000000000818301527fffffffffffff000000000000000000000000000000000000000000000000000060d098891b811660558301527f2077697468206c656e6774682030780000000000000000000000000000000000605b830181905297891b8116606a8301527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060708301527f7800000000000000000000000000000000000000000000000000000000000000609083015295881b861660918201526097810196909652951b90921660a684015250507f2e0000000000000000000000000000000000000000000000000000000000000060ac8201528151808203608d01815260ad90910190915295945050505050565b600060f08083179060ff82169003610b0a5750603092915050565b8060ff1660f103610b1e5750603192915050565b8060ff1660f203610b325750603292915050565b8060ff1660f303610b465750603392915050565b8060ff1660f403610b5a5750603492915050565b8060ff1660f503610b6e5750603592915050565b8060ff1660f603610b825750603692915050565b8060ff1660f703610b965750603792915050565b8060ff1660f803610baa5750603892915050565b8060ff1660f903610bbe5750603992915050565b8060ff1660fa03610bd25750606192915050565b8060ff1660fb03610be65750606292915050565b8060ff1660fc03610bfa5750606392915050565b8060ff1660fd03610c0e5750606492915050565b8060ff1660fe03610c225750606592915050565b8060ff1660ff0361038a5750606692915050565b600060208284031215610c4857600080fd5b813562ffffff198116811461040157600080fd5b6000815180845260005b81811015610c8257602081850181015186830182015201610c66565b81811115610c94576000602083870101525b50601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006104016020830184610c5c565b80356bffffffffffffffffffffffff81168114610cf657600080fd5b919050565b60008060008060808587031215610d1157600080fd5b610d1a85610cda565b9350610d2860208601610cda565b9250610d3660408601610cda565b9150610d4460608601610cda565b905092959194509250565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600060208284031215610d9057600080fd5b813567ffffffffffffffff80821115610da857600080fd5b818401915084601f830112610dbc57600080fd5b813581811115610dce57610dce610d4f565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908382118183101715610e1457610e14610d4f565b81604052828152876020848701011115610e2d57600080fd5b826020860160208301376000928101602001929092525095945050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006bffffffffffffffffffffffff808316818516808303821115610ea357610ea3610e4d565b01949350505050565b600060ff821660ff841680821015610ec657610ec6610e4d565b90039392505050565b600060ff821660ff84168160ff0481118215151615610ef057610ef0610e4d565b029392505050565b60008219821115610f0b57610f0b610e4d565b50019056fea2646970667358221220dc439a974ef897208309713b2a571822aee94a27601b541a5fc9766f69ebffd264736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \n/**\n * @notice exposes tips methods for testing against golang\n*/\ncontract TipsHarness {\n    using Tips for bytes;\n    using Tips for bytes29;\n\n    function tipsVersion() public pure returns (uint16) {\n        return Tips.TIPS_VERSION;\n    }\n\n    function offsetUpdater() public pure returns (uint256) {\n        return Tips.OFFSET_UPDATER;\n    }\n\n    function offsetRelayer() public pure returns (uint256) {\n        return Tips.OFFSET_RELAYER;\n    }\n\n    function offsetProver() public pure returns (uint256) {\n        return Tips.OFFSET_PROVER;\n    }\n\n    function offsetProcessor() public pure returns (uint256) {\n        return Tips.OFFSET_PROCESSOR;\n    }\n\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) public pure returns (bytes memory) {\n        return Tips.formatTips(_updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    function emptyTips() external pure returns (bytes memory) {\n        return Tips.emptyTips();\n    }\n\n    function tipsView(bytes memory _tips) external pure returns (bytes29) {\n        return Tips.tipsView(_tips);\n    }\n\n    function tipsVersion(bytes29 _tips) external pure returns (uint16) {\n        return Tips.tipsVersion(_tips);\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.updaterTip(_tips);\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.relayerTip(_tips);\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.proverTip(_tips);\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.processorTip(_tips);\n    }\n\n    function totalTips(bytes29 _tips) external pure returns (uint96) {\n        return Tips.totalTips(_tips);\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"44729:1966:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"44729:1966:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;45014:98;42217:2;45014:98;;;160:25:1;;;148:2;133:18;45014:98:0;;;;;;;;45220:102;42320:2;45220:102;;46461:116;;;;;;:::i;:::-;;:::i;:::-;;;708:26:1;696:39;;;678:58;;666:2;651:18;46461:116:0;534:208:1;44811:93:0;41788:1;44811:93;;;921:6:1;909:19;;;891:38;;879:2;864:18;44811:93:0;747:188:1;44910:98:0;42167:1;44910:98;;45600;;;:::i;:::-;;;;;;;:::i;45985:112::-;;;;;;:::i;:::-;;:::i;46583:110::-;;;;;;:::i;:::-;;:::i;45118:96::-;42267:2;45118:96;;46144:112;;;;;;:::i;:::-;;:::i;45824:114::-;;;;;;:::i;:::-;;:::i;46302:110::-;;;;;;:::i;:::-;;:::i;45328:266::-;;;;;;:::i;:::-;;:::i;45704:114::-;;;;;;:::i;:::-;;:::i;:::-;;;-1:-1:-1;;3625:79:1;;;3607:98;;3595:2;3580:18;45704:114:0;3461:250:1;46461:116:0;46521:6;46546:24;46564:5;46546:17;:24::i;:::-;46539:31;46461:116;-1:-1:-1;;46461:116:0:o;45600:98::-;45644:12;45675:16;42925:83;;;4590:16:1;42925:83:0;;;4574:102:1;43198:1:0;4777:11:1;;;4770:46;;;4832:12;;;4825:47;;;4888:12;;;4881:47;;;4944:12;;;4937:47;42925:83:0;;;;;;;;;5000:12:1;;;;42925:83:0;;;45600:98;;45675:16;45668:23;;45600:98;:::o;45985:112::-;46043:6;46068:22;46084:5;46068:15;:22::i;46583:110::-;46640:6;46665:21;46680:5;46665:14;:21::i;46144:112::-;46202:6;46227:22;46243:5;46227:15;:22::i;45824:114::-;45883:6;45908:23;45925:5;45908:16;:23::i;46302:110::-;46359:6;46384:21;46399:5;46384:14;:21::i;45328:266::-;42925:83;;;4590:16:1;42925:83:0;;;4574:102:1;4695:66;4798:3;4794:16;;;4790:25;;4777:11;;;4770:46;4850:16;;;4846:25;;4832:12;;;4825:47;4906:16;;;4902:25;;4888:12;;;4881:47;4962:16;;;4958:25;4944:12;;;4937:47;42925:83:0;;;;;;;;;5000:12:1;;;;42925:83:0;;;45488:12;;45519:68;45512:75;45328:266;-1:-1:-1;;;;;45328:266:0:o;45704:114::-;45765:7;45791:20;45805:5;45791:13;:20::i;44313:153::-;44389:6;44373:5;42372:35;37387:10;37380:18;-1:-1:-1;;42372:16:0;;;;:35::i;:::-;-1:-1:-1;44421:37:0::1;-1:-1:-1::0;;44421:15:0;::::1;42320:2;44455;44421:15;:37::i;:::-;44407:52;;;;42417:1;44313:153:::0;;;;:::o;43726:149::-;43800:6;43784:5;42372:35;37387:10;37380:18;;42372:35;-1:-1:-1;43832:35:0::1;-1:-1:-1::0;;43832:15:0;::::1;42167:1;43864:2;43832:15;:35::i;44472:183::-:0;44545:6;44529:5;42372:35;37387:10;37380:18;;42372:35;;44629:19:::1;44642:5;44629:12;:19::i;:::-;44610:16;44620:5;44610:9;:16::i;:::-;44590:17;44601:5;44590:10;:17::i;:::-;44570;44581:5;44570:10;:17::i;:::-;:37;;;;:::i;:::-;:56;;;;:::i;:::-;:78;;;;:::i;:::-;44563:85:::0;44472:183;-1:-1:-1;;;44472:183:0:o;43922:149::-;43996:6;43980:5;42372:35;37387:10;37380:18;;42372:35;-1:-1:-1;44028:35:0::1;-1:-1:-1::0;;44028:15:0;::::1;42217:2;44060;44028:15;:35::i;43543:136::-:0;43618:6;43602:5;42372:35;37387:10;37380:18;;42372:35;-1:-1:-1;43650:21:0::1;-1:-1:-1::0;;43650:15:0;::::1;43666:1;43669;43650:15;:21::i;44117:147::-:0;44190:6;44174:5;42372:35;37387:10;37380:18;;42372:35;-1:-1:-1;44222:34:0::1;-1:-1:-1::0;;44222:15:0;::::1;42267:2;44253;44222:15;:34::i;43365:122::-:0;43426:7;43452:28;:5;37387:10;43452:9;:28::i;10073:578::-;10151:7;10175:26;10182:7;10191:9;10175:6;:26::i;:::-;10170:451;;10220:9;10233:35;10251:15;10258:7;14417:3;14413:17;;14206:268;10251:15;10243:24;;10233:9;:35::i;:::-;10217:51;;;10285:9;10298:29;10316:9;10308:18;;10298:9;:29::i;:::-;10385:186;;5390:31:1;10385:186:0;;;5378:44:1;5441:66;5545:3;5541:16;;;5537:25;;5523:12;;;5516:47;5593:15;5579:12;;;5572:37;5643:16;;;5639:25;5625:12;;;5618:47;10282:45:0;;-1:-1:-1;10341:17:0;;-1:-1:-1;5681:12:1;;10385:186:0;;;;;;;;;;;;10341:244;;10606:3;10599:11;;;;;;;;;;;:::i;:::-;;;;;;;;10170:451;-1:-1:-1;10637:7:0;;10073:578;-1:-1:-1;10073:578:0:o;21121:221::-;21240:14;21318:11;21323:6;21318:2;:11;:::i;:::-;21317:17;;21333:1;21317:17;:::i;:::-;21273:62;;21281:30;21287:7;21296:6;21304;21281:5;:30::i;:::-;21273:62;;;21121:221;-1:-1:-1;;;;21121:221:0:o;13655:359::-;13759:10;;13725:7;;13906:4;13897:14;;13981:26;;;;13897:14;13759:10;13981:5;:26::i;9643:132::-;9717:4;9759:9;9740:28;;:15;9747:7;14417:3;14413:17;;14206:268;9740:15;:28;;;;9643:132;-1:-1:-1;;;9643:132:0:o;5031:667::-;5085:13;;5141:2;5126:258;5149:2;5145:1;:6;;;5126:258;;;5169:11;5196:5;:1;5200;5196:5;:::i;:::-;5189:13;;:2;:13;;5169:34;;5226:14;5234:5;5226:7;:14::i;:::-;5217:23;;;;;;5258:1;:7;;5263:2;5258:7;5254:58;;5295:2;5285:12;;;;;5254:58;-1:-1:-1;5353:6:0;;5126:258;;;-1:-1:-1;5447:2:0;5432:260;5455:3;5451:1;:7;;;5432:260;;;5476:11;5503:5;:1;5507;5503:5;:::i;:::-;5496:13;;:2;:13;;5476:34;;5534:14;5542:5;5534:7;:14::i;:::-;5524:24;;;;;;5566:1;:6;;5571:1;5566:6;5562:58;;5603:2;5592:13;;;;;5562:58;-1:-1:-1;5661:6:0;;5432:260;;;;5031:667;;;:::o;20004:771::-;20119:14;20149:6;:11;;20159:1;20149:11;20145:59;;-1:-1:-1;20191:1:0;20176:17;;20145:59;20235:12;20239:7;16492:2;16488:16;2670:26;16484:28;;16246:282;20235:12;20217:30;;:15;;;;:6;:15;:::i;:::-;:30;20213:137;;;20270:68;20286:12;20290:7;15386:3;15382:17;2670:26;15378:29;;15059:364;20286:12;20270:68;;20300:12;20304:7;16492:2;16488:16;2670:26;16484:28;;16246:282;20300:12;20270:68;;20314:6;20330;20322:15;;20270;:68::i;:::-;20263:76;;;;;;;;;;;:::i;20213:137::-;20377:2;20367:6;:12;;;;20359:83;;;;;;;6706:2:1;20359:83:0;;;6688:21:1;6745:2;6725:18;;;6718:30;6784:34;6764:18;;;6757:62;6855:28;6835:18;;;6828:56;6901:19;;20359:83:0;6504:422:1;20359:83:0;20523:1;20514:10;;20453:15;20559:12;20563:7;15386:3;15382:17;2670:26;15378:29;;15059:364;20559:12;20544:27;;;-1:-1:-1;20581:13:0;7488:66;7458:12;;;7437:131;20733:17;;;;20727:24;20723:36;;;-1:-1:-1;;;;;20004:771:0:o;12796:462::-;12907:15;;12949:11;12956:4;12949;:11;:::i;:::-;12934:26;;13075:4;13069:11;13063:4;13060:21;13057:66;;;-1:-1:-1;13108:1:0;13057:66;13146:4;13154:1;13146:9;13142:51;;-1:-1:-1;;13171:11:0;;;;;13142:51;-1:-1:-1;;12065:2:0;12061:27;;;12135:17;;;;12127:26;;;12199:17;12195:2;12191:26;;12796:462::o;4508:199::-;4558:14;4595:18;4611:1;4605:2;:7;;;;4595:9;:18::i;:::-;4584:29;;4637:13;;;;;;4649:1;4637:13;4671;4681:2;4671:9;:13::i;:::-;4660:24;;;;4508:199;-1:-1:-1;4508:199:0:o;18761:741::-;18907:17;18939:9;18952:15;18962:4;18952:9;:15::i;:::-;18936:31;;;18980:9;18993:15;19003:4;18993:9;:15::i;:::-;18977:31;;;19021:9;19034:17;19044:6;19034:9;:17::i;:::-;19018:33;;;19064:9;19077:17;19087:6;19077:9;:17::i;:::-;19130:355;;;7772:34:1;19130:355:0;;;7760:47:1;7837:23;7823:12;;;7816:45;7880:66;7984:3;7980:16;;;7976:25;;7962:12;;;7955:47;8021:17;8054:12;;;8047:24;;;8105:16;;;8101:25;;8087:12;;;8080:47;8157:34;8143:12;;;8136:56;8223:3;8208:13;;;8201:26;8262:16;;;8258:25;;8243:13;;;8236:48;8300:13;;;8293:25;;;;8353:16;;8349:25;;;8334:13;;;8327:48;-1:-1:-1;;7008:3:1;8421:13;;;6996:16;19130:355:0;;;;;;;;;7028:11:1;;;;19130:355:0;;;;;-1:-1:-1;;;;;18761:741:0:o;2943:1393::-;2995:10;3161:4;3156:9;;;;3207:15;;;;;3203:57;;-1:-1:-1;3245:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3203:57::-;3278:7;:15;;3289:4;3278:15;3274:57;;-1:-1:-1;3316:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3274:57::-;3349:7;:15;;3360:4;3349:15;3345:57;;-1:-1:-1;3387:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3345:57::-;3420:7;:15;;3431:4;3420:15;3416:57;;-1:-1:-1;3458:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3416:57::-;3491:7;:15;;3502:4;3491:15;3487:57;;-1:-1:-1;3529:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3487:57::-;3562:7;:15;;3573:4;3562:15;3558:57;;-1:-1:-1;3600:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3558:57::-;3633:7;:15;;3644:4;3633:15;3629:57;;-1:-1:-1;3671:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3629:57::-;3704:7;:15;;3715:4;3704:15;3700:57;;-1:-1:-1;3742:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3700:57::-;3775:7;:15;;3786:4;3775:15;3771:57;;-1:-1:-1;3813:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3771:57::-;3846:7;:15;;3857:4;3846:15;3842:57;;-1:-1:-1;3884:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3842:57::-;3917:7;:15;;3928:4;3917:15;3913:57;;-1:-1:-1;3955:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3913:57::-;3988:7;:15;;3999:4;3988:15;3984:57;;-1:-1:-1;4026:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3984:57::-;4059:7;:15;;4070:4;4059:15;4055:57;;-1:-1:-1;4097:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4055:57::-;4130:7;:15;;4141:4;4130:15;4126:57;;-1:-1:-1;4168:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4126:57::-;4201:7;:15;;4212:4;4201:15;4197:57;;-1:-1:-1;4239:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4197:57::-;4272:7;:15;;4283:4;4272:15;4268:57;;-1:-1:-1;4310:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;196:333:1:-;255:6;308:2;296:9;287:7;283:23;279:32;276:52;;;324:1;321;314:12;276:52;363:9;350:23;-1:-1:-1;;406:5:1;402:78;395:5;392:89;382:117;;495:1;492;485:12;940:530;981:3;1019:5;1013:12;1046:6;1041:3;1034:19;1071:1;1081:162;1095:6;1092:1;1089:13;1081:162;;;1157:4;1213:13;;;1209:22;;1203:29;1185:11;;;1181:20;;1174:59;1110:12;1081:162;;;1261:6;1258:1;1255:13;1252:87;;;1327:1;1320:4;1311:6;1306:3;1302:16;1298:27;1291:38;1252:87;-1:-1:-1;1384:2:1;1372:15;1389:66;1368:88;1359:98;;;;1459:4;1355:109;;940:530;-1:-1:-1;;940:530:1:o;1475:217::-;1622:2;1611:9;1604:21;1585:4;1642:44;1682:2;1671:9;1667:18;1659:6;1642:44;:::i;1697:179::-;1764:20;;1824:26;1813:38;;1803:49;;1793:77;;1866:1;1863;1856:12;1793:77;1697:179;;;:::o;1881:401::-;1963:6;1971;1979;1987;2040:3;2028:9;2019:7;2015:23;2011:33;2008:53;;;2057:1;2054;2047:12;2008:53;2080:28;2098:9;2080:28;:::i;:::-;2070:38;;2127:37;2160:2;2149:9;2145:18;2127:37;:::i;:::-;2117:47;;2183:37;2216:2;2205:9;2201:18;2183:37;:::i;:::-;2173:47;;2239:37;2272:2;2261:9;2257:18;2239:37;:::i;:::-;2229:47;;1881:401;;;;;;;:::o;2287:184::-;2339:77;2336:1;2329:88;2436:4;2433:1;2426:15;2460:4;2457:1;2450:15;2476:980;2544:6;2597:2;2585:9;2576:7;2572:23;2568:32;2565:52;;;2613:1;2610;2603:12;2565:52;2653:9;2640:23;2682:18;2723:2;2715:6;2712:14;2709:34;;;2739:1;2736;2729:12;2709:34;2777:6;2766:9;2762:22;2752:32;;2822:7;2815:4;2811:2;2807:13;2803:27;2793:55;;2844:1;2841;2834:12;2793:55;2880:2;2867:16;2902:2;2898;2895:10;2892:36;;;2908:18;;:::i;:::-;3042:2;3036:9;3104:4;3096:13;;2947:66;3092:22;;;3116:2;3088:31;3084:40;3072:53;;;3140:18;;;3160:22;;;3137:46;3134:72;;;3186:18;;:::i;:::-;3226:10;3222:2;3215:22;3261:2;3253:6;3246:18;3301:7;3296:2;3291;3287;3283:11;3279:20;3276:33;3273:53;;;3322:1;3319;3312:12;3273:53;3378:2;3373;3369;3365:11;3360:2;3352:6;3348:15;3335:46;3423:1;3401:15;;;3418:2;3397:24;3390:35;;;;-1:-1:-1;3405:6:1;2476:980;-1:-1:-1;;;;;2476:980:1:o;3905:184::-;3957:77;3954:1;3947:88;4054:4;4051:1;4044:15;4078:4;4075:1;4068:15;4094:244;4133:3;4161:26;4214:2;4211:1;4207:10;4244:2;4241:1;4237:10;4275:3;4271:2;4267:12;4262:3;4259:21;4256:47;;;4283:18;;:::i;:::-;4319:13;;4094:244;-1:-1:-1;;;;4094:244:1:o;5928:195::-;5966:4;6003;6000:1;5996:12;6035:4;6032:1;6028:12;6060:3;6055;6052:12;6049:38;;;6067:18;;:::i;:::-;6104:13;;;5928:195;-1:-1:-1;;;5928:195:1:o;6128:238::-;6166:7;6206:4;6203:1;6199:12;6238:4;6235:1;6231:12;6298:3;6292:4;6288:14;6283:3;6280:23;6273:3;6266:11;6259:19;6255:49;6252:75;;;6307:18;;:::i;:::-;6347:13;;6128:238;-1:-1:-1;;;6128:238:1:o;6371:128::-;6411:3;6442:1;6438:6;6435:1;6432:13;6429:39;;;6448:18;;:::i;:::-;-1:-1:-1;6484:9:1;;6371:128::o","abiDefinition":[{"inputs":[],"name":"emptyTips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint96","name":"_updaterTip","type":"uint96"},{"internalType":"uint96","name":"_relayerTip","type":"uint96"},{"internalType":"uint96","name":"_proverTip","type":"uint96"},{"internalType":"uint96","name":"_processorTip","type":"uint96"}],"name":"formatTips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetProcessor","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetProver","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetRelayer","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"offsetUpdater","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes29","name":"_tips","type":"bytes29"}],"name":"processorTip","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes29","name":"_tips","type":"bytes29"}],"name":"proverTip","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes29","name":"_tips","type":"bytes29"}],"name":"relayerTip","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"tipsVersion","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes29","name":"_tips","type":"bytes29"}],"name":"tipsVersion","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_tips","type":"bytes"}],"name":"tipsView","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes29","name":"_tips","type":"bytes29"}],"name":"totalTips","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes29","name":"_tips","type":"bytes29"}],"name":"updaterTip","outputs":[{"internalType":"uint96","name":"","type":"uint96"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{"processorTip(bytes29)":{"notice":"Returns processorTip field"},"proverTip(bytes29)":{"notice":"Returns proverTip field"},"relayerTip(bytes29)":{"notice":"Returns relayerTip field"},"updaterTip(bytes29)":{"notice":"Returns updaterTip field"}},"notice":"exposes tips methods for testing against golang","version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"emptyTips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint96\",\"name\":\"_updaterTip\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_relayerTip\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_proverTip\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_processorTip\",\"type\":\"uint96\"}],\"name\":\"formatTips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetProcessor\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetProver\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetRelayer\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offsetUpdater\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"_tips\",\"type\":\"bytes29\"}],\"name\":\"processorTip\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"_tips\",\"type\":\"bytes29\"}],\"name\":\"proverTip\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"_tips\",\"type\":\"bytes29\"}],\"name\":\"relayerTip\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tipsVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"_tips\",\"type\":\"bytes29\"}],\"name\":\"tipsVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_tips\",\"type\":\"bytes\"}],\"name\":\"tipsView\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"_tips\",\"type\":\"bytes29\"}],\"name\":\"totalTips\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes29\",\"name\":\"_tips\",\"type\":\"bytes29\"}],\"name\":\"updaterTip\",\"outputs\":[{\"internalType\":\"uint96\",\"name\":\"\",\"type\":\"uint96\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"processorTip(bytes29)\":{\"notice\":\"Returns processorTip field\"},\"proverTip(bytes29)\":{\"notice\":\"Returns proverTip field\"},\"relayerTip(bytes29)\":{\"notice\":\"Returns relayerTip field\"},\"updaterTip(bytes29)\":{\"notice\":\"Returns updaterTip field\"}},\"notice\":\"exposes tips methods for testing against golang\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.sol\":\"TipsHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.sol\":{\"keccak256\":\"0xd4a0cae21b9995a7859da5d380597c60cacdf1d04b8a0aecff3e80a25fd34537\",\"urls\":[\"bzz-raw://c09e0256932a2ad21733d0048fcb674b27e9c0b419f8008ee654d42cd4fba150\",\"dweb:/ipfs/QmT7VNaBajgaFxM6SjET1TAZ8CXxfW53ix4MwxiQSzYJiu\"]}},\"version\":1}"},"hashes":{"emptyTips()":"725bd463","formatTips(uint96,uint96,uint96,uint96)":"d024f867","offsetProcessor()":"01fab8df","offsetProver()":"98de8554","offsetRelayer()":"0032b444","offsetUpdater()":"71370889","processorTip(bytes29)":"1c9caa04","proverTip(bytes29)":"cc6a5c9b","relayerTip(bytes29)":"aa02b2b2","tipsVersion()":"60fb5709","tipsVersion(bytes29)":"c46647e2","tipsView(bytes)":"ec000108","totalTips(bytes29)":"91864805","updaterTip(bytes29)":"8ff916f8"}},"solidity/TipsHarness.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b3875413b9a97499e1e4bda671ff1fcd9829ffb8c489c1114da46f62547b979964736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b3875413b9a97499e1e4bda671ff1fcd9829ffb8c489c1114da46f62547b979964736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \n/**\n * @notice exposes tips methods for testing against golang\n*/\ncontract TipsHarness {\n    using Tips for bytes;\n    using Tips for bytes29;\n\n    function tipsVersion() public pure returns (uint16) {\n        return Tips.TIPS_VERSION;\n    }\n\n    function offsetUpdater() public pure returns (uint256) {\n        return Tips.OFFSET_UPDATER;\n    }\n\n    function offsetRelayer() public pure returns (uint256) {\n        return Tips.OFFSET_RELAYER;\n    }\n\n    function offsetProver() public pure returns (uint256) {\n        return Tips.OFFSET_PROVER;\n    }\n\n    function offsetProcessor() public pure returns (uint256) {\n        return Tips.OFFSET_PROCESSOR;\n    }\n\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) public pure returns (bytes memory) {\n        return Tips.formatTips(_updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    function emptyTips() external pure returns (bytes memory) {\n        return Tips.emptyTips();\n    }\n\n    function tipsView(bytes memory _tips) external pure returns (bytes29) {\n        return Tips.tipsView(_tips);\n    }\n\n    function tipsVersion(bytes29 _tips) external pure returns (uint16) {\n        return Tips.tipsVersion(_tips);\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.updaterTip(_tips);\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.relayerTip(_tips);\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.proverTip(_tips);\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.processorTip(_tips);\n    }\n\n    function totalTips(bytes29 _tips) external pure returns (uint96) {\n        return Tips.totalTips(_tips);\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"32274:1110:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;32274:1110:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"32274:1110:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.sol\":{\"keccak256\":\"0xd4a0cae21b9995a7859da5d380597c60cacdf1d04b8a0aecff3e80a25fd34537\",\"urls\":[\"bzz-raw://c09e0256932a2ad21733d0048fcb674b27e9c0b419f8008ee654d42cd4fba150\",\"dweb:/ipfs/QmT7VNaBajgaFxM6SjET1TAZ8CXxfW53ix4MwxiQSzYJiu\"]}},\"version\":1}"},"hashes":{}},"solidity/TipsHarness.sol:TypedMemView":{"code":"0x60c9610038600b82828239805160001a607314602b57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f26be3fc146038575b600080fd5b605e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000909116815260200160405180910390f3fea2646970667358221220bcaa3e8cf6368e7af3db7057e2dfc446f33142e320eee5392d5e6bbca67c34f664736f6c634300080d0033","runtime-code":"0x730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f26be3fc146038575b600080fd5b605e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000909116815260200160405180910390f3fea2646970667358221220bcaa3e8cf6368e7af3db7057e2dfc446f33142e320eee5392d5e6bbca67c34f664736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \n/**\n * @notice exposes tips methods for testing against golang\n*/\ncontract TipsHarness {\n    using Tips for bytes;\n    using Tips for bytes29;\n\n    function tipsVersion() public pure returns (uint16) {\n        return Tips.TIPS_VERSION;\n    }\n\n    function offsetUpdater() public pure returns (uint256) {\n        return Tips.OFFSET_UPDATER;\n    }\n\n    function offsetRelayer() public pure returns (uint256) {\n        return Tips.OFFSET_RELAYER;\n    }\n\n    function offsetProver() public pure returns (uint256) {\n        return Tips.OFFSET_PROVER;\n    }\n\n    function offsetProcessor() public pure returns (uint256) {\n        return Tips.OFFSET_PROCESSOR;\n    }\n\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) public pure returns (bytes memory) {\n        return Tips.formatTips(_updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    function emptyTips() external pure returns (bytes memory) {\n        return Tips.emptyTips();\n    }\n\n    function tipsView(bytes memory _tips) external pure returns (bytes29) {\n        return Tips.tipsView(_tips);\n    }\n\n    function tipsVersion(bytes29 _tips) external pure returns (uint16) {\n        return Tips.tipsVersion(_tips);\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.updaterTip(_tips);\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.relayerTip(_tips);\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.proverTip(_tips);\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) external pure returns (uint96) {\n        return Tips.processorTip(_tips);\n    }\n\n    function totalTips(bytes29 _tips) external pure returns (uint96) {\n        return Tips.totalTips(_tips);\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"26:32242:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;26:32242:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"26:32242:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;2539:94;;;;;;;;198:66:1;186:79;;;168:98;;156:2;141:18;2539:94:0;;;;;;","abiDefinition":[{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/TipsHarness.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/TipsHarness.sol\":{\"keccak256\":\"0xd4a0cae21b9995a7859da5d380597c60cacdf1d04b8a0aecff3e80a25fd34537\",\"urls\":[\"bzz-raw://c09e0256932a2ad21733d0048fcb674b27e9c0b419f8008ee654d42cd4fba150\",\"dweb:/ipfs/QmT7VNaBajgaFxM6SjET1TAZ8CXxfW53ix4MwxiQSzYJiu\"]}},\"version\":1}"},"hashes":{"NULL()":"f26be3fc"}}}