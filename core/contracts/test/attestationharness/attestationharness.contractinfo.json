{"solidity/AttestationHarness.sol:Attestation":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220174c7e2cc841c5259dfc83352f41e0130d1b4723ec6fa05b680a64dd0aedc30e64736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220174c7e2cc841c5259dfc83352f41e0130d1b4723ec6fa05b680a64dd0aedc30e64736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary Attestation {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): homeDomain     uint32   4 bytes\n     * [004 .. 008): nonce          uint32   4 bytes\n     * [008 .. 040): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 040): data           bytes   40 bytes (see above)\n     * [040 .. END): signature      bytes   ?? bytes (64/65 bytes)\n     */\n\n    uint256 internal constant OFFSET_HOME_DOMAIN = 0;\n    uint256 internal constant OFFSET_NONCE = 4;\n    uint256 internal constant OFFSET_ROOT = 8;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 40;\n    uint256 internal constant OFFSET_SIGNATURE = ATTESTATION_DATA_LENGTH;\n\n    /**\n     * @notice Returns formatted Attestation with provided fields\n     * @param _data         Attestation Data (see above)\n     * @param _signature    Notary's signature on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(bytes memory _data, bytes memory _signature)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(_data, _signature);\n    }\n\n    /**\n     * @notice Returns formatted Attestation Data with provided fields\n     * @param _domain   Domain of Home's chain\n     * @param _root     New merkle root\n     * @param _nonce    Nonce of the merkle root\n     * @return Formatted data\n     **/\n    function formatAttestationData(\n        uint32 _domain,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_domain, _nonce, _root);\n    }\n\n    /**\n     * @notice Checks that message is an Attestation, by checking its length\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        // Should have non-zero length for signature. Signature validity is not checked.\n        return _view.len() \u003e ATTESTATION_DATA_LENGTH;\n    }\n\n    /**\n     * @notice Returns domain of chain where the Home contract is deployed\n     */\n    function attestationDomain(bytes29 _view) internal pure returns (uint32) {\n        return uint32(_view.indexUint(OFFSET_HOME_DOMAIN, 4));\n    }\n\n    /**\n     * @notice Returns nonce of Home contract at the time, when `root` was the Merkle root.\n     */\n    function attestationNonce(bytes29 _view) internal pure returns (uint32) {\n        return uint32(_view.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Home contract\n     */\n    function attestationRoot(bytes29 _view) internal pure returns (bytes32) {\n        return _view.index(OFFSET_ROOT, 32);\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure returns (bytes29) {\n        return _view.slice(OFFSET_HOME_DOMAIN, ATTESTATION_DATA_LENGTH, 0);\n    }\n\n    /**\n     * @notice Returns Notary's signature on AttestationData\n     */\n    function attestationSignature(bytes29 _view) internal pure returns (bytes29) {\n        return _view.slice(OFFSET_SIGNATURE, _view.len() - ATTESTATION_DATA_LENGTH, 0);\n    }\n}\n\n// \ncontract AttestationHarness {\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function formatAttestation(\n        uint32 _domain,\n        uint32 _nonce,\n        bytes32 _root,\n        bytes memory _signature\n    ) public pure returns (bytes memory) {\n        return\n            Attestation.formatAttestation(\n                formatAttestationData(_domain, _nonce, _root),\n                _signature\n            );\n    }\n\n    function formatAttestationData(\n        uint32 _domain,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_domain, _nonce, _root);\n    }\n\n    function isAttestation(bytes memory _attestation) public pure returns (bool) {\n        return _attestation.ref(0).isAttestation();\n    }\n\n    function domain(bytes memory _attestation) public pure returns (uint32) {\n        return _attestation.ref(0).attestationDomain();\n    }\n\n    function nonce(bytes memory _attestation) public pure returns (uint32) {\n        return _attestation.ref(0).attestationNonce();\n    }\n\n    function root(bytes memory _attestation) public pure returns (bytes32) {\n        return _attestation.ref(0).attestationRoot();\n    }\n\n    function data(bytes memory _attestation) public view returns (bytes memory) {\n        return _attestation.ref(0).attestationData().clone();\n    }\n\n    function signature(bytes memory _attestation) public view returns (bytes memory) {\n        return _attestation.ref(0).attestationSignature().clone();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"32270:3216:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;32270:3216:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"32270:3216:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_HOME_DOMAIN":{"details":"AttestationData memory layout [000 .. 004): homeDomain     uint32   4 bytes [004 .. 008): nonce          uint32   4 bytes [008 .. 040): root           bytes32 32 bytes      Attestation memory layout [000 .. 040): data           bytes   40 bytes (see above) [040 .. END): signature      bytes   ?? bytes (64/65 bytes)"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_HOME_DOMAIN\":{\"details\":\"AttestationData memory layout [000 .. 004): homeDomain     uint32   4 bytes [004 .. 008): nonce          uint32   4 bytes [008 .. 040): root           bytes32 32 bytes      Attestation memory layout [000 .. 040): data           bytes   40 bytes (see above) [040 .. END): signature      bytes   ?? bytes (64/65 bytes)\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.sol\":\"Attestation\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.sol\":{\"keccak256\":\"0xa1ecb092d1bb125607ee9b568767f9cf0366164f77583e3051f0fb987bc51f77\",\"urls\":[\"bzz-raw://c9a84f9b2d6e2e88831aa5435b0ad28738a7ca90a0abe8a5e3d7247797b99d03\",\"dweb:/ipfs/QmQbt2LQ26nimJJ4DWfzUB5EJ4ufLmYGdWnkDGV1ff7HqE\"]}},\"version\":1}"},"hashes":{}},"solidity/AttestationHarness.sol:AttestationHarness":{"code":"0x608060405234801561001057600080fd5b5061109b806100206000396000f3fe608060405234801561001057600080fd5b50600436106100885760003560e01c8063c2e9e2081161005b578063c2e9e20814610110578063d3d29df114610131578063ef6d4cad14610144578063fbad03131461015757600080fd5b80633ae7034d1461008d5780634d358d65146100b55780634e765004146100d557806358d18e3a146100fd575b600080fd5b6100a061009b366004610cd0565b61016a565b60405190151581526020015b60405180910390f35b6100c86100c3366004610d1e565b61019f565b6040516100ac9190610e00565b6100e86100e3366004610cd0565b6101c0565b60405163ffffffff90911681526020016100ac565b6100c861010b366004610cd0565b6101da565b61012361011e366004610cd0565b610203565b6040519081526020016100ac565b6100c861013f366004610cd0565b61021d565b6100c8610152366004610e13565b61023b565b6100e8610165366004610cd0565b610297565b600061019961017983836102b1565b62ffffff1916602860189190911c6bffffffffffffffffffffffff161190565b92915050565b60606101b56101af86868661023b565b836102d5565b90505b949350505050565b60006101996101cf83836102b1565b62ffffff1916610301565b60606101996101f86101ed8460006102b1565b62ffffff1916610315565b62ffffff1916610348565b600061019961021283836102b1565b62ffffff191661039b565b60606101996101f86102308460006102b1565b62ffffff19166103b0565b604080517fffffffff0000000000000000000000000000000000000000000000000000000060e086811b8216602084015285901b16602482015260288082018490528251808303909101815260489091019091525b9392505050565b60006101996102a683836102b1565b62ffffff19166103c5565b8151600090602084016102cc64ffffffffff851682846103d9565b95945050505050565b606082826040516020016102ea929190610e4f565b604051602081830303815290604052905092915050565b600061019962ffffff198316600480610420565b6000610199602861033881601886901c6bffffffffffffffffffffffff16610ead565b62ffffff19851691906000610450565b60606000806103658460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050604051915081925061038a84836020016104d4565b508181016020016040529052919050565b600061019962ffffff198316600860206106a8565b600061019962ffffff19831682602881610450565b600061019962ffffff198316826004610420565b6000806103e68385610ec4565b90506040518111156103f6575060005b8060000361040b5762ffffff19915050610290565b5050606092831b9190911790911b1760181b90565b600061042d826020610edc565b610438906008610eff565b60ff166104468585856106a8565b901c949350505050565b60008061046b8660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506104848661089a565b8461048f8784610ec4565b6104999190610ec4565b11156104ac5762ffffff199150506101b8565b6104b68582610ec4565b90506104ca8364ffffffffff1682866103d9565b9695505050505050565b600062ffffff1980841603610570576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f54797065644d656d566965772f636f7079546f202d204e756c6c20706f696e7460448201527f657220646572656600000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b610579836108e2565b610605576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f54797065644d656d566965772f636f7079546f202d20496e76616c696420706f60448201527f696e7465722064657265660000000000000000000000000000000000000000006064820152608401610567565b600061061f8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060006106498560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600060405190508481111561066e5760206060fd5b8285848460045afa506104ca6106848760d81c90565b70ffffffffff000000000000000000000000606091821b168717901b841760181b90565b60008160ff166000036106bd57506000610290565b6106d58460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff166106f060ff841685610ec4565b11156107825761074f6107118560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff166107378660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff1661091f565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105679190610e00565b60208260ff161115610816576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e2033322062797465730000000000006064820152608401610567565b6008820260006108348660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60006108b48260181c6bffffffffffffffffffffffff1690565b6108cc8360781c6bffffffffffffffffffffffff1690565b016bffffffffffffffffffffffff169050919050565b60006108ee8260d81c90565b64ffffffffff1664ffffffffff0361090857506000919050565b60006109138361089a565b60405110199392505050565b6060600061092c8661098d565b915050600061093a8661098d565b91505060006109488661098d565b91505060006109568661098d565b915050838383836040516020016109709493929190610f28565b604051602081830303815290604052945050505050949350505050565b600080601f5b600f8160ff161115610a005760006109ac826008610eff565b60ff1685901c90506109bd81610a77565b61ffff16841793508160ff166010146109d857601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610993565b50600f5b60ff8160ff161015610a71576000610a1d826008610eff565b60ff1685901c9050610a2e81610a77565b61ffff16831792508160ff16600014610a4957601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610a04565b50915091565b6000610a8960048360ff16901c610aa9565b60ff1661ffff919091161760081b610aa082610aa9565b60ff1617919050565b600060f08083179060ff82169003610ac45750603092915050565b8060ff1660f103610ad85750603192915050565b8060ff1660f203610aec5750603292915050565b8060ff1660f303610b005750603392915050565b8060ff1660f403610b145750603492915050565b8060ff1660f503610b285750603592915050565b8060ff1660f603610b3c5750603692915050565b8060ff1660f703610b505750603792915050565b8060ff1660f803610b645750603892915050565b8060ff1660f903610b785750603992915050565b8060ff1660fa03610b8c5750606192915050565b8060ff1660fb03610ba05750606292915050565b8060ff1660fc03610bb45750606392915050565b8060ff1660fd03610bc85750606492915050565b8060ff1660fe03610bdc5750606592915050565b8060ff1660ff03610bf05750606692915050565b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610c3657600080fd5b813567ffffffffffffffff80821115610c5157610c51610bf6565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610c9757610c97610bf6565b81604052838152866020858801011115610cb057600080fd5b836020870160208301376000602085830101528094505050505092915050565b600060208284031215610ce257600080fd5b813567ffffffffffffffff811115610cf957600080fd5b6101b884828501610c25565b803563ffffffff81168114610d1957600080fd5b919050565b60008060008060808587031215610d3457600080fd5b610d3d85610d05565b9350610d4b60208601610d05565b925060408501359150606085013567ffffffffffffffff811115610d6e57600080fd5b610d7a87828801610c25565b91505092959194509250565b60005b83811015610da1578181015183820152602001610d89565b83811115610db0576000848401525b50505050565b60008151808452610dce816020860160208601610d86565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006102906020830184610db6565b600080600060608486031215610e2857600080fd5b610e3184610d05565b9250610e3f60208501610d05565b9150604084013590509250925092565b60008351610e61818460208801610d86565b835190830190610e75818360208801610d86565b01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082821015610ebf57610ebf610e7e565b500390565b60008219821115610ed757610ed7610e7e565b500190565b600060ff821660ff841680821015610ef657610ef6610e7e565b90039392505050565b600060ff821660ff84168160ff0481118215151615610f2057610f20610e7e565b029392505050565b7f54797065644d656d566965772f696e646578202d204f76657272616e2074686581527f20766965772e20536c696365206973206174203078000000000000000000000060208201527fffffffffffff000000000000000000000000000000000000000000000000000060d086811b821660358401527f2077697468206c656e6774682030780000000000000000000000000000000000603b840181905286821b8316604a8501527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060508501527f7800000000000000000000000000000000000000000000000000000000000000607085015285821b83166071850152607784015283901b1660868201527f2e00000000000000000000000000000000000000000000000000000000000000608c8201526000608d82016104ca56fea26469706673582212203593e560245ba73c8625f6dae52e94664942ef8a7d7beda4098e2242844aab2064736f6c634300080d0033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100885760003560e01c8063c2e9e2081161005b578063c2e9e20814610110578063d3d29df114610131578063ef6d4cad14610144578063fbad03131461015757600080fd5b80633ae7034d1461008d5780634d358d65146100b55780634e765004146100d557806358d18e3a146100fd575b600080fd5b6100a061009b366004610cd0565b61016a565b60405190151581526020015b60405180910390f35b6100c86100c3366004610d1e565b61019f565b6040516100ac9190610e00565b6100e86100e3366004610cd0565b6101c0565b60405163ffffffff90911681526020016100ac565b6100c861010b366004610cd0565b6101da565b61012361011e366004610cd0565b610203565b6040519081526020016100ac565b6100c861013f366004610cd0565b61021d565b6100c8610152366004610e13565b61023b565b6100e8610165366004610cd0565b610297565b600061019961017983836102b1565b62ffffff1916602860189190911c6bffffffffffffffffffffffff161190565b92915050565b60606101b56101af86868661023b565b836102d5565b90505b949350505050565b60006101996101cf83836102b1565b62ffffff1916610301565b60606101996101f86101ed8460006102b1565b62ffffff1916610315565b62ffffff1916610348565b600061019961021283836102b1565b62ffffff191661039b565b60606101996101f86102308460006102b1565b62ffffff19166103b0565b604080517fffffffff0000000000000000000000000000000000000000000000000000000060e086811b8216602084015285901b16602482015260288082018490528251808303909101815260489091019091525b9392505050565b60006101996102a683836102b1565b62ffffff19166103c5565b8151600090602084016102cc64ffffffffff851682846103d9565b95945050505050565b606082826040516020016102ea929190610e4f565b604051602081830303815290604052905092915050565b600061019962ffffff198316600480610420565b6000610199602861033881601886901c6bffffffffffffffffffffffff16610ead565b62ffffff19851691906000610450565b60606000806103658460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050604051915081925061038a84836020016104d4565b508181016020016040529052919050565b600061019962ffffff198316600860206106a8565b600061019962ffffff19831682602881610450565b600061019962ffffff198316826004610420565b6000806103e68385610ec4565b90506040518111156103f6575060005b8060000361040b5762ffffff19915050610290565b5050606092831b9190911790911b1760181b90565b600061042d826020610edc565b610438906008610eff565b60ff166104468585856106a8565b901c949350505050565b60008061046b8660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506104848661089a565b8461048f8784610ec4565b6104999190610ec4565b11156104ac5762ffffff199150506101b8565b6104b68582610ec4565b90506104ca8364ffffffffff1682866103d9565b9695505050505050565b600062ffffff1980841603610570576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f54797065644d656d566965772f636f7079546f202d204e756c6c20706f696e7460448201527f657220646572656600000000000000000000000000000000000000000000000060648201526084015b60405180910390fd5b610579836108e2565b610605576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f54797065644d656d566965772f636f7079546f202d20496e76616c696420706f60448201527f696e7465722064657265660000000000000000000000000000000000000000006064820152608401610567565b600061061f8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060006106498560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600060405190508481111561066e5760206060fd5b8285848460045afa506104ca6106848760d81c90565b70ffffffffff000000000000000000000000606091821b168717901b841760181b90565b60008160ff166000036106bd57506000610290565b6106d58460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff166106f060ff841685610ec4565b11156107825761074f6107118560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff166107378660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff1661091f565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105679190610e00565b60208260ff161115610816576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e2033322062797465730000000000006064820152608401610567565b6008820260006108348660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60006108b48260181c6bffffffffffffffffffffffff1690565b6108cc8360781c6bffffffffffffffffffffffff1690565b016bffffffffffffffffffffffff169050919050565b60006108ee8260d81c90565b64ffffffffff1664ffffffffff0361090857506000919050565b60006109138361089a565b60405110199392505050565b6060600061092c8661098d565b915050600061093a8661098d565b91505060006109488661098d565b91505060006109568661098d565b915050838383836040516020016109709493929190610f28565b604051602081830303815290604052945050505050949350505050565b600080601f5b600f8160ff161115610a005760006109ac826008610eff565b60ff1685901c90506109bd81610a77565b61ffff16841793508160ff166010146109d857601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610993565b50600f5b60ff8160ff161015610a71576000610a1d826008610eff565b60ff1685901c9050610a2e81610a77565b61ffff16831792508160ff16600014610a4957601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610a04565b50915091565b6000610a8960048360ff16901c610aa9565b60ff1661ffff919091161760081b610aa082610aa9565b60ff1617919050565b600060f08083179060ff82169003610ac45750603092915050565b8060ff1660f103610ad85750603192915050565b8060ff1660f203610aec5750603292915050565b8060ff1660f303610b005750603392915050565b8060ff1660f403610b145750603492915050565b8060ff1660f503610b285750603592915050565b8060ff1660f603610b3c5750603692915050565b8060ff1660f703610b505750603792915050565b8060ff1660f803610b645750603892915050565b8060ff1660f903610b785750603992915050565b8060ff1660fa03610b8c5750606192915050565b8060ff1660fb03610ba05750606292915050565b8060ff1660fc03610bb45750606392915050565b8060ff1660fd03610bc85750606492915050565b8060ff1660fe03610bdc5750606592915050565b8060ff1660ff03610bf05750606692915050565b50919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610c3657600080fd5b813567ffffffffffffffff80821115610c5157610c51610bf6565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610c9757610c97610bf6565b81604052838152866020858801011115610cb057600080fd5b836020870160208301376000602085830101528094505050505092915050565b600060208284031215610ce257600080fd5b813567ffffffffffffffff811115610cf957600080fd5b6101b884828501610c25565b803563ffffffff81168114610d1957600080fd5b919050565b60008060008060808587031215610d3457600080fd5b610d3d85610d05565b9350610d4b60208601610d05565b925060408501359150606085013567ffffffffffffffff811115610d6e57600080fd5b610d7a87828801610c25565b91505092959194509250565b60005b83811015610da1578181015183820152602001610d89565b83811115610db0576000848401525b50505050565b60008151808452610dce816020860160208601610d86565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006102906020830184610db6565b600080600060608486031215610e2857600080fd5b610e3184610d05565b9250610e3f60208501610d05565b9150604084013590509250925092565b60008351610e61818460208801610d86565b835190830190610e75818360208801610d86565b01949350505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600082821015610ebf57610ebf610e7e565b500390565b60008219821115610ed757610ed7610e7e565b500190565b600060ff821660ff841680821015610ef657610ef6610e7e565b90039392505050565b600060ff821660ff84168160ff0481118215151615610f2057610f20610e7e565b029392505050565b7f54797065644d656d566965772f696e646578202d204f76657272616e2074686581527f20766965772e20536c696365206973206174203078000000000000000000000060208201527fffffffffffff000000000000000000000000000000000000000000000000000060d086811b821660358401527f2077697468206c656e6774682030780000000000000000000000000000000000603b840181905286821b8316604a8501527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060508501527f7800000000000000000000000000000000000000000000000000000000000000607085015285821b83166071850152607784015283901b1660868201527f2e00000000000000000000000000000000000000000000000000000000000000608c8201526000608d82016104ca56fea26469706673582212203593e560245ba73c8625f6dae52e94664942ef8a7d7beda4098e2242844aab2064736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary Attestation {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): homeDomain     uint32   4 bytes\n     * [004 .. 008): nonce          uint32   4 bytes\n     * [008 .. 040): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 040): data           bytes   40 bytes (see above)\n     * [040 .. END): signature      bytes   ?? bytes (64/65 bytes)\n     */\n\n    uint256 internal constant OFFSET_HOME_DOMAIN = 0;\n    uint256 internal constant OFFSET_NONCE = 4;\n    uint256 internal constant OFFSET_ROOT = 8;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 40;\n    uint256 internal constant OFFSET_SIGNATURE = ATTESTATION_DATA_LENGTH;\n\n    /**\n     * @notice Returns formatted Attestation with provided fields\n     * @param _data         Attestation Data (see above)\n     * @param _signature    Notary's signature on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(bytes memory _data, bytes memory _signature)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(_data, _signature);\n    }\n\n    /**\n     * @notice Returns formatted Attestation Data with provided fields\n     * @param _domain   Domain of Home's chain\n     * @param _root     New merkle root\n     * @param _nonce    Nonce of the merkle root\n     * @return Formatted data\n     **/\n    function formatAttestationData(\n        uint32 _domain,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_domain, _nonce, _root);\n    }\n\n    /**\n     * @notice Checks that message is an Attestation, by checking its length\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        // Should have non-zero length for signature. Signature validity is not checked.\n        return _view.len() \u003e ATTESTATION_DATA_LENGTH;\n    }\n\n    /**\n     * @notice Returns domain of chain where the Home contract is deployed\n     */\n    function attestationDomain(bytes29 _view) internal pure returns (uint32) {\n        return uint32(_view.indexUint(OFFSET_HOME_DOMAIN, 4));\n    }\n\n    /**\n     * @notice Returns nonce of Home contract at the time, when `root` was the Merkle root.\n     */\n    function attestationNonce(bytes29 _view) internal pure returns (uint32) {\n        return uint32(_view.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Home contract\n     */\n    function attestationRoot(bytes29 _view) internal pure returns (bytes32) {\n        return _view.index(OFFSET_ROOT, 32);\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure returns (bytes29) {\n        return _view.slice(OFFSET_HOME_DOMAIN, ATTESTATION_DATA_LENGTH, 0);\n    }\n\n    /**\n     * @notice Returns Notary's signature on AttestationData\n     */\n    function attestationSignature(bytes29 _view) internal pure returns (bytes29) {\n        return _view.slice(OFFSET_SIGNATURE, _view.len() - ATTESTATION_DATA_LENGTH, 0);\n    }\n}\n\n// \ncontract AttestationHarness {\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function formatAttestation(\n        uint32 _domain,\n        uint32 _nonce,\n        bytes32 _root,\n        bytes memory _signature\n    ) public pure returns (bytes memory) {\n        return\n            Attestation.formatAttestation(\n                formatAttestationData(_domain, _nonce, _root),\n                _signature\n            );\n    }\n\n    function formatAttestationData(\n        uint32 _domain,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_domain, _nonce, _root);\n    }\n\n    function isAttestation(bytes memory _attestation) public pure returns (bool) {\n        return _attestation.ref(0).isAttestation();\n    }\n\n    function domain(bytes memory _attestation) public pure returns (uint32) {\n        return _attestation.ref(0).attestationDomain();\n    }\n\n    function nonce(bytes memory _attestation) public pure returns (uint32) {\n        return _attestation.ref(0).attestationNonce();\n    }\n\n    function root(bytes memory _attestation) public pure returns (bytes32) {\n        return _attestation.ref(0).attestationRoot();\n    }\n\n    function data(bytes memory _attestation) public view returns (bytes memory) {\n        return _attestation.ref(0).attestationData().clone();\n    }\n\n    function signature(bytes memory _attestation) public view returns (bytes memory) {\n        return _attestation.ref(0).attestationSignature().clone();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"35492:1584:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"35492:1584:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;36208:136;;;;;;:::i;:::-;;:::i;:::-;;;1475:14:1;;1468:22;1450:41;;1438:2;1423:18;36208:136:0;;;;;;;;35632:341;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;36491:133::-;;;;;;:::i;:::-;;:::i;:::-;;;3188:10:1;3176:23;;;3158:42;;3146:2;3131:18;36491:133:0;3014:192:1;36919:155:0;;;;;;:::i;:::-;;:::i;36630:132::-;;;;;;:::i;:::-;;:::i;:::-;;;3357:25:1;;;3345:2;3330:18;36630:132:0;3211:177:1;36768:145:0;;;;;;:::i;:::-;;:::i;35979:223::-;;;;;;:::i;:::-;;:::i;36350:135::-;;;;;;:::i;:::-;;:::i;36208:136::-;36279:4;36302:35;:19;:12;36279:4;36302:16;:19::i;:::-;-1:-1:-1;;36302:33:0;32963:2;16492;16488:16;;;;2670:26;16484:28;34217:37;;34044:217;36302:35;36295:42;36208:136;-1:-1:-1;;36208:136:0:o;35632:341::-;35789:12;35832:134;35879:45;35901:7;35910:6;35918:5;35879:21;:45::i;:::-;35942:10;35832:29;:134::i;:::-;35813:153;;35632:341;;;;;;;:::o;36491:133::-;36554:6;36579:38;:19;:12;36554:6;36579:16;:19::i;:::-;-1:-1:-1;;36579:36:0;;:38::i;36919:155::-;36986:12;37017:50;:42;:19;:12;37034:1;37017:16;:19::i;:::-;-1:-1:-1;;37017:40:0;;:42::i;:::-;-1:-1:-1;;37017:48:0;;:50::i;36630:132::-;36692:7;36718:37;:19;:12;36692:7;36718:16;:19::i;:::-;-1:-1:-1;;36718:35:0;;:37::i;36768:145::-;36830:12;36861:45;:37;:19;:12;36878:1;36861:16;:19::i;:::-;-1:-1:-1;;36861:35:0;;:37::i;35979:223::-;33898:40;;;4703:66:1;4798:3;4794:16;;;4790:25;;33898:40:0;;;4778:38:1;4849:16;;;4845:25;4832:11;;;4825:46;4887:11;;;;4880:27;;;33898:40:0;;;;;;;;;;4923:12:1;;;;33898:40:0;;;35979:223;;;;;;:::o;36350:135::-;36414:6;36439:39;:19;:12;36414:6;36439:16;:19::i;:::-;-1:-1:-1;;36439:37:0;;:39::i;13655:359::-;13759:10;;13725:7;;13906:4;13897:14;;13981:26;;;;13897:14;13759:10;13981:5;:26::i;:::-;13974:33;13655:359;-1:-1:-1;;;;;13655:359:0:o;33281:196::-;33400:12;33452:5;33459:10;33435:35;;;;;;;;;:::i;:::-;;;;;;;;;;;;;33428:42;;33281:196;;;;:::o;34615:136::-;34679:6;34711:32;-1:-1:-1;;34711:15:0;;32857:1;;34711:15;:32::i;35312:172::-;35380:7;35406:71;32963:2;35436:37;32963:2;16492;16488:16;;;2670:26;16484:28;35436:37;:::i;:::-;-1:-1:-1;;35406:11:0;;;:71;35475:1;35406:11;:71::i;28308:632::-;28363:16;28391:11;28412:12;28427;28431:7;16492:2;16488:16;2670:26;16484:28;;16246:282;28427:12;28412:27;;;;28549:4;28543:11;28536:18;;28604:3;28597:10;;28650:33;28663:7;28672:3;28678:4;28672:10;28650:12;:33::i;:::-;-1:-1:-1;28807:14:0;;;28823:4;28803:25;28797:4;28790:39;28870:17;;28308:632;;-1:-1:-1;28308:632:0:o;34844:124::-;34907:7;34933:28;-1:-1:-1;;34933:11:0;;32904:1;34958:2;34933:11;:28::i;35074:155::-;35137:7;35163:59;-1:-1:-1;;35163:11:0;;35137:7;32963:2;35137:7;35163:11;:59::i;34358:143::-;34423:6;34455:38;-1:-1:-1;;34455:15:0;;34423:6;34491:1;34455:15;:38::i;12796:462::-;12907:15;;12949:11;12956:4;12949;:11;:::i;:::-;12934:26;;13075:4;13069:11;13063:4;13060:21;13057:66;;;-1:-1:-1;13108:1:0;13057:66;13146:4;13154:1;13146:9;13142:51;;-1:-1:-1;;13171:11:0;;;;;13142:51;-1:-1:-1;;12065:2:0;12061:27;;;12135:17;;;;12127:26;;;12199:17;12195:2;12191:26;;12796:462::o;21121:221::-;21240:14;21318:11;21323:6;21318:2;:11;:::i;:::-;21317:17;;21333:1;21317:17;:::i;:::-;21273:62;;21281:30;21287:7;21296:6;21304;21281:5;:30::i;:::-;21273:62;;;21121:221;-1:-1:-1;;;;21121:221:0:o;17129:399::-;17268:7;17287:12;17302;17306:7;15386:3;15382:17;2670:26;15378:29;;15059:364;17302:12;17287:27;;;;17398:12;17402:7;17398:3;:12::i;:::-;17391:4;17375:13;17382:6;17375:4;:13;:::i;:::-;:20;;;;:::i;:::-;:35;17371:77;;;-1:-1:-1;;17426:11:0;;;;;17371:77;17465:13;17472:6;17465:4;:13;:::i;:::-;17458:20;;17495:26;17501:7;17495:26;;17510:4;17516;17495:5;:26::i;:::-;17488:33;17129:399;-1:-1:-1;;;;;;17129:399:0:o;27036:902::-;27114:15;-1:-1:-1;;7972:15:0;;;;27141:69;;;;;;;5724:2:1;27141:69:0;;;5706:21:1;5763:2;5743:18;;;5736:30;5802:34;5782:18;;;5775:62;5873:10;5853:18;;;5846:38;5901:19;;27141:69:0;;;;;;;;;27228:16;27236:7;27228;:16::i;:::-;27220:72;;;;;;;6133:2:1;27220:72:0;;;6115:21:1;6172:2;6152:18;;;6145:30;6211:34;6191:18;;;6184:62;6282:13;6262:18;;;6255:41;6313:19;;27220:72:0;5931:407:1;27220:72:0;27302:12;27317;27321:7;16492:2;16488:16;2670:26;16484:28;;16246:282;27317:12;27302:27;;;;27339:15;27357:12;27361:7;15386:3;15382:17;2670:26;15378:29;;15059:364;27357:12;27339:30;;;;27380:11;27501:4;27495:11;27488:18;;27588:7;27583:3;27580:16;27577:94;;;27628:4;27622;27615:18;27577:94;27843:4;27834:7;27828:4;27819:7;27816:1;27809:5;27798:50;27794:55;27879:52;27900:15;27907:7;14417:3;14413:17;;14206:268;27900:15;12061:27;12065:2;12061:27;;;;12135:17;;12127:26;;12199:17;;12195:2;12191:26;;11811:446;20004:771;20119:14;20149:6;:11;;20159:1;20149:11;20145:59;;-1:-1:-1;20191:1:0;20176:17;;20145:59;20235:12;20239:7;16492:2;16488:16;2670:26;16484:28;;16246:282;20235:12;20217:30;;:15;;;;:6;:15;:::i;:::-;:30;20213:137;;;20270:68;20286:12;20290:7;15386:3;15382:17;2670:26;15378:29;;15059:364;20286:12;20270:68;;20300:12;20304:7;16492:2;16488:16;2670:26;16484:28;;16246:282;20300:12;20270:68;;20314:6;20330;20322:15;;20270;:68::i;:::-;20263:76;;;;;;;;;;;:::i;20213:137::-;20377:2;20367:6;:12;;;;20359:83;;;;;;;6769:2:1;20359:83:0;;;6751:21:1;6808:2;6788:18;;;6781:30;6847:34;6827:18;;;6820:62;6918:28;6898:18;;;6891:56;6964:19;;20359:83:0;6567:422:1;20359:83:0;20523:1;20514:10;;20453:15;20559:12;20563:7;15386:3;15382:17;2670:26;15378:29;;15059:364;20559:12;20544:27;;;-1:-1:-1;20581:13:0;7488:66;7458:12;;;7437:131;20733:17;;;;20727:24;20723:36;;;-1:-1:-1;;;;;20004:771:0:o;16702:147::-;16755:7;16820:12;16824:7;16492:2;16488:16;2670:26;16484:28;;16246:282;16820:12;16805;16809:7;15386:3;15382:17;2670:26;15378:29;;15059:364;16805:12;:27;16798:34;;;;16702:147;;;:::o;8645:333::-;8702:8;8726:15;8733:7;14417:3;14413:17;;14206:268;8726:15;:31;;8745:12;8726:31;8722:74;;-1:-1:-1;8780:5:0;;8645:333;-1:-1:-1;8645:333:0:o;8722:74::-;8805:12;8820;8824:7;8820:3;:12::i;:::-;8955:4;8949:11;-1:-1:-1;8936:26:0;;8645:333;-1:-1:-1;;;8645:333:0:o;18761:741::-;18907:17;18939:9;18952:15;18962:4;18952:9;:15::i;:::-;18936:31;;;18980:9;18993:15;19003:4;18993:9;:15::i;:::-;18977:31;;;19021:9;19034:17;19044:6;19034:9;:17::i;:::-;19018:33;;;19064:9;19077:17;19087:6;19077:9;:17::i;:::-;19061:33;;;19244:1;19306;19386;19448;19130:355;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;19104:391;;18926:576;;;;18761:741;;;;;;:::o;5031:667::-;5085:13;;5141:2;5126:258;5149:2;5145:1;:6;;;5126:258;;;5169:11;5196:5;:1;5200;5196:5;:::i;:::-;5189:13;;:2;:13;;5169:34;;5226:14;5234:5;5226:7;:14::i;:::-;5217:23;;;;;;5258:1;:7;;5263:2;5258:7;5254:58;;5295:2;5285:12;;;;;5254:58;-1:-1:-1;5353:6:0;;5126:258;;;-1:-1:-1;5447:2:0;5432:260;5455:3;5451:1;:7;;;5432:260;;;5476:11;5503:5;:1;5507;5503:5;:::i;:::-;5496:13;;:2;:13;;5476:34;;5534:14;5542:5;5534:7;:14::i;:::-;5524:24;;;;;;5566:1;:6;;5571:1;5566:6;5562:58;;5603:2;5592:13;;;;;5562:58;-1:-1:-1;5661:6:0;;5432:260;;;;5031:667;;;:::o;4508:199::-;4558:14;4595:18;4611:1;4605:2;:7;;;;4595:9;:18::i;:::-;4584:29;;4637:13;;;;;;4649:1;4637:13;4671;4681:2;4671:9;:13::i;:::-;4660:24;;;;4508:199;-1:-1:-1;4508:199:0:o;2943:1393::-;2995:10;3161:4;3156:9;;;;3207:15;;;;;3203:57;;-1:-1:-1;3245:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3203:57::-;3278:7;:15;;3289:4;3278:15;3274:57;;-1:-1:-1;3316:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3274:57::-;3349:7;:15;;3360:4;3349:15;3345:57;;-1:-1:-1;3387:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3345:57::-;3420:7;:15;;3431:4;3420:15;3416:57;;-1:-1:-1;3458:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3416:57::-;3491:7;:15;;3502:4;3491:15;3487:57;;-1:-1:-1;3529:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3487:57::-;3562:7;:15;;3573:4;3562:15;3558:57;;-1:-1:-1;3600:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3558:57::-;3633:7;:15;;3644:4;3633:15;3629:57;;-1:-1:-1;3671:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3629:57::-;3704:7;:15;;3715:4;3704:15;3700:57;;-1:-1:-1;3742:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3700:57::-;3775:7;:15;;3786:4;3775:15;3771:57;;-1:-1:-1;3813:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3771:57::-;3846:7;:15;;3857:4;3846:15;3842:57;;-1:-1:-1;3884:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3842:57::-;3917:7;:15;;3928:4;3917:15;3913:57;;-1:-1:-1;3955:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3913:57::-;3988:7;:15;;3999:4;3988:15;3984:57;;-1:-1:-1;4026:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3984:57::-;4059:7;:15;;4070:4;4059:15;4055:57;;-1:-1:-1;4097:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4055:57::-;4130:7;:15;;4141:4;4130:15;4126:57;;-1:-1:-1;4168:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4126:57::-;4201:7;:15;;4212:4;4201:15;4197:57;;-1:-1:-1;4239:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4197:57::-;4272:7;:15;;4283:4;4272:15;4268:57;;-1:-1:-1;4310:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4268:57::-;3007:1329;2943:1393;;;:::o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:320::-;1053:6;1106:2;1094:9;1085:7;1081:23;1077:32;1074:52;;;1122:1;1119;1112:12;1074:52;1162:9;1149:23;1195:18;1187:6;1184:30;1181:50;;;1227:1;1224;1217:12;1181:50;1250:49;1291:7;1282:6;1271:9;1267:22;1250:49;:::i;1502:163::-;1569:20;;1629:10;1618:22;;1608:33;;1598:61;;1655:1;1652;1645:12;1598:61;1502:163;;;:::o;1670:533::-;1763:6;1771;1779;1787;1840:3;1828:9;1819:7;1815:23;1811:33;1808:53;;;1857:1;1854;1847:12;1808:53;1880:28;1898:9;1880:28;:::i;:::-;1870:38;;1927:37;1960:2;1949:9;1945:18;1927:37;:::i;:::-;1917:47;;2011:2;2000:9;1996:18;1983:32;1973:42;;2066:2;2055:9;2051:18;2038:32;2093:18;2085:6;2082:30;2079:50;;;2125:1;2122;2115:12;2079:50;2148:49;2189:7;2180:6;2169:9;2165:22;2148:49;:::i;:::-;2138:59;;;1670:533;;;;;;;:::o;2208:258::-;2280:1;2290:113;2304:6;2301:1;2298:13;2290:113;;;2380:11;;;2374:18;2361:11;;;2354:39;2326:2;2319:10;2290:113;;;2421:6;2418:1;2415:13;2412:48;;;2456:1;2447:6;2442:3;2438:16;2431:27;2412:48;;2208:258;;;:::o;2471:316::-;2512:3;2550:5;2544:12;2577:6;2572:3;2565:19;2593:63;2649:6;2642:4;2637:3;2633:14;2626:4;2619:5;2615:16;2593:63;:::i;:::-;2701:2;2689:15;2706:66;2685:88;2676:98;;;;2776:4;2672:109;;2471:316;-1:-1:-1;;2471:316:1:o;2792:217::-;2939:2;2928:9;2921:21;2902:4;2959:44;2999:2;2988:9;2984:18;2976:6;2959:44;:::i;3393:324::-;3468:6;3476;3484;3537:2;3525:9;3516:7;3512:23;3508:32;3505:52;;;3553:1;3550;3543:12;3505:52;3576:28;3594:9;3576:28;:::i;:::-;3566:38;;3623:37;3656:2;3645:9;3641:18;3623:37;:::i;:::-;3613:47;;3707:2;3696:9;3692:18;3679:32;3669:42;;3393:324;;;;;:::o;3722:466::-;3897:3;3935:6;3929:13;3951:53;3997:6;3992:3;3985:4;3977:6;3973:17;3951:53;:::i;:::-;4067:13;;4026:16;;;;4089:57;4067:13;4026:16;4123:4;4111:17;;4089:57;:::i;:::-;4162:20;;3722:466;-1:-1:-1;;;;3722:466:1:o;4193:184::-;4245:77;4242:1;4235:88;4342:4;4339:1;4332:15;4366:4;4363:1;4356:15;4382:125;4422:4;4450:1;4447;4444:8;4441:34;;;4455:18;;:::i;:::-;-1:-1:-1;4492:9:1;;4382:125::o;4946:128::-;4986:3;5017:1;5013:6;5010:1;5007:13;5004:39;;;5023:18;;:::i;:::-;-1:-1:-1;5059:9:1;;4946:128::o;5079:195::-;5117:4;5154;5151:1;5147:12;5186:4;5183:1;5179:12;5211:3;5206;5203:12;5200:38;;;5218:18;;:::i;:::-;5255:13;;;5079:195;-1:-1:-1;;;5079:195:1:o;5279:238::-;5317:7;5357:4;5354:1;5350:12;5389:4;5386:1;5382:12;5449:3;5443:4;5439:14;5434:3;5431:23;5424:3;5417:11;5410:19;5406:49;5403:75;;;5458:18;;:::i;:::-;5498:13;;5279:238;-1:-1:-1;;;5279:238:1:o;7113:1391::-;7835:34;7823:47;;7900:23;7895:2;7886:12;;7879:45;7943:66;8047:3;8043:16;;;8039:25;;8034:2;8025:12;;8018:47;8084:17;8126:2;8117:12;;8110:24;;;8168:16;;;8164:25;;8159:2;8150:12;;8143:47;8220:34;8215:2;8206:12;;8199:56;8286:3;8280;8271:13;;8264:26;8325:16;;;8321:25;;8315:3;8306:13;;8299:48;8372:3;8363:13;;8356:25;8416:16;;;8412:25;8406:3;8397:13;;8390:48;7071:3;8493;8484:13;;7059:16;-1:-1:-1;7091:11:1;;;8454:44;6994:114","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"_attestation","type":"bytes"}],"name":"data","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_attestation","type":"bytes"}],"name":"domain","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_domain","type":"uint32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"bytes32","name":"_root","type":"bytes32"},{"internalType":"bytes","name":"_signature","type":"bytes"}],"name":"formatAttestation","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_domain","type":"uint32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"bytes32","name":"_root","type":"bytes32"}],"name":"formatAttestationData","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_attestation","type":"bytes"}],"name":"isAttestation","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_attestation","type":"bytes"}],"name":"nonce","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_attestation","type":"bytes"}],"name":"root","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_attestation","type":"bytes"}],"name":"signature","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_attestation\",\"type\":\"bytes\"}],\"name\":\"data\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_attestation\",\"type\":\"bytes\"}],\"name\":\"domain\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"formatAttestation\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_domain\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"formatAttestationData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_attestation\",\"type\":\"bytes\"}],\"name\":\"isAttestation\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_attestation\",\"type\":\"bytes\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_attestation\",\"type\":\"bytes\"}],\"name\":\"root\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_attestation\",\"type\":\"bytes\"}],\"name\":\"signature\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.sol\":\"AttestationHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.sol\":{\"keccak256\":\"0xa1ecb092d1bb125607ee9b568767f9cf0366164f77583e3051f0fb987bc51f77\",\"urls\":[\"bzz-raw://c9a84f9b2d6e2e88831aa5435b0ad28738a7ca90a0abe8a5e3d7247797b99d03\",\"dweb:/ipfs/QmQbt2LQ26nimJJ4DWfzUB5EJ4ufLmYGdWnkDGV1ff7HqE\"]}},\"version\":1}"},"hashes":{"data(bytes)":"d3d29df1","domain(bytes)":"fbad0313","formatAttestation(uint32,uint32,bytes32,bytes)":"4d358d65","formatAttestationData(uint32,uint32,bytes32)":"ef6d4cad","isAttestation(bytes)":"3ae7034d","nonce(bytes)":"4e765004","root(bytes)":"c2e9e208","signature(bytes)":"58d18e3a"}},"solidity/AttestationHarness.sol:TypedMemView":{"code":"0x60c9610038600b82828239805160001a607314602b57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f26be3fc146038575b600080fd5b605e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000909116815260200160405180910390f3fea26469706673582212209ea5273888337b1496057049c57d442a265b849725273d42b7024200b638c69464736f6c634300080d0033","runtime-code":"0x730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f26be3fc146038575b600080fd5b605e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000909116815260200160405180910390f3fea26469706673582212209ea5273888337b1496057049c57d442a265b849725273d42b7024200b638c69464736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary Attestation {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev AttestationData memory layout\n     * [000 .. 004): homeDomain     uint32   4 bytes\n     * [004 .. 008): nonce          uint32   4 bytes\n     * [008 .. 040): root           bytes32 32 bytes\n     *\n     *      Attestation memory layout\n     * [000 .. 040): data           bytes   40 bytes (see above)\n     * [040 .. END): signature      bytes   ?? bytes (64/65 bytes)\n     */\n\n    uint256 internal constant OFFSET_HOME_DOMAIN = 0;\n    uint256 internal constant OFFSET_NONCE = 4;\n    uint256 internal constant OFFSET_ROOT = 8;\n    uint256 internal constant ATTESTATION_DATA_LENGTH = 40;\n    uint256 internal constant OFFSET_SIGNATURE = ATTESTATION_DATA_LENGTH;\n\n    /**\n     * @notice Returns formatted Attestation with provided fields\n     * @param _data         Attestation Data (see above)\n     * @param _signature    Notary's signature on `_data`\n     * @return Formatted attestation\n     **/\n    function formatAttestation(bytes memory _data, bytes memory _signature)\n        internal\n        pure\n        returns (bytes memory)\n    {\n        return abi.encodePacked(_data, _signature);\n    }\n\n    /**\n     * @notice Returns formatted Attestation Data with provided fields\n     * @param _domain   Domain of Home's chain\n     * @param _root     New merkle root\n     * @param _nonce    Nonce of the merkle root\n     * @return Formatted data\n     **/\n    function formatAttestationData(\n        uint32 _domain,\n        uint32 _nonce,\n        bytes32 _root\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(_domain, _nonce, _root);\n    }\n\n    /**\n     * @notice Checks that message is an Attestation, by checking its length\n     */\n    function isAttestation(bytes29 _view) internal pure returns (bool) {\n        // Should have non-zero length for signature. Signature validity is not checked.\n        return _view.len() \u003e ATTESTATION_DATA_LENGTH;\n    }\n\n    /**\n     * @notice Returns domain of chain where the Home contract is deployed\n     */\n    function attestationDomain(bytes29 _view) internal pure returns (uint32) {\n        return uint32(_view.indexUint(OFFSET_HOME_DOMAIN, 4));\n    }\n\n    /**\n     * @notice Returns nonce of Home contract at the time, when `root` was the Merkle root.\n     */\n    function attestationNonce(bytes29 _view) internal pure returns (uint32) {\n        return uint32(_view.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /**\n     * @notice Returns a historical Merkle root from the Home contract\n     */\n    function attestationRoot(bytes29 _view) internal pure returns (bytes32) {\n        return _view.index(OFFSET_ROOT, 32);\n    }\n\n    /**\n     * @notice Returns Attestation's Data, that is going to be signed by the Notary\n     */\n    function attestationData(bytes29 _view) internal pure returns (bytes29) {\n        return _view.slice(OFFSET_HOME_DOMAIN, ATTESTATION_DATA_LENGTH, 0);\n    }\n\n    /**\n     * @notice Returns Notary's signature on AttestationData\n     */\n    function attestationSignature(bytes29 _view) internal pure returns (bytes29) {\n        return _view.slice(OFFSET_SIGNATURE, _view.len() - ATTESTATION_DATA_LENGTH, 0);\n    }\n}\n\n// \ncontract AttestationHarness {\n    using Attestation for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function formatAttestation(\n        uint32 _domain,\n        uint32 _nonce,\n        bytes32 _root,\n        bytes memory _signature\n    ) public pure returns (bytes memory) {\n        return\n            Attestation.formatAttestation(\n                formatAttestationData(_domain, _nonce, _root),\n                _signature\n            );\n    }\n\n    function formatAttestationData(\n        uint32 _domain,\n        uint32 _nonce,\n        bytes32 _root\n    ) public pure returns (bytes memory) {\n        return Attestation.formatAttestationData(_domain, _nonce, _root);\n    }\n\n    function isAttestation(bytes memory _attestation) public pure returns (bool) {\n        return _attestation.ref(0).isAttestation();\n    }\n\n    function domain(bytes memory _attestation) public pure returns (uint32) {\n        return _attestation.ref(0).attestationDomain();\n    }\n\n    function nonce(bytes memory _attestation) public pure returns (uint32) {\n        return _attestation.ref(0).attestationNonce();\n    }\n\n    function root(bytes memory _attestation) public pure returns (bytes32) {\n        return _attestation.ref(0).attestationRoot();\n    }\n\n    function data(bytes memory _attestation) public view returns (bytes memory) {\n        return _attestation.ref(0).attestationData().clone();\n    }\n\n    function signature(bytes memory _attestation) public view returns (bytes memory) {\n        return _attestation.ref(0).attestationSignature().clone();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"26:32242:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;26:32242:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"26:32242:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;2539:94;;;;;;;;198:66:1;186:79;;;168:98;;156:2;141:18;2539:94:0;;;;;;","abiDefinition":[{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/AttestationHarness.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/AttestationHarness.sol\":{\"keccak256\":\"0xa1ecb092d1bb125607ee9b568767f9cf0366164f77583e3051f0fb987bc51f77\",\"urls\":[\"bzz-raw://c9a84f9b2d6e2e88831aa5435b0ad28738a7ca90a0abe8a5e3d7247797b99d03\",\"dweb:/ipfs/QmQbt2LQ26nimJJ4DWfzUB5EJ4ufLmYGdWnkDGV1ff7HqE\"]}},\"version\":1}"},"hashes":{"NULL()":"f26be3fc"}}}