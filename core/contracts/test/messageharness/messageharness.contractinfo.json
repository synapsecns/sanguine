{"solidity/MessageHarness.sol:Header":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220151de2853871dd0747b9d52f6ca623fb23b91958b265dd507ad724e447a11b3c64736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220151de2853871dd0747b9d52f6ca623fb23b91958b265dd507ad724e447a11b3c64736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"38359:3297:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;38359:3297:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"38359:3297:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_ORIGIN":{"details":"Header memory layout [000 .. 002): version            uint16   2 bytes [002 .. 006): originDomain       uint32   4 bytes [006 .. 038): sender             bytes32 32 bytes [038 .. 042): nonce              uint32   4 bytes [042 .. 046): destinationDomain  uint32   4 bytes [046 .. 078): recipient          bytes32 32 bytes [078 .. 082): optimisticSeconds  uint32   4 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_ORIGIN\":{\"details\":\"Header memory layout [000 .. 002): version            uint16   2 bytes [002 .. 006): originDomain       uint32   4 bytes [006 .. 038): sender             bytes32 32 bytes [038 .. 042): nonce              uint32   4 bytes [042 .. 046): destinationDomain  uint32   4 bytes [046 .. 078): recipient          bytes32 32 bytes [078 .. 082): optimisticSeconds  uint32   4 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"Header\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xf6e9ee713825afa2c227d061dae76dd824f85b31a15d838206a967b23353a673\",\"urls\":[\"bzz-raw://f061a04f570408bbb7590e9a719fd5dc59069f4a04f4a1ba4b38c17dc82abdfd\",\"dweb:/ipfs/QmV8VVt3ExGtCwjLr2tEjVRD6VbeKK1hPvtY8PPy8QNg8E\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.sol:Message":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208d58afd4704cdd3440a04f310b6727d2cf48c056ac3049266e870f046ba9116064736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208d58afd4704cdd3440a04f310b6727d2cf48c056ac3049266e870f046ba9116064736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"33386:4971:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;33386:4971:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"33386:4971:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"HEADER_OFFSET":{"details":"This value reflects the header offset in the latest message version"},"MESSAGE_VERSION":{"details":"This is only updated if the whole message structure is changed,      i.e. if a new part is added.      If already existing part is changed, the message version does not get bumped."},"TWO_BYTES":{"details":"How much bytes is used for storing the version, or a single offset value"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"HEADER_OFFSET\":{\"details\":\"This value reflects the header offset in the latest message version\"},\"MESSAGE_VERSION\":{\"details\":\"This is only updated if the whole message structure is changed,      i.e. if a new part is added.      If already existing part is changed, the message version does not get bumped.\"},\"TWO_BYTES\":{\"details\":\"How much bytes is used for storing the version, or a single offset value\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"Message\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xf6e9ee713825afa2c227d061dae76dd824f85b31a15d838206a967b23353a673\",\"urls\":[\"bzz-raw://f061a04f570408bbb7590e9a719fd5dc59069f4a04f4a1ba4b38c17dc82abdfd\",\"dweb:/ipfs/QmV8VVt3ExGtCwjLr2tEjVRD6VbeKK1hPvtY8PPy8QNg8E\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.sol:MessageHarness":{"code":"0x608060405234801561001057600080fd5b50611742806100206000396000f3fe608060405234801561001057600080fd5b50600436106100d45760003560e01c8063985a5c3111610081578063cb3eb0e11161005b578063cb3eb0e1146101bd578063d7a7a72c146101d0578063f45387ba146101e357600080fd5b8063985a5c3114610184578063c81aa9c814610197578063c97c703a146101aa57600080fd5b80636dc3c4f7116100b25780636dc3c4f71461014b5780637c1cfff91461015e5780637c5178251461017157600080fd5b8063045c6c0b146100d957806346fad66e146101025780634e76500414610123575b600080fd5b6100ec6100e7366004611260565b61021b565b6040516100f9919061130f565b60405180910390f35b61011561011036600461133b565b610248565b6040519081526020016100f9565b610136610131366004611260565b6102f7565b60405163ffffffff90911681526020016100f9565b610115610159366004611260565b61031e565b61013661016c366004611260565b61033a565b6100ec61017f36600461133b565b610356565b610115610192366004611260565b6103f7565b6101366101a5366004611260565b610413565b6100ec6101b8366004611260565b61042f565b6101366101cb366004611260565b61044b565b6101156101de366004611260565b610467565b6101f66101f1366004611260565b610480565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f9565b606061024261023761022c8461049c565b62ffffff19166104aa565b62ffffff19166104ea565b92915050565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffff0000000000000000000000000000000000000000000000000000000060e08b811b82166022840152602683018b905289811b8216604684015288811b8216604a840152604e830188905286901b16606e8201528151808203605201815260729091019091526000906102e981858561053d565b9a9950505050505050505050565b60006102426103136103088461049c565b62ffffff191661055b565b62ffffff1916610592565b600061024261032f6103088461049c565b62ffffff19166105bc565b600061024261034b6103088461049c565b62ffffff19166105dd565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffff0000000000000000000000000000000000000000000000000000000060e08b811b82166022840152602683018b905289811b8216604684015288811b8216604a840152604e830188905286901b16606e8201528151808203605201815260729091019091526060906102e98185856105fe565b60006102426104086103088461049c565b62ffffff1916610678565b60006102426104246103088461049c565b62ffffff1916610699565b60606102426102376104408461049c565b62ffffff19166106ba565b600061024261045c6103088461049c565b62ffffff19166106f9565b60006102426104758361049c565b62ffffff191661071a565b60006102426104916103088461049c565b62ffffff191661073f565b600061024282610539610750565b6000816104bf62ffffff198216610539610774565b506104e1836104cf856002610898565b6104da866003610898565b60026108ca565b91505b50919050565b60606000806105078460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050604051915081925061052c84836020016108f4565b508181016020016040529052919050565b600061054a8484846105fe565b8051906020012090505b9392505050565b60008161057062ffffff198216610539610774565b506104e183610580856001610898565b61058b866002610898565b60016108ca565b6000816105a860015b62ffffff19831690610774565b506104e162ffffff19841660266004610acd565b6000816105c9600161059b565b506104e162ffffff19841660066020610afd565b6000816105ea600161059b565b506104e162ffffff198416604e6004610acd565b825160609060009061061260046002611453565b60ff1661061f919061147c565b90506000845182610630919061147c565b9050600161064060046002611453565b60ff16838389898960405160200161065e97969594939291906114a2565b604051602081830303815290604052925050509392505050565b600081610685600161059b565b506104e162ffffff198416602e6020610afd565b6000816106a6600161059b565b506104e162ffffff198416602a6004610acd565b6000816106cf62ffffff198216610539610774565b506104e1836106df856003610898565b601886901c6bffffffffffffffffffffffff1660036108ca565b600081610706600161059b565b506104e162ffffff19841660026004610acd565b60008161072f62ffffff198216610539610774565b506104e162ffffff198416610cef565b600061024261074d83610678565b90565b81516000906020840161076b64ffffffffff85168284610d4c565b95945050505050565b60006107808383610d93565b61089157600061079f6107938560d81c90565b64ffffffffff16610db6565b91505060006107b48464ffffffffff16610db6565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610888919061130f565b60405180910390fd5b5090919050565b600061055460028360048111156108b1576108b16113f5565b6108bb9190611540565b62ffffff198516906002610acd565b60006108e9846108da818661157d565b62ffffff198816919085610ea0565b90505b949350505050565b600062ffffff198084160361098b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f54797065644d656d566965772f636f7079546f202d204e756c6c20706f696e7460448201527f65722064657265660000000000000000000000000000000000000000000000006064820152608401610888565b61099483610f1a565b610a20576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f54797065644d656d566965772f636f7079546f202d20496e76616c696420706f60448201527f696e7465722064657265660000000000000000000000000000000000000000006064820152608401610888565b6000610a3a8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610a648560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000604051905084811115610a895760206060fd5b8285848460045afa50610ac3610a9f8760d81c90565b70ffffffffff000000000000000000000000606091821b168717901b841760181b90565b9695505050505050565b6000610ada826020611594565b610ae5906008611453565b60ff16610af3858585610afd565b901c949350505050565b60008160ff16600003610b1257506000610554565b610b2a8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610b4560ff8416856115b7565b1115610bd757610ba4610b668560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610b8c8660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16610f57565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610888919061130f565b60208260ff161115610c6b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e2033322062797465730000000000006064820152608401610888565b600882026000610c898660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b600080610d0a8360781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610d348460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169091209392505050565b600080610d5983856115b7565b9050604051811115610d69575060005b80600003610d7e5762ffffff19915050610554565b5050606092831b9190911790911b1760181b90565b60008164ffffffffff16610da78460d81c90565b64ffffffffff16149392505050565b600080601f5b600f8160ff161115610e29576000610dd5826008611453565b60ff1685901c9050610de681610fc5565b61ffff16841793508160ff16601014610e0157601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610dbc565b50600f5b60ff8160ff161015610e9a576000610e46826008611453565b60ff1685901c9050610e5781610fc5565b61ffff16831792508160ff16600014610e7257601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610e2d565b50915091565b600080610ebb8660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050610ed486610ff7565b84610edf87846115b7565b610ee991906115b7565b1115610efc5762ffffff199150506108ec565b610f0685826115b7565b9050610ac38364ffffffffff168286610d4c565b6000610f268260d81c90565b64ffffffffff1664ffffffffff03610f4057506000919050565b6000610f4b83610ff7565b60405110199392505050565b60606000610f6486610db6565b9150506000610f7286610db6565b9150506000610f8086610db6565b9150506000610f8e86610db6565b91505083838383604051602001610fa894939291906115cf565b604051602081830303815290604052945050505050949350505050565b6000610fd760048360ff16901c61103f565b60ff1661ffff919091161760081b610fee8261103f565b60ff1617919050565b60006110118260181c6bffffffffffffffffffffffff1690565b6110298360781c6bffffffffffffffffffffffff1690565b016bffffffffffffffffffffffff169050919050565b600060f08083179060ff8216900361105a5750603092915050565b8060ff1660f10361106e5750603192915050565b8060ff1660f2036110825750603292915050565b8060ff1660f3036110965750603392915050565b8060ff1660f4036110aa5750603492915050565b8060ff1660f5036110be5750603592915050565b8060ff1660f6036110d25750603692915050565b8060ff1660f7036110e65750603792915050565b8060ff1660f8036110fa5750603892915050565b8060ff1660f90361110e5750603992915050565b8060ff1660fa036111225750606192915050565b8060ff1660fb036111365750606292915050565b8060ff1660fc0361114a5750606392915050565b8060ff1660fd0361115e5750606492915050565b8060ff1660fe036111725750606592915050565b8060ff1660ff036104e45750606692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126111c657600080fd5b813567ffffffffffffffff808211156111e1576111e1611186565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561122757611227611186565b8160405283815286602085880101111561124057600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561127257600080fd5b813567ffffffffffffffff81111561128957600080fd5b6108ec848285016111b5565b60005b838110156112b0578181015183820152602001611298565b838111156112bf576000848401525b50505050565b600081518084526112dd816020860160208601611295565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60208152600061055460208301846112c5565b803563ffffffff8116811461133657600080fd5b919050565b600080600080600080600080610100898b03121561135857600080fd5b61136189611322565b97506020890135965061137660408a01611322565b955061138460608a01611322565b94506080890135935061139960a08a01611322565b925060c089013567ffffffffffffffff808211156113b657600080fd5b6113c28c838d016111b5565b935060e08b01359150808211156113d857600080fd5b506113e58b828c016111b5565b9150509295985092959890939650565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600060ff821660ff84168160ff048111821515161561147457611474611424565b029392505050565b600061ffff80831681851680830382111561149957611499611424565b01949350505050565b60007fffff000000000000000000000000000000000000000000000000000000000000808a60f01b168352808960f01b166002840152808860f01b166004840152808760f01b166006840152508451611502816008850160208901611295565b845190830190611519816008840160208901611295565b845191019061152f816008840160208801611295565b016008019998505050505050505050565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561157857611578611424565b500290565b60008282101561158f5761158f611424565b500390565b600060ff821660ff8416808210156115ae576115ae611424565b90039392505050565b600082198211156115ca576115ca611424565b500190565b7f54797065644d656d566965772f696e646578202d204f76657272616e2074686581527f20766965772e20536c696365206973206174203078000000000000000000000060208201527fffffffffffff000000000000000000000000000000000000000000000000000060d086811b821660358401527f2077697468206c656e6774682030780000000000000000000000000000000000603b840181905286821b8316604a8501527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060508501527f7800000000000000000000000000000000000000000000000000000000000000607085015285821b83166071850152607784015283901b1660868201527f2e00000000000000000000000000000000000000000000000000000000000000608c8201526000608d8201610ac356fea264697066735822122091a8f3707296d120f4c00eef1ddbd608a08744cf35154a101a76438fcd3c18b064736f6c634300080d0033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100d45760003560e01c8063985a5c3111610081578063cb3eb0e11161005b578063cb3eb0e1146101bd578063d7a7a72c146101d0578063f45387ba146101e357600080fd5b8063985a5c3114610184578063c81aa9c814610197578063c97c703a146101aa57600080fd5b80636dc3c4f7116100b25780636dc3c4f71461014b5780637c1cfff91461015e5780637c5178251461017157600080fd5b8063045c6c0b146100d957806346fad66e146101025780634e76500414610123575b600080fd5b6100ec6100e7366004611260565b61021b565b6040516100f9919061130f565b60405180910390f35b61011561011036600461133b565b610248565b6040519081526020016100f9565b610136610131366004611260565b6102f7565b60405163ffffffff90911681526020016100f9565b610115610159366004611260565b61031e565b61013661016c366004611260565b61033a565b6100ec61017f36600461133b565b610356565b610115610192366004611260565b6103f7565b6101366101a5366004611260565b610413565b6100ec6101b8366004611260565b61042f565b6101366101cb366004611260565b61044b565b6101156101de366004611260565b610467565b6101f66101f1366004611260565b610480565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100f9565b606061024261023761022c8461049c565b62ffffff19166104aa565b62ffffff19166104ea565b92915050565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffff0000000000000000000000000000000000000000000000000000000060e08b811b82166022840152602683018b905289811b8216604684015288811b8216604a840152604e830188905286901b16606e8201528151808203605201815260729091019091526000906102e981858561053d565b9a9950505050505050505050565b60006102426103136103088461049c565b62ffffff191661055b565b62ffffff1916610592565b600061024261032f6103088461049c565b62ffffff19166105bc565b600061024261034b6103088461049c565b62ffffff19166105dd565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffff0000000000000000000000000000000000000000000000000000000060e08b811b82166022840152602683018b905289811b8216604684015288811b8216604a840152604e830188905286901b16606e8201528151808203605201815260729091019091526060906102e98185856105fe565b60006102426104086103088461049c565b62ffffff1916610678565b60006102426104246103088461049c565b62ffffff1916610699565b60606102426102376104408461049c565b62ffffff19166106ba565b600061024261045c6103088461049c565b62ffffff19166106f9565b60006102426104758361049c565b62ffffff191661071a565b60006102426104916103088461049c565b62ffffff191661073f565b600061024282610539610750565b6000816104bf62ffffff198216610539610774565b506104e1836104cf856002610898565b6104da866003610898565b60026108ca565b91505b50919050565b60606000806105078460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050604051915081925061052c84836020016108f4565b508181016020016040529052919050565b600061054a8484846105fe565b8051906020012090505b9392505050565b60008161057062ffffff198216610539610774565b506104e183610580856001610898565b61058b866002610898565b60016108ca565b6000816105a860015b62ffffff19831690610774565b506104e162ffffff19841660266004610acd565b6000816105c9600161059b565b506104e162ffffff19841660066020610afd565b6000816105ea600161059b565b506104e162ffffff198416604e6004610acd565b825160609060009061061260046002611453565b60ff1661061f919061147c565b90506000845182610630919061147c565b9050600161064060046002611453565b60ff16838389898960405160200161065e97969594939291906114a2565b604051602081830303815290604052925050509392505050565b600081610685600161059b565b506104e162ffffff198416602e6020610afd565b6000816106a6600161059b565b506104e162ffffff198416602a6004610acd565b6000816106cf62ffffff198216610539610774565b506104e1836106df856003610898565b601886901c6bffffffffffffffffffffffff1660036108ca565b600081610706600161059b565b506104e162ffffff19841660026004610acd565b60008161072f62ffffff198216610539610774565b506104e162ffffff198416610cef565b600061024261074d83610678565b90565b81516000906020840161076b64ffffffffff85168284610d4c565b95945050505050565b60006107808383610d93565b61089157600061079f6107938560d81c90565b64ffffffffff16610db6565b91505060006107b48464ffffffffff16610db6565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610888919061130f565b60405180910390fd5b5090919050565b600061055460028360048111156108b1576108b16113f5565b6108bb9190611540565b62ffffff198516906002610acd565b60006108e9846108da818661157d565b62ffffff198816919085610ea0565b90505b949350505050565b600062ffffff198084160361098b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f54797065644d656d566965772f636f7079546f202d204e756c6c20706f696e7460448201527f65722064657265660000000000000000000000000000000000000000000000006064820152608401610888565b61099483610f1a565b610a20576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f54797065644d656d566965772f636f7079546f202d20496e76616c696420706f60448201527f696e7465722064657265660000000000000000000000000000000000000000006064820152608401610888565b6000610a3a8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610a648560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000604051905084811115610a895760206060fd5b8285848460045afa50610ac3610a9f8760d81c90565b70ffffffffff000000000000000000000000606091821b168717901b841760181b90565b9695505050505050565b6000610ada826020611594565b610ae5906008611453565b60ff16610af3858585610afd565b901c949350505050565b60008160ff16600003610b1257506000610554565b610b2a8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610b4560ff8416856115b7565b1115610bd757610ba4610b668560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610b8c8660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff16610f57565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610888919061130f565b60208260ff161115610c6b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e2033322062797465730000000000006064820152608401610888565b600882026000610c898660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b600080610d0a8360781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610d348460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169091209392505050565b600080610d5983856115b7565b9050604051811115610d69575060005b80600003610d7e5762ffffff19915050610554565b5050606092831b9190911790911b1760181b90565b60008164ffffffffff16610da78460d81c90565b64ffffffffff16149392505050565b600080601f5b600f8160ff161115610e29576000610dd5826008611453565b60ff1685901c9050610de681610fc5565b61ffff16841793508160ff16601014610e0157601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610dbc565b50600f5b60ff8160ff161015610e9a576000610e46826008611453565b60ff1685901c9050610e5781610fc5565b61ffff16831792508160ff16600014610e7257601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610e2d565b50915091565b600080610ebb8660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050610ed486610ff7565b84610edf87846115b7565b610ee991906115b7565b1115610efc5762ffffff199150506108ec565b610f0685826115b7565b9050610ac38364ffffffffff168286610d4c565b6000610f268260d81c90565b64ffffffffff1664ffffffffff03610f4057506000919050565b6000610f4b83610ff7565b60405110199392505050565b60606000610f6486610db6565b9150506000610f7286610db6565b9150506000610f8086610db6565b9150506000610f8e86610db6565b91505083838383604051602001610fa894939291906115cf565b604051602081830303815290604052945050505050949350505050565b6000610fd760048360ff16901c61103f565b60ff1661ffff919091161760081b610fee8261103f565b60ff1617919050565b60006110118260181c6bffffffffffffffffffffffff1690565b6110298360781c6bffffffffffffffffffffffff1690565b016bffffffffffffffffffffffff169050919050565b600060f08083179060ff8216900361105a5750603092915050565b8060ff1660f10361106e5750603192915050565b8060ff1660f2036110825750603292915050565b8060ff1660f3036110965750603392915050565b8060ff1660f4036110aa5750603492915050565b8060ff1660f5036110be5750603592915050565b8060ff1660f6036110d25750603692915050565b8060ff1660f7036110e65750603792915050565b8060ff1660f8036110fa5750603892915050565b8060ff1660f90361110e5750603992915050565b8060ff1660fa036111225750606192915050565b8060ff1660fb036111365750606292915050565b8060ff1660fc0361114a5750606392915050565b8060ff1660fd0361115e5750606492915050565b8060ff1660fe036111725750606592915050565b8060ff1660ff036104e45750606692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126111c657600080fd5b813567ffffffffffffffff808211156111e1576111e1611186565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561122757611227611186565b8160405283815286602085880101111561124057600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561127257600080fd5b813567ffffffffffffffff81111561128957600080fd5b6108ec848285016111b5565b60005b838110156112b0578181015183820152602001611298565b838111156112bf576000848401525b50505050565b600081518084526112dd816020860160208601611295565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b60208152600061055460208301846112c5565b803563ffffffff8116811461133657600080fd5b919050565b600080600080600080600080610100898b03121561135857600080fd5b61136189611322565b97506020890135965061137660408a01611322565b955061138460608a01611322565b94506080890135935061139960a08a01611322565b925060c089013567ffffffffffffffff808211156113b657600080fd5b6113c28c838d016111b5565b935060e08b01359150808211156113d857600080fd5b506113e58b828c016111b5565b9150509295985092959890939650565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600060ff821660ff84168160ff048111821515161561147457611474611424565b029392505050565b600061ffff80831681851680830382111561149957611499611424565b01949350505050565b60007fffff000000000000000000000000000000000000000000000000000000000000808a60f01b168352808960f01b166002840152808860f01b166004840152808760f01b166006840152508451611502816008850160208901611295565b845190830190611519816008840160208901611295565b845191019061152f816008840160208801611295565b016008019998505050505050505050565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561157857611578611424565b500290565b60008282101561158f5761158f611424565b500390565b600060ff821660ff8416808210156115ae576115ae611424565b90039392505050565b600082198211156115ca576115ca611424565b500190565b7f54797065644d656d566965772f696e646578202d204f76657272616e2074686581527f20766965772e20536c696365206973206174203078000000000000000000000060208201527fffffffffffff000000000000000000000000000000000000000000000000000060d086811b821660358401527f2077697468206c656e6774682030780000000000000000000000000000000000603b840181905286821b8316604a8501527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060508501527f7800000000000000000000000000000000000000000000000000000000000000607085015285821b83166071850152607784015283901b1660868201527f2e00000000000000000000000000000000000000000000000000000000000000608c8201526000608d8201610ac356fea264697066735822122091a8f3707296d120f4c00eef1ddbd608a08744cf35154a101a76438fcd3c18b064736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"41662:3223:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"41662:3223:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;43440:135;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;42885:549;;;;;;:::i;:::-;;:::i;:::-;;;3403:25:1;;;3391:2;3376:18;42885:549:0;3257:177:1;44003:132:0;;;;;;:::i;:::-;;:::i;:::-;;;3613:10:1;3601:23;;;3583:42;;3571:2;3556:18;44003:132:0;3439:192:1;43862:135:0;;;;;;:::i;:::-;;:::i;44599:156::-;;;;;;:::i;:::-;;:::i;41819:596::-;;;;;;:::i;:::-;;:::i;44291:141::-;;;;;;:::i;:::-;;:::i;44141:144::-;;;;;;:::i;:::-;;:::i;43581:135::-;;;;;;:::i;:::-;;:::i;43722:134::-;;;;;;:::i;:::-;;:::i;44761:122::-;;;;;;:::i;:::-;;:::i;44438:155::-;;;;;;:::i;:::-;;:::i;:::-;;;3812:42:1;3800:55;;;3782:74;;3770:2;3755:18;44438:155:0;3636:226:1;43440:135:0;43500:12;43531:37;:29;:22;:8;:20;:22::i;:::-;-1:-1:-1;;43531:27:0;;:29::i;:::-;-1:-1:-1;;43531:35:0;;:37::i;:::-;43524:44;43440:135;-1:-1:-1;;43440:135:0:o;42885:549::-;39638:242;;;4359:16:1;39638:242:0;;;4343:102:1;4464:66;4567:3;4563:16;;;4559:25;;4546:11;;;4539:46;4601:11;;;4594:27;;;4655:16;;;4651:25;;4637:12;;;4630:47;4711:16;;;4707:25;;4693:12;;;4686:47;4749:12;;;4742:28;;;4804:16;;;4800:25;4786:12;;;4779:47;39638:242:0;;;;;;;;;4842:12:1;;;;39638:242:0;;;43153:7;;43385:42;43405:7;43414:5;43421;43385:19;:42::i;:::-;43378:49;42885:549;-1:-1:-1;;;;;;;;;;42885:549:0:o;44003:132::-;44064:6;44089:39;:31;:22;:8;:20;:22::i;:::-;-1:-1:-1;;44089:29:0;;:31::i;:::-;-1:-1:-1;;44089:37:0;;:39::i;43862:135::-;43924:7;43950:40;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;43950:38:0;;:40::i;44599:156::-;44672:6;44697:51;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;44697:49:0;;:51::i;41819:596::-;39638:242;;;4359:16:1;39638:242:0;;;4343:102:1;4464:66;4567:3;4563:16;;;4559:25;;4546:11;;;4539:46;4601:11;;;4594:27;;;4655:16;;;4651:25;;4637:12;;;4630:47;4711:16;;;4707:25;;4693:12;;;4686:47;4749:12;;;4742:28;;;4804:16;;;4800:25;4786:12;;;4779:47;39638:242:0;;;;;;;;;4842:12:1;;;;39638:242:0;;;42108:12;;42357:51;42379:7;42388:5;42395:12;42357:21;:51::i;44291:141::-;44356:7;44382:43;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;44382:41:0;;:43::i;44141:144::-;44208:6;44233:45;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;44233:43:0;;:45::i;43581:135::-;43641:12;43672:37;:29;:22;:8;:20;:22::i;:::-;-1:-1:-1;;43672:27:0;;:29::i;43722:134::-;43784:6;43809:40;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;43809:38:0;;:40::i;44761:122::-;44821:7;44847:29;:22;:8;:20;:22::i;:::-;-1:-1:-1;;44847:27:0;;:29::i;44438:155::-;44510:7;44536:50;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;44536:48:0;;:50::i;36381:126::-;36448:7;36474:26;:8;33969:4;36474:12;:26::i;37058:299::-;37135:7;37116:8;34213:30;-1:-1:-1;;34213:16:0;;33969:4;34213:16;:30::i;:::-;;37173:177:::1;37199:8;37225:33;37237:8;37247:10;37225:11;:33::i;:::-;37276;37288:8;37298:10;37276:11;:33::i;:::-;34088:10;37173:8;:177::i;:::-;37154:196;;34253:1;37058:299:::0;;;;:::o;28308:632::-;28363:16;28391:11;28412:12;28427;28431:7;16492:2;16488:16;2670:26;16484:28;;16246:282;28427:12;28412:27;;;;28549:4;28543:11;28536:18;;28604:3;28597:10;;28650:33;28663:7;28672:3;28678:4;28672:10;28650:12;:33::i;:::-;-1:-1:-1;28807:14:0;;;28823:4;28803:25;28797:4;28790:39;28870:17;;28308:632;;-1:-1:-1;28308:632:0:o;36145:230::-;36288:7;36324:43;36338:7;36347:5;36354:12;36324:13;:43::i;:::-;36314:54;;;;;;36307:61;;36145:230;;;;;;:::o;36631:305::-;36710:7;36691:8;34213:30;-1:-1:-1;;34213:16:0;;33969:4;34213:16;:30::i;:::-;;36748:181:::1;36774:8;36800:35;36812:8;36822:12;36800:11;:35::i;:::-;36853:33;36865:8;36875:10;36853:11;:33::i;:::-;34025:12;37173:8;:177::i;40622:149::-:0;40697:6;40679:7;39307:37;34025:12;34018:20;-1:-1:-1;;39307:16:0;;;;:37::i;:::-;-1:-1:-1;40729:34:0::1;-1:-1:-1::0;;40729:17:0;::::1;39086:2;40761:1;40729:17;:34::i;40430:141::-:0;40506:7;40488;39307:37;34025:12;34018:20;;39307:37;-1:-1:-1;40532:32:0::1;-1:-1:-1::0;;40532:13:0;::::1;39039:1;40561:2;40532:13;:32::i;41266:174::-:0;41353:6;41335:7;39307:37;34025:12;34018:20;;39307:37;-1:-1:-1;41385:47:0::1;-1:-1:-1::0;;41385:17:0;::::1;39253:2;41430:1;41385:17;:47::i;35273:638::-:0;35569:14;;35418:12;;35526:17;;35024:29;35042:10;34895:1;35024:29;:::i;:::-;35546:13;;:38;;;;:::i;:::-;35526:58;;35594:17;35634:5;:12;35614:10;:33;;;;:::i;:::-;35594:53;-1:-1:-1;33745:1:0;35024:29;35042:10;34895:1;35024:29;:::i;:::-;35743:13;;35774:10;35802;35830:7;35855:5;35878:12;35676:228;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;35657:247;;;;35273:638;;;;;:::o;41055:147::-;41134:7;41116;39307:37;34025:12;34018:20;;39307:37;-1:-1:-1;41160:35:0::1;-1:-1:-1::0;;41160:13:0;::::1;39192:2;41192;41160:13;:35::i;40828:161::-:0;40909:6;40891:7;39307:37;34025:12;34018:20;;39307:37;-1:-1:-1;40941:40:0::1;-1:-1:-1::0;;40941:17:0;::::1;39140:2;40979:1;40941:17;:40::i;37479:190::-:0;37556:7;37537:8;34213:30;-1:-1:-1;;34213:16:0;;33969:4;34213:16;:30::i;:::-;;37582:80:::1;37591:8;37601:33;37613:8;37623:10;37601:11;:33::i;:::-;16492:2:::0;16488:16;;;2670:26;16484:28;34149:10:::1;37173:8;:177::i;40227:151::-:0;40303:6;40285:7;39307:37;34025:12;34018:20;;39307:37;-1:-1:-1;40335:35:0::1;-1:-1:-1::0;;40335:17:0;::::1;38991:1;40368;40335:17;:35::i;37730:170::-:0;37807:7;37788:8;34213:30;-1:-1:-1;;34213:16:0;;33969:4;34213:16;:30::i;:::-;-1:-1:-1;37876:17:0::1;-1:-1:-1::0;;37876:15:0;::::1;;:17::i;41509:145::-:0;41575:7;41601:46;41628:18;41638:7;41628:9;:18::i;:::-;33368:4;33255:127;13655:359;13759:10;;13725:7;;13906:4;13897:14;;13981:26;;;;13897:14;13759:10;13981:5;:26::i;:::-;13974:33;13655:359;-1:-1:-1;;;;;13655:359:0:o;10073:578::-;10151:7;10175:26;10182:7;10191:9;10175:6;:26::i;:::-;10170:451;;10220:9;10233:35;10251:15;10258:7;14417:3;14413:17;;14206:268;10251:15;10243:24;;10233:9;:35::i;:::-;10217:51;;;10285:9;10298:29;10316:9;10308:18;;10298:9;:29::i;:::-;10385:186;;6971:31:1;10385:186:0;;;6959:44:1;7022:66;7126:3;7122:16;;;7118:25;;7104:12;;;7097:47;7174:15;7160:12;;;7153:37;7224:16;;;7220:25;7206:12;;;7199:47;10282:45:0;;-1:-1:-1;10341:17:0;;-1:-1:-1;7262:12:1;;10385:186:0;;;;;;;;;;;;10341:244;;10606:3;10599:11;;;;;;;;;;;:::i;:::-;;;;;;;;10170:451;-1:-1:-1;10637:7:0;;10073:578;-1:-1:-1;10073:578:0:o;38191:164::-;38265:7;38291:57;34895:1;38318:5;38310:14;;;;;;;;:::i;:::-;:26;;;;:::i;:::-;-1:-1:-1;;38291:18:0;;;34895:1;38291:18;:57::i;37906:218::-;38047:7;38073:44;38088:5;38095:11;38088:5;38095:3;:11;:::i;:::-;-1:-1:-1;;38073:14:0;;;:44;38108:8;38073:14;:44::i;:::-;38066:51;;37906:218;;;;;;;:::o;27036:902::-;27114:15;-1:-1:-1;;7972:15:0;;;;27141:69;;;;;;;8074:2:1;27141:69:0;;;8056:21:1;8113:2;8093:18;;;8086:30;8152:34;8132:18;;;8125:62;8223:10;8203:18;;;8196:38;8251:19;;27141:69:0;7872:404:1;27141:69:0;27228:16;27236:7;27228;:16::i;:::-;27220:72;;;;;;;8483:2:1;27220:72:0;;;8465:21:1;8522:2;8502:18;;;8495:30;8561:34;8541:18;;;8534:62;8632:13;8612:18;;;8605:41;8663:19;;27220:72:0;8281:407:1;27220:72:0;27302:12;27317;27321:7;16492:2;16488:16;2670:26;16484:28;;16246:282;27317:12;27302:27;;;;27339:15;27357:12;27361:7;15386:3;15382:17;2670:26;15378:29;;15059:364;27357:12;27339:30;;;;27380:11;27501:4;27495:11;27488:18;;27588:7;27583:3;27580:16;27577:94;;;27628:4;27622;27615:18;27577:94;27843:4;27834:7;27828:4;27819:7;27816:1;27809:5;27798:50;27794:55;27879:52;27900:15;27907:7;14417:3;14413:17;;14206:268;27900:15;12061:27;12065:2;12061:27;;;;12135:17;;12127:26;;12199:17;;12195:2;12191:26;;11811:446;27879:52;27869:62;27036:902;-1:-1:-1;;;;;;27036:902:0:o;21121:221::-;21240:14;21318:11;21323:6;21318:2;:11;:::i;:::-;21317:17;;21333:1;21317:17;:::i;:::-;21273:62;;21281:30;21287:7;21296:6;21304;21281:5;:30::i;:::-;21273:62;;;21121:221;-1:-1:-1;;;;21121:221:0:o;20004:771::-;20119:14;20149:6;:11;;20159:1;20149:11;20145:59;;-1:-1:-1;20191:1:0;20176:17;;20145:59;20235:12;20239:7;16492:2;16488:16;2670:26;16484:28;;16246:282;20235:12;20217:30;;:15;;;;:6;:15;:::i;:::-;:30;20213:137;;;20270:68;20286:12;20290:7;15386:3;15382:17;2670:26;15378:29;;15059:364;20286:12;20270:68;;20300:12;20304:7;16492:2;16488:16;2670:26;16484:28;;16246:282;20300:12;20270:68;;20314:6;20330;20322:15;;20270;:68::i;:::-;20263:76;;;;;;;;;;;:::i;20213:137::-;20377:2;20367:6;:12;;;;20359:83;;;;;;;9228:2:1;20359:83:0;;;9210:21:1;9267:2;9247:18;;;9240:30;9306:34;9286:18;;;9279:62;9377:28;9357:18;;;9350:56;9423:19;;20359:83:0;9026:422:1;20359:83:0;20523:1;20514:10;;20453:15;20559:12;20563:7;15386:3;15382:17;2670:26;15378:29;;15059:364;20559:12;20544:27;;;-1:-1:-1;20581:13:0;7488:66;7458:12;;;7437:131;20733:17;;;;20727:24;20723:36;;;-1:-1:-1;;;;;20004:771:0:o;22455:290::-;22511:14;22537:12;22552;22556:7;15386:3;15382:17;2670:26;15378:29;;15059:364;22552:12;22537:27;;;;22574:12;22589;22593:7;16492:2;16488:16;2670:26;16484:28;;16246:282;22589:12;22574:27;;22708:21;;;;22455:290;-1:-1:-1;;;22455:290:0:o;12796:462::-;12907:15;;12949:11;12956:4;12949;:11;:::i;:::-;12934:26;;13075:4;13069:11;13063:4;13060:21;13057:66;;;-1:-1:-1;13108:1:0;13057:66;13146:4;13154:1;13146:9;13142:51;;-1:-1:-1;;13171:11:0;;;;;13142:51;-1:-1:-1;;12065:2:0;12061:27;;;12135:17;;;;12127:26;;;12199:17;12195:2;12191:26;;12796:462::o;9643:132::-;9717:4;9759:9;9740:28;;:15;9747:7;14417:3;14413:17;;14206:268;9740:15;:28;;;;9643:132;-1:-1:-1;;;9643:132:0:o;5031:667::-;5085:13;;5141:2;5126:258;5149:2;5145:1;:6;;;5126:258;;;5169:11;5196:5;:1;5200;5196:5;:::i;:::-;5189:13;;:2;:13;;5169:34;;5226:14;5234:5;5226:7;:14::i;:::-;5217:23;;;;;;5258:1;:7;;5263:2;5258:7;5254:58;;5295:2;5285:12;;;;;5254:58;-1:-1:-1;5353:6:0;;5126:258;;;-1:-1:-1;5447:2:0;5432:260;5455:3;5451:1;:7;;;5432:260;;;5476:11;5503:5;:1;5507;5503:5;:::i;:::-;5496:13;;:2;:13;;5476:34;;5534:14;5542:5;5534:7;:14::i;:::-;5524:24;;;;;;5566:1;:6;;5571:1;5566:6;5562:58;;5603:2;5592:13;;;;;5562:58;-1:-1:-1;5661:6:0;;5432:260;;;;5031:667;;;:::o;17129:399::-;17268:7;17287:12;17302;17306:7;15386:3;15382:17;2670:26;15378:29;;15059:364;17302:12;17287:27;;;;17398:12;17402:7;17398:3;:12::i;:::-;17391:4;17375:13;17382:6;17375:4;:13;:::i;:::-;:20;;;;:::i;:::-;:35;17371:77;;;-1:-1:-1;;17426:11:0;;;;;17371:77;17465:13;17472:6;17465:4;:13;:::i;:::-;17458:20;;17495:26;17501:7;17495:26;;17510:4;17516;17495:5;:26::i;8645:333::-;8702:8;8726:15;8733:7;14417:3;14413:17;;14206:268;8726:15;:31;;8745:12;8726:31;8722:74;;-1:-1:-1;8780:5:0;;8645:333;-1:-1:-1;8645:333:0:o;8722:74::-;8805:12;8820;8824:7;8820:3;:12::i;:::-;8955:4;8949:11;-1:-1:-1;8936:26:0;;8645:333;-1:-1:-1;;;8645:333:0:o;18761:741::-;18907:17;18939:9;18952:15;18962:4;18952:9;:15::i;:::-;18936:31;;;18980:9;18993:15;19003:4;18993:9;:15::i;:::-;18977:31;;;19021:9;19034:17;19044:6;19034:9;:17::i;:::-;19018:33;;;19064:9;19077:17;19087:6;19077:9;:17::i;:::-;19061:33;;;19244:1;19306;19386;19448;19130:355;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;19104:391;;18926:576;;;;18761:741;;;;;;:::o;4508:199::-;4558:14;4595:18;4611:1;4605:2;:7;;;;4595:9;:18::i;:::-;4584:29;;4637:13;;;;;;4649:1;4637:13;4671;4681:2;4671:9;:13::i;:::-;4660:24;;;;4508:199;-1:-1:-1;4508:199:0:o;16702:147::-;16755:7;16820:12;16824:7;16492:2;16488:16;2670:26;16484:28;;16246:282;16820:12;16805;16809:7;15386:3;15382:17;2670:26;15378:29;;15059:364;16805:12;:27;16798:34;;;;16702:147;;;:::o;2943:1393::-;2995:10;3161:4;3156:9;;;;3207:15;;;;;3203:57;;-1:-1:-1;3245:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3203:57::-;3278:7;:15;;3289:4;3278:15;3274:57;;-1:-1:-1;3316:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3274:57::-;3349:7;:15;;3360:4;3349:15;3345:57;;-1:-1:-1;3387:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3345:57::-;3420:7;:15;;3431:4;3420:15;3416:57;;-1:-1:-1;3458:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3416:57::-;3491:7;:15;;3502:4;3491:15;3487:57;;-1:-1:-1;3529:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3487:57::-;3562:7;:15;;3573:4;3562:15;3558:57;;-1:-1:-1;3600:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3558:57::-;3633:7;:15;;3644:4;3633:15;3629:57;;-1:-1:-1;3671:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3629:57::-;3704:7;:15;;3715:4;3704:15;3700:57;;-1:-1:-1;3742:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3700:57::-;3775:7;:15;;3786:4;3775:15;3771:57;;-1:-1:-1;3813:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3771:57::-;3846:7;:15;;3857:4;3846:15;3842:57;;-1:-1:-1;3884:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3842:57::-;3917:7;:15;;3928:4;3917:15;3913:57;;-1:-1:-1;3955:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3913:57::-;3988:7;:15;;3999:4;3988:15;3984:57;;-1:-1:-1;4026:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3984:57::-;4059:7;:15;;4070:4;4059:15;4055:57;;-1:-1:-1;4097:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4055:57::-;4130:7;:15;;4141:4;4130:15;4126:57;;-1:-1:-1;4168:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4126:57::-;4201:7;:15;;4212:4;4201:15;4197:57;;-1:-1:-1;4239:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4197:57::-;4272:7;:15;;4283:4;4272:15;4268:57;;-1:-1:-1;4310:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:320::-;1053:6;1106:2;1094:9;1085:7;1081:23;1077:32;1074:52;;;1122:1;1119;1112:12;1074:52;1162:9;1149:23;1195:18;1187:6;1184:30;1181:50;;;1227:1;1224;1217:12;1181:50;1250:49;1291:7;1282:6;1271:9;1267:22;1250:49;:::i;1310:258::-;1382:1;1392:113;1406:6;1403:1;1400:13;1392:113;;;1482:11;;;1476:18;1463:11;;;1456:39;1428:2;1421:10;1392:113;;;1523:6;1520:1;1517:13;1514:48;;;1558:1;1549:6;1544:3;1540:16;1533:27;1514:48;;1310:258;;;:::o;1573:316::-;1614:3;1652:5;1646:12;1679:6;1674:3;1667:19;1695:63;1751:6;1744:4;1739:3;1735:14;1728:4;1721:5;1717:16;1695:63;:::i;:::-;1803:2;1791:15;1808:66;1787:88;1778:98;;;;1878:4;1774:109;;1573:316;-1:-1:-1;;1573:316:1:o;1894:217::-;2041:2;2030:9;2023:21;2004:4;2061:44;2101:2;2090:9;2086:18;2078:6;2061:44;:::i;2116:163::-;2183:20;;2243:10;2232:22;;2222:33;;2212:61;;2269:1;2266;2259:12;2212:61;2116:163;;;:::o;2284:968::-;2420:6;2428;2436;2444;2452;2460;2468;2476;2529:3;2517:9;2508:7;2504:23;2500:33;2497:53;;;2546:1;2543;2536:12;2497:53;2569:28;2587:9;2569:28;:::i;:::-;2559:38;;2644:2;2633:9;2629:18;2616:32;2606:42;;2667:37;2700:2;2689:9;2685:18;2667:37;:::i;:::-;2657:47;;2723:37;2756:2;2745:9;2741:18;2723:37;:::i;:::-;2713:47;;2807:3;2796:9;2792:19;2779:33;2769:43;;2831:38;2864:3;2853:9;2849:19;2831:38;:::i;:::-;2821:48;;2920:3;2909:9;2905:19;2892:33;2944:18;2985:2;2977:6;2974:14;2971:34;;;3001:1;2998;2991:12;2971:34;3024:49;3065:7;3056:6;3045:9;3041:22;3024:49;:::i;:::-;3014:59;;3126:3;3115:9;3111:19;3098:33;3082:49;;3156:2;3146:8;3143:16;3140:36;;;3172:1;3169;3162:12;3140:36;;3195:51;3238:7;3227:8;3216:9;3212:24;3195:51;:::i;:::-;3185:61;;;2284:968;;;;;;;;;;;:::o;3867:184::-;3919:77;3916:1;3909:88;4016:4;4013:1;4006:15;4040:4;4037:1;4030:15;4865:184;4917:77;4914:1;4907:88;5014:4;5011:1;5004:15;5038:4;5035:1;5028:15;5054:238;5092:7;5132:4;5129:1;5125:12;5164:4;5161:1;5157:12;5224:3;5218:4;5214:14;5209:3;5206:23;5199:3;5192:11;5185:19;5181:49;5178:75;;;5233:18;;:::i;:::-;5273:13;;5054:238;-1:-1:-1;;;5054:238:1:o;5297:224::-;5336:3;5364:6;5397:2;5394:1;5390:10;5427:2;5424:1;5420:10;5458:3;5454:2;5450:12;5445:3;5442:21;5439:47;;;5466:18;;:::i;:::-;5502:13;;5297:224;-1:-1:-1;;;;5297:224:1:o;5526:1073::-;5851:3;5879:66;5988:2;5979:6;5974:3;5970:16;5966:25;5961:3;5954:38;6043:2;6034:6;6029:3;6025:16;6021:25;6017:1;6012:3;6008:11;6001:46;6098:2;6089:6;6084:3;6080:16;6076:25;6072:1;6067:3;6063:11;6056:46;6153:2;6144:6;6139:3;6135:16;6131:25;6127:1;6122:3;6118:11;6111:46;;6186:6;6180:13;6202:61;6256:6;6252:1;6247:3;6243:11;6236:4;6228:6;6224:17;6202:61;:::i;:::-;6323:13;;6282:16;;;;6345:62;6323:13;6394:1;6386:10;;6379:4;6367:17;;6345:62;:::i;:::-;6468:13;;6426:17;;;6490:62;6468:13;6539:1;6531:10;;6524:4;6512:17;;6490:62;:::i;:::-;6572:17;6591:1;6568:25;;5526:1073;-1:-1:-1;;;;;;;;;5526:1073:1:o;7509:228::-;7549:7;7675:1;7607:66;7603:74;7600:1;7597:81;7592:1;7585:9;7578:17;7574:105;7571:131;;;7682:18;;:::i;:::-;-1:-1:-1;7722:9:1;;7509:228::o;7742:125::-;7782:4;7810:1;7807;7804:8;7801:34;;;7815:18;;:::i;:::-;-1:-1:-1;7852:9:1;;7742:125::o;8693:195::-;8731:4;8768;8765:1;8761:12;8800:4;8797:1;8793:12;8825:3;8820;8817:12;8814:38;;;8832:18;;:::i;:::-;8869:13;;;8693:195;-1:-1:-1;;;8693:195:1:o;8893:128::-;8933:3;8964:1;8960:6;8957:1;8954:13;8951:39;;;8970:18;;:::i;:::-;-1:-1:-1;9006:9:1;;8893:128::o;9572:1391::-;10294:34;10282:47;;10359:23;10354:2;10345:12;;10338:45;10402:66;10506:3;10502:16;;;10498:25;;10493:2;10484:12;;10477:47;10543:17;10585:2;10576:12;;10569:24;;;10627:16;;;10623:25;;10618:2;10609:12;;10602:47;10679:34;10674:2;10665:12;;10658:56;10745:3;10739;10730:13;;10723:26;10784:16;;;10780:25;;10774:3;10765:13;;10758:48;10831:3;10822:13;;10815:25;10875:16;;;10871:25;10865:3;10856:13;;10849:48;9530:3;10952;10943:13;;9518:16;-1:-1:-1;9550:11:1;;;10913:44;9453:114","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"body","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"destination","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_originDomain","type":"uint32"},{"internalType":"bytes32","name":"_sender","type":"bytes32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"uint32","name":"_destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"_recipient","type":"bytes32"},{"internalType":"uint32","name":"_optimisticSeconds","type":"uint32"},{"internalType":"bytes","name":"_tips","type":"bytes"},{"internalType":"bytes","name":"_messageBody","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"leaf","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"bytes32","name":"_sender","type":"bytes32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"bytes32","name":"_recipient","type":"bytes32"},{"internalType":"uint32","name":"_optimisticSeconds","type":"uint32"},{"internalType":"bytes","name":"_tips","type":"bytes"},{"internalType":"bytes","name":"_body","type":"bytes"}],"name":"messageHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"nonce","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"optimisticSeconds","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"origin","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"recipient","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"recipientAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"sender","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"tips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)":{"notice":"Returns leaf of formatted message with provided fields."}},"version":1},"developerDoc":{"kind":"dev","methods":{"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)":{"params":{"_body":"Raw bytes of message body","_destination":"Domain of destination chain","_nonce":"Destination-specific nonce number","_origin":"Domain of home chain","_recipient":"Address of recipient on destination chain as bytes32","_sender":"Address of sender as bytes32"},"returns":{"_0":"Leaf (hash) of formatted message*"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"body\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"destination\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_originDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_optimisticSeconds\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_tips\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_messageBody\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"leaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_optimisticSeconds\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_tips\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_body\",\"type\":\"bytes\"}],\"name\":\"messageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"optimisticSeconds\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"recipientAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"sender\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"tips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)\":{\"params\":{\"_body\":\"Raw bytes of message body\",\"_destination\":\"Domain of destination chain\",\"_nonce\":\"Destination-specific nonce number\",\"_origin\":\"Domain of home chain\",\"_recipient\":\"Address of recipient on destination chain as bytes32\",\"_sender\":\"Address of sender as bytes32\"},\"returns\":{\"_0\":\"Leaf (hash) of formatted message*\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)\":{\"notice\":\"Returns leaf of formatted message with provided fields.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"MessageHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xf6e9ee713825afa2c227d061dae76dd824f85b31a15d838206a967b23353a673\",\"urls\":[\"bzz-raw://f061a04f570408bbb7590e9a719fd5dc59069f4a04f4a1ba4b38c17dc82abdfd\",\"dweb:/ipfs/QmV8VVt3ExGtCwjLr2tEjVRD6VbeKK1hPvtY8PPy8QNg8E\"]}},\"version\":1}"},"hashes":{"body(bytes)":"c97c703a","destination(bytes)":"c81aa9c8","formatMessage(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)":"7c517825","leaf(bytes)":"d7a7a72c","messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)":"46fad66e","nonce(bytes)":"4e765004","optimisticSeconds(bytes)":"7c1cfff9","origin(bytes)":"cb3eb0e1","recipient(bytes)":"985a5c31","recipientAddress(bytes)":"f45387ba","sender(bytes)":"6dc3c4f7","tips(bytes)":"045c6c0b"}},"solidity/MessageHarness.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220272115c0d3c96e86b1f3a1b79c1d18812f629ad36943b92e2cb880d9130a014f64736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220272115c0d3c96e86b1f3a1b79c1d18812f629ad36943b92e2cb880d9130a014f64736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"32274:1110:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;32274:1110:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"32274:1110:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xf6e9ee713825afa2c227d061dae76dd824f85b31a15d838206a967b23353a673\",\"urls\":[\"bzz-raw://f061a04f570408bbb7590e9a719fd5dc59069f4a04f4a1ba4b38c17dc82abdfd\",\"dweb:/ipfs/QmV8VVt3ExGtCwjLr2tEjVRD6VbeKK1hPvtY8PPy8QNg8E\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.sol:TypedMemView":{"code":"0x60c9610038600b82828239805160001a607314602b57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f26be3fc146038575b600080fd5b605e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000909116815260200160405180910390f3fea2646970667358221220d7745ca3a0dd1dcedb2899b14e00eea6ad2532032fb3c7ffb3294b0043fa0f0864736f6c634300080d0033","runtime-code":"0x730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f26be3fc146038575b600080fd5b605e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000909116815260200160405180910390f3fea2646970667358221220d7745ca3a0dd1dcedb2899b14e00eea6ad2532032fb3c7ffb3294b0043fa0f0864736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 private constant OFFSET_ORIGIN = 2;\n    uint256 private constant OFFSET_SENDER = 6;\n    uint256 private constant OFFSET_NONCE = 38;\n    uint256 private constant OFFSET_DESTINATION = 42;\n    uint256 private constant OFFSET_RECIPIENT = 46;\n    uint256 private constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"26:32242:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;26:32242:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"26:32242:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;2539:94;;;;;;;;198:66:1;186:79;;;168:98;;156:2;141:18;2539:94:0;;;;;;","abiDefinition":[{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xf6e9ee713825afa2c227d061dae76dd824f85b31a15d838206a967b23353a673\",\"urls\":[\"bzz-raw://f061a04f570408bbb7590e9a719fd5dc59069f4a04f4a1ba4b38c17dc82abdfd\",\"dweb:/ipfs/QmV8VVt3ExGtCwjLr2tEjVRD6VbeKK1hPvtY8PPy8QNg8E\"]}},\"version\":1}"},"hashes":{"NULL()":"f26be3fc"}}}