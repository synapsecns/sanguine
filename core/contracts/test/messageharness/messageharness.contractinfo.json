{"solidity/MessageHarness.sol:Header":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c8edaddd1a73e02423359ded235b6369ad4b189b3082f964ab0af5f44ca5d88264736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c8edaddd1a73e02423359ded235b6369ad4b189b3082f964ab0af5f44ca5d88264736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = Tips.formatTips(\n            _updaterTip,\n            _relayerTip,\n            _proverTip,\n            _processorTip\n        );\n\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n\n    function messageVersion() public pure returns (uint16) {\n        return Message.MESSAGE_VERSION;\n    }\n\n    function headerOffset() public pure returns (uint16) {\n        return Message.HEADER_OFFSET;\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"38359:3303:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;38359:3303:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"38359:3303:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_ORIGIN":{"details":"Header memory layout [000 .. 002): version            uint16   2 bytes [002 .. 006): originDomain       uint32   4 bytes [006 .. 038): sender             bytes32 32 bytes [038 .. 042): nonce              uint32   4 bytes [042 .. 046): destinationDomain  uint32   4 bytes [046 .. 078): recipient          bytes32 32 bytes [078 .. 082): optimisticSeconds  uint32   4 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_ORIGIN\":{\"details\":\"Header memory layout [000 .. 002): version            uint16   2 bytes [002 .. 006): originDomain       uint32   4 bytes [006 .. 038): sender             bytes32 32 bytes [038 .. 042): nonce              uint32   4 bytes [042 .. 046): destinationDomain  uint32   4 bytes [046 .. 078): recipient          bytes32 32 bytes [078 .. 082): optimisticSeconds  uint32   4 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"Header\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xd56bf4956dacf8171f3ad4aeb3a5b7d8caa7cbe9e8b69dfc8d9bd876eebd9a72\",\"urls\":[\"bzz-raw://ddfeebc4974db727553a7ca169c2faa33d43beeb304939917f1452adf389c71b\",\"dweb:/ipfs/QmS8RKA433rvBfZwRkF8JkTHbQi5X7a4ArQQo3wcwaTeuj\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.sol:Message":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220cf880a41369369c56329af38ab922b24e58c3510844966fc54314d843c59948764736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220cf880a41369369c56329af38ab922b24e58c3510844966fc54314d843c59948764736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = Tips.formatTips(\n            _updaterTip,\n            _relayerTip,\n            _proverTip,\n            _processorTip\n        );\n\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n\n    function messageVersion() public pure returns (uint16) {\n        return Message.MESSAGE_VERSION;\n    }\n\n    function headerOffset() public pure returns (uint16) {\n        return Message.HEADER_OFFSET;\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"33386:4971:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;33386:4971:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"33386:4971:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"HEADER_OFFSET":{"details":"This value reflects the header offset in the latest message version"},"MESSAGE_VERSION":{"details":"This is only updated if the whole message structure is changed,      i.e. if a new part is added.      If already existing part is changed, the message version does not get bumped."},"TWO_BYTES":{"details":"How much bytes is used for storing the version, or a single offset value"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"HEADER_OFFSET\":{\"details\":\"This value reflects the header offset in the latest message version\"},\"MESSAGE_VERSION\":{\"details\":\"This is only updated if the whole message structure is changed,      i.e. if a new part is added.      If already existing part is changed, the message version does not get bumped.\"},\"TWO_BYTES\":{\"details\":\"How much bytes is used for storing the version, or a single offset value\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"Message\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xd56bf4956dacf8171f3ad4aeb3a5b7d8caa7cbe9e8b69dfc8d9bd876eebd9a72\",\"urls\":[\"bzz-raw://ddfeebc4974db727553a7ca169c2faa33d43beeb304939917f1452adf389c71b\",\"dweb:/ipfs/QmS8RKA433rvBfZwRkF8JkTHbQi5X7a4ArQQo3wcwaTeuj\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.sol:MessageHarness":{"code":"0x608060405234801561001057600080fd5b5061193e806100206000396000f3fe608060405234801561001057600080fd5b50600436106100ea5760003560e01c806381d030ef1161008c578063c97c703a11610066578063c97c703a146101de578063cb3eb0e1146101f1578063d7a7a72c14610204578063f45387ba1461021757600080fd5b806381d030ef146101a5578063985a5c31146101b8578063c81aa9c8146101cb57600080fd5b806352617f3c116100c857806352617f3c14610161578063639c5570146101775780636dc3c4f71461017f5780637c1cfff91461019257600080fd5b8063045c6c0b146100ef57806346fad66e146101185780634e76500414610139575b600080fd5b6101026100fd366004611367565b61024f565b60405161010f9190611416565b60405180910390f35b61012b610126366004611442565b61027c565b60405190815260200161010f565b61014c610147366004611367565b61032b565b60405163ffffffff909116815260200161010f565b60015b60405161ffff909116815260200161010f565b610164610352565b61012b61018d366004611367565b610368565b61014c6101a0366004611367565b610384565b6101026101b3366004611518565b6103a0565b61012b6101c6366004611367565b610477565b61014c6101d9366004611367565b610493565b6101026101ec366004611367565b6104af565b61014c6101ff366004611367565b6104cb565b61012b610212366004611367565b6104e7565b61022a610225366004611367565b610500565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161010f565b606061027661026b6102608461051c565b62ffffff191661052a565b62ffffff191661056a565b92915050565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffff0000000000000000000000000000000000000000000000000000000060e08b811b82166022840152602683018b905289811b8216604684015288811b8216604a840152604e830188905286901b16606e82015281518082036052018152607290910190915260009061031d8185856105bd565b9a9950505050505050505050565b600061027661034761033c8461051c565b62ffffff19166105db565b62ffffff1916610612565b60006103606004600261164f565b60ff16905090565b600061027661037961033c8461051c565b62ffffff191661063c565b600061027661039561033c8461051c565b62ffffff191661065d565b606060006103b08787878761067e565b905060006104588e8e8e8e8e8e604080517e01000000000000000000000000000000000000000000000000000000000000602082015260e097881b7fffffffff000000000000000000000000000000000000000000000000000000009081166022830152602682019790975294871b8616604686015292861b8516604a850152604e84019190915290931b909116606e82015281516052818303018152607290910190915290565b9050610465818386610710565b9e9d5050505050505050505050505050565b600061027661048861033c8461051c565b62ffffff191661078a565b60006102766104a461033c8461051c565b62ffffff19166107ab565b606061027661026b6104c08461051c565b62ffffff19166107cc565b60006102766104dc61033c8461051c565b62ffffff191661080b565b60006102766104f58361051c565b62ffffff191661082c565b600061027661051161033c8461051c565b62ffffff1916610851565b600061027682610539610862565b60008161053f62ffffff198216610539610886565b506105618361054f8560026109aa565b61055a8660036109aa565b60026109dc565b91505b50919050565b60606000806105878460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060405191508192506105ac84836020016109fb565b508181016020016040529052919050565b60006105ca848484610710565b8051906020012090505b9392505050565b6000816105f062ffffff198216610539610886565b50610561836106008560016109aa565b61060b8660026109aa565b60016109dc565b60008161062860015b62ffffff19831690610886565b5061056162ffffff19841660266004610bd4565b600081610649600161061b565b5061056162ffffff19841660066020610c04565b60008161066a600161061b565b5061056162ffffff198416604e6004610bd4565b6040517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffffffffffffffffffff000000000000000000000000000000000000000060a086811b8216602284015285811b8216602e84015284811b8216603a84015283901b16604682015260609060520160405160208183030381529060405290505b949350505050565b82516060906000906107246004600261164f565b60ff166107319190611678565b905060008451826107429190611678565b905060016107526004600261164f565b60ff168383898989604051602001610770979695949392919061169e565b604051602081830303815290604052925050509392505050565b600081610797600161061b565b5061056162ffffff198416602e6020610c04565b6000816107b8600161061b565b5061056162ffffff198416602a6004610bd4565b6000816107e162ffffff198216610539610886565b50610561836107f18560036109aa565b601886901c6bffffffffffffffffffffffff1660036109dc565b600081610818600161061b565b5061056162ffffff19841660026004610bd4565b60008161084162ffffff198216610539610886565b5061056162ffffff198416610df6565b600061027661085f8361078a565b90565b81516000906020840161087d64ffffffffff85168284610e53565b95945050505050565b60006108928383610e9a565b6109a35760006108b16108a58560d81c90565b64ffffffffff16610ebd565b91505060006108c68464ffffffffff16610ebd565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161099a9190611416565b60405180910390fd5b5090919050565b60006105d460028360048111156109c3576109c36115f1565b6109cd919061173c565b62ffffff198516906002610bd4565b600061087d846109ec8186611779565b62ffffff198816919085610fa7565b600062ffffff1980841603610a92576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f54797065644d656d566965772f636f7079546f202d204e756c6c20706f696e7460448201527f6572206465726566000000000000000000000000000000000000000000000000606482015260840161099a565b610a9b83611021565b610b27576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f54797065644d656d566965772f636f7079546f202d20496e76616c696420706f60448201527f696e746572206465726566000000000000000000000000000000000000000000606482015260840161099a565b6000610b418460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610b6b8560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000604051905084811115610b905760206060fd5b8285848460045afa50610bca610ba68760d81c90565b70ffffffffff000000000000000000000000606091821b168717901b841760181b90565b9695505050505050565b6000610be1826020611790565b610bec90600861164f565b60ff16610bfa858585610c04565b901c949350505050565b60008160ff16600003610c19575060006105d4565b610c318460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610c4c60ff8416856117b3565b1115610cde57610cab610c6d8560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610c938660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff1661105e565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161099a9190611416565b60208260ff161115610d72576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e203332206279746573000000000000606482015260840161099a565b600882026000610d908660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b600080610e118360781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610e3b8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169091209392505050565b600080610e6083856117b3565b9050604051811115610e70575060005b80600003610e855762ffffff199150506105d4565b5050606092831b9190911790911b1760181b90565b60008164ffffffffff16610eae8460d81c90565b64ffffffffff16149392505050565b600080601f5b600f8160ff161115610f30576000610edc82600861164f565b60ff1685901c9050610eed816110cc565b61ffff16841793508160ff16601014610f0857601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610ec3565b50600f5b60ff8160ff161015610fa1576000610f4d82600861164f565b60ff1685901c9050610f5e816110cc565b61ffff16831792508160ff16600014610f7957601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610f34565b50915091565b600080610fc28660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050610fdb866110fe565b84610fe687846117b3565b610ff091906117b3565b11156110035762ffffff19915050610708565b61100d85826117b3565b9050610bca8364ffffffffff168286610e53565b600061102d8260d81c90565b64ffffffffff1664ffffffffff0361104757506000919050565b6000611052836110fe565b60405110199392505050565b6060600061106b86610ebd565b915050600061107986610ebd565b915050600061108786610ebd565b915050600061109586610ebd565b915050838383836040516020016110af94939291906117cb565b604051602081830303815290604052945050505050949350505050565b60006110de60048360ff16901c611146565b60ff1661ffff919091161760081b6110f582611146565b60ff1617919050565b60006111188260181c6bffffffffffffffffffffffff1690565b6111308360781c6bffffffffffffffffffffffff1690565b016bffffffffffffffffffffffff169050919050565b600060f08083179060ff821690036111615750603092915050565b8060ff1660f1036111755750603192915050565b8060ff1660f2036111895750603292915050565b8060ff1660f30361119d5750603392915050565b8060ff1660f4036111b15750603492915050565b8060ff1660f5036111c55750603592915050565b8060ff1660f6036111d95750603692915050565b8060ff1660f7036111ed5750603792915050565b8060ff1660f8036112015750603892915050565b8060ff1660f9036112155750603992915050565b8060ff1660fa036112295750606192915050565b8060ff1660fb0361123d5750606292915050565b8060ff1660fc036112515750606392915050565b8060ff1660fd036112655750606492915050565b8060ff1660fe036112795750606592915050565b8060ff1660ff036105645750606692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126112cd57600080fd5b813567ffffffffffffffff808211156112e8576112e861128d565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561132e5761132e61128d565b8160405283815286602085880101111561134757600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561137957600080fd5b813567ffffffffffffffff81111561139057600080fd5b610708848285016112bc565b60005b838110156113b757818101518382015260200161139f565b838111156113c6576000848401525b50505050565b600081518084526113e481602086016020860161139c565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006105d460208301846113cc565b803563ffffffff8116811461143d57600080fd5b919050565b600080600080600080600080610100898b03121561145f57600080fd5b61146889611429565b97506020890135965061147d60408a01611429565b955061148b60608a01611429565b9450608089013593506114a060a08a01611429565b925060c089013567ffffffffffffffff808211156114bd57600080fd5b6114c98c838d016112bc565b935060e08b01359150808211156114df57600080fd5b506114ec8b828c016112bc565b9150509295985092959890939650565b80356bffffffffffffffffffffffff8116811461143d57600080fd5b60008060008060008060008060008060006101608c8e03121561153a57600080fd5b6115438c611429565b9a5060208c0135995061155860408d01611429565b985061156660608d01611429565b975060808c0135965061157b60a08d01611429565b955061158960c08d016114fc565b945061159760e08d016114fc565b93506115a66101008d016114fc565b92506115b56101208d016114fc565b91506101408c013567ffffffffffffffff8111156115d257600080fd5b6115de8e828f016112bc565b9150509295989b509295989b9093969950565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600060ff821660ff84168160ff048111821515161561167057611670611620565b029392505050565b600061ffff80831681851680830382111561169557611695611620565b01949350505050565b60007fffff000000000000000000000000000000000000000000000000000000000000808a60f01b168352808960f01b166002840152808860f01b166004840152808760f01b1660068401525084516116fe81600885016020890161139c565b84519083019061171581600884016020890161139c565b845191019061172b81600884016020880161139c565b016008019998505050505050505050565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561177457611774611620565b500290565b60008282101561178b5761178b611620565b500390565b600060ff821660ff8416808210156117aa576117aa611620565b90039392505050565b600082198211156117c6576117c6611620565b500190565b7f54797065644d656d566965772f696e646578202d204f76657272616e2074686581527f20766965772e20536c696365206973206174203078000000000000000000000060208201527fffffffffffff000000000000000000000000000000000000000000000000000060d086811b821660358401527f2077697468206c656e6774682030780000000000000000000000000000000000603b840181905286821b8316604a8501527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060508501527f7800000000000000000000000000000000000000000000000000000000000000607085015285821b83166071850152607784015283901b1660868201527f2e00000000000000000000000000000000000000000000000000000000000000608c8201526000608d8201610bca56fea26469706673582212200d433cf58b1c411e28dea26e6cfce55626c077761ae2aefdef024731ec7fd18464736f6c634300080d0033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100ea5760003560e01c806381d030ef1161008c578063c97c703a11610066578063c97c703a146101de578063cb3eb0e1146101f1578063d7a7a72c14610204578063f45387ba1461021757600080fd5b806381d030ef146101a5578063985a5c31146101b8578063c81aa9c8146101cb57600080fd5b806352617f3c116100c857806352617f3c14610161578063639c5570146101775780636dc3c4f71461017f5780637c1cfff91461019257600080fd5b8063045c6c0b146100ef57806346fad66e146101185780634e76500414610139575b600080fd5b6101026100fd366004611367565b61024f565b60405161010f9190611416565b60405180910390f35b61012b610126366004611442565b61027c565b60405190815260200161010f565b61014c610147366004611367565b61032b565b60405163ffffffff909116815260200161010f565b60015b60405161ffff909116815260200161010f565b610164610352565b61012b61018d366004611367565b610368565b61014c6101a0366004611367565b610384565b6101026101b3366004611518565b6103a0565b61012b6101c6366004611367565b610477565b61014c6101d9366004611367565b610493565b6101026101ec366004611367565b6104af565b61014c6101ff366004611367565b6104cb565b61012b610212366004611367565b6104e7565b61022a610225366004611367565b610500565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200161010f565b606061027661026b6102608461051c565b62ffffff191661052a565b62ffffff191661056a565b92915050565b604080517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffff0000000000000000000000000000000000000000000000000000000060e08b811b82166022840152602683018b905289811b8216604684015288811b8216604a840152604e830188905286901b16606e82015281518082036052018152607290910190915260009061031d8185856105bd565b9a9950505050505050505050565b600061027661034761033c8461051c565b62ffffff19166105db565b62ffffff1916610612565b60006103606004600261164f565b60ff16905090565b600061027661037961033c8461051c565b62ffffff191661063c565b600061027661039561033c8461051c565b62ffffff191661065d565b606060006103b08787878761067e565b905060006104588e8e8e8e8e8e604080517e01000000000000000000000000000000000000000000000000000000000000602082015260e097881b7fffffffff000000000000000000000000000000000000000000000000000000009081166022830152602682019790975294871b8616604686015292861b8516604a850152604e84019190915290931b909116606e82015281516052818303018152607290910190915290565b9050610465818386610710565b9e9d5050505050505050505050505050565b600061027661048861033c8461051c565b62ffffff191661078a565b60006102766104a461033c8461051c565b62ffffff19166107ab565b606061027661026b6104c08461051c565b62ffffff19166107cc565b60006102766104dc61033c8461051c565b62ffffff191661080b565b60006102766104f58361051c565b62ffffff191661082c565b600061027661051161033c8461051c565b62ffffff1916610851565b600061027682610539610862565b60008161053f62ffffff198216610539610886565b506105618361054f8560026109aa565b61055a8660036109aa565b60026109dc565b91505b50919050565b60606000806105878460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060405191508192506105ac84836020016109fb565b508181016020016040529052919050565b60006105ca848484610710565b8051906020012090505b9392505050565b6000816105f062ffffff198216610539610886565b50610561836106008560016109aa565b61060b8660026109aa565b60016109dc565b60008161062860015b62ffffff19831690610886565b5061056162ffffff19841660266004610bd4565b600081610649600161061b565b5061056162ffffff19841660066020610c04565b60008161066a600161061b565b5061056162ffffff198416604e6004610bd4565b6040517e0100000000000000000000000000000000000000000000000000000000000060208201527fffffffffffffffffffffffff000000000000000000000000000000000000000060a086811b8216602284015285811b8216602e84015284811b8216603a84015283901b16604682015260609060520160405160208183030381529060405290505b949350505050565b82516060906000906107246004600261164f565b60ff166107319190611678565b905060008451826107429190611678565b905060016107526004600261164f565b60ff168383898989604051602001610770979695949392919061169e565b604051602081830303815290604052925050509392505050565b600081610797600161061b565b5061056162ffffff198416602e6020610c04565b6000816107b8600161061b565b5061056162ffffff198416602a6004610bd4565b6000816107e162ffffff198216610539610886565b50610561836107f18560036109aa565b601886901c6bffffffffffffffffffffffff1660036109dc565b600081610818600161061b565b5061056162ffffff19841660026004610bd4565b60008161084162ffffff198216610539610886565b5061056162ffffff198416610df6565b600061027661085f8361078a565b90565b81516000906020840161087d64ffffffffff85168284610e53565b95945050505050565b60006108928383610e9a565b6109a35760006108b16108a58560d81c90565b64ffffffffff16610ebd565b91505060006108c68464ffffffffff16610ebd565b6040517f5479706520617373657274696f6e206661696c65642e20476f7420307800000060208201527fffffffffffffffffffff0000000000000000000000000000000000000000000060b086811b8216603d8401527f2e20457870656374656420307800000000000000000000000000000000000000604784015283901b16605482015290925060009150605e016040516020818303038152906040529050806040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161099a9190611416565b60405180910390fd5b5090919050565b60006105d460028360048111156109c3576109c36115f1565b6109cd919061173c565b62ffffff198516906002610bd4565b600061087d846109ec8186611779565b62ffffff198816919085610fa7565b600062ffffff1980841603610a92576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f54797065644d656d566965772f636f7079546f202d204e756c6c20706f696e7460448201527f6572206465726566000000000000000000000000000000000000000000000000606482015260840161099a565b610a9b83611021565b610b27576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f54797065644d656d566965772f636f7079546f202d20496e76616c696420706f60448201527f696e746572206465726566000000000000000000000000000000000000000000606482015260840161099a565b6000610b418460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610b6b8560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000604051905084811115610b905760206060fd5b8285848460045afa50610bca610ba68760d81c90565b70ffffffffff000000000000000000000000606091821b168717901b841760181b90565b9695505050505050565b6000610be1826020611790565b610bec90600861164f565b60ff16610bfa858585610c04565b901c949350505050565b60008160ff16600003610c19575060006105d4565b610c318460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610c4c60ff8416856117b3565b1115610cde57610cab610c6d8560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16610c938660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff1661105e565b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161099a9190611416565b60208260ff161115610d72576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e203332206279746573000000000000606482015260840161099a565b600882026000610d908660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b600080610e118360781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506000610e3b8460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169091209392505050565b600080610e6083856117b3565b9050604051811115610e70575060005b80600003610e855762ffffff199150506105d4565b5050606092831b9190911790911b1760181b90565b60008164ffffffffff16610eae8460d81c90565b64ffffffffff16149392505050565b600080601f5b600f8160ff161115610f30576000610edc82600861164f565b60ff1685901c9050610eed816110cc565b61ffff16841793508160ff16601014610f0857601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610ec3565b50600f5b60ff8160ff161015610fa1576000610f4d82600861164f565b60ff1685901c9050610f5e816110cc565b61ffff16831792508160ff16600014610f7957601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610f34565b50915091565b600080610fc28660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050610fdb866110fe565b84610fe687846117b3565b610ff091906117b3565b11156110035762ffffff19915050610708565b61100d85826117b3565b9050610bca8364ffffffffff168286610e53565b600061102d8260d81c90565b64ffffffffff1664ffffffffff0361104757506000919050565b6000611052836110fe565b60405110199392505050565b6060600061106b86610ebd565b915050600061107986610ebd565b915050600061108786610ebd565b915050600061109586610ebd565b915050838383836040516020016110af94939291906117cb565b604051602081830303815290604052945050505050949350505050565b60006110de60048360ff16901c611146565b60ff1661ffff919091161760081b6110f582611146565b60ff1617919050565b60006111188260181c6bffffffffffffffffffffffff1690565b6111308360781c6bffffffffffffffffffffffff1690565b016bffffffffffffffffffffffff169050919050565b600060f08083179060ff821690036111615750603092915050565b8060ff1660f1036111755750603192915050565b8060ff1660f2036111895750603292915050565b8060ff1660f30361119d5750603392915050565b8060ff1660f4036111b15750603492915050565b8060ff1660f5036111c55750603592915050565b8060ff1660f6036111d95750603692915050565b8060ff1660f7036111ed5750603792915050565b8060ff1660f8036112015750603892915050565b8060ff1660f9036112155750603992915050565b8060ff1660fa036112295750606192915050565b8060ff1660fb0361123d5750606292915050565b8060ff1660fc036112515750606392915050565b8060ff1660fd036112655750606492915050565b8060ff1660fe036112795750606592915050565b8060ff1660ff036105645750606692915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f8301126112cd57600080fd5b813567ffffffffffffffff808211156112e8576112e861128d565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f0116810190828211818310171561132e5761132e61128d565b8160405283815286602085880101111561134757600080fd5b836020870160208301376000602085830101528094505050505092915050565b60006020828403121561137957600080fd5b813567ffffffffffffffff81111561139057600080fd5b610708848285016112bc565b60005b838110156113b757818101518382015260200161139f565b838111156113c6576000848401525b50505050565b600081518084526113e481602086016020860161139c565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006105d460208301846113cc565b803563ffffffff8116811461143d57600080fd5b919050565b600080600080600080600080610100898b03121561145f57600080fd5b61146889611429565b97506020890135965061147d60408a01611429565b955061148b60608a01611429565b9450608089013593506114a060a08a01611429565b925060c089013567ffffffffffffffff808211156114bd57600080fd5b6114c98c838d016112bc565b935060e08b01359150808211156114df57600080fd5b506114ec8b828c016112bc565b9150509295985092959890939650565b80356bffffffffffffffffffffffff8116811461143d57600080fd5b60008060008060008060008060008060006101608c8e03121561153a57600080fd5b6115438c611429565b9a5060208c0135995061155860408d01611429565b985061156660608d01611429565b975060808c0135965061157b60a08d01611429565b955061158960c08d016114fc565b945061159760e08d016114fc565b93506115a66101008d016114fc565b92506115b56101208d016114fc565b91506101408c013567ffffffffffffffff8111156115d257600080fd5b6115de8e828f016112bc565b9150509295989b509295989b9093969950565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b600060ff821660ff84168160ff048111821515161561167057611670611620565b029392505050565b600061ffff80831681851680830382111561169557611695611620565b01949350505050565b60007fffff000000000000000000000000000000000000000000000000000000000000808a60f01b168352808960f01b166002840152808860f01b166004840152808760f01b1660068401525084516116fe81600885016020890161139c565b84519083019061171581600884016020890161139c565b845191019061172b81600884016020880161139c565b016008019998505050505050505050565b6000817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff048311821515161561177457611774611620565b500290565b60008282101561178b5761178b611620565b500390565b600060ff821660ff8416808210156117aa576117aa611620565b90039392505050565b600082198211156117c6576117c6611620565b500190565b7f54797065644d656d566965772f696e646578202d204f76657272616e2074686581527f20766965772e20536c696365206973206174203078000000000000000000000060208201527fffffffffffff000000000000000000000000000000000000000000000000000060d086811b821660358401527f2077697468206c656e6774682030780000000000000000000000000000000000603b840181905286821b8316604a8501527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060508501527f7800000000000000000000000000000000000000000000000000000000000000607085015285821b83166071850152607784015283901b1660868201527f2e00000000000000000000000000000000000000000000000000000000000000608c8201526000608d8201610bca56fea26469706673582212200d433cf58b1c411e28dea26e6cfce55626c077761ae2aefdef024731ec7fd18464736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = Tips.formatTips(\n            _updaterTip,\n            _relayerTip,\n            _proverTip,\n            _processorTip\n        );\n\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n\n    function messageVersion() public pure returns (uint16) {\n        return Message.MESSAGE_VERSION;\n    }\n\n    function headerOffset() public pure returns (uint16) {\n        return Message.HEADER_OFFSET;\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"44669:3701:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"44669:3701:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;46713:135;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;:::-;;;;;;;;46158:549;;;;;;:::i;:::-;;:::i;:::-;;;3403:25:1;;;3391:2;3376:18;46158:549:0;3257:177:1;47276:132:0;;;;;;:::i;:::-;;:::i;:::-;;;3613:10:1;3601:23;;;3583:42;;3571:2;3556:18;47276:132:0;3439:192:1;48162:102:0;33745:1;48162:102;;;3810:6:1;3798:19;;;3780:38;;3768:2;3753:18;48162:102:0;3636:188:1;48270:98:0;;;:::i;47135:135::-;;;;;;:::i;:::-;;:::i;47872:156::-;;;;;;:::i;:::-;;:::i;44826:862::-;;;;;;:::i;:::-;;:::i;47564:141::-;;;;;;:::i;:::-;;:::i;47414:144::-;;;;;;:::i;:::-;;:::i;46854:135::-;;;;;;:::i;:::-;;:::i;46995:134::-;;;;;;:::i;:::-;;:::i;48034:122::-;;;;;;:::i;:::-;;:::i;47711:155::-;;;;;;:::i;:::-;;:::i;:::-;;;5236:42:1;5224:55;;;5206:74;;5194:2;5179:18;47711:155:0;5060:226:1;46713:135:0;46773:12;46804:37;:29;:22;:8;:20;:22::i;:::-;-1:-1:-1;;46804:27:0;;:29::i;:::-;-1:-1:-1;;46804:35:0;;:37::i;:::-;46797:44;46713:135;-1:-1:-1;;46713:135:0:o;46158:549::-;39644:242;;;6215:16:1;39644:242:0;;;6199:102:1;6320:66;6423:3;6419:16;;;6415:25;;6402:11;;;6395:46;6457:11;;;6450:27;;;6511:16;;;6507:25;;6493:12;;;6486:47;6567:16;;;6563:25;;6549:12;;;6542:47;6605:12;;;6598:28;;;6660:16;;;6656:25;6642:12;;;6635:47;39644:242:0;;;;;;;;;6698:12:1;;;;39644:242:0;;;46426:7;;46658:42;46678:7;46687:5;46694;46658:19;:42::i;:::-;46651:49;46158:549;-1:-1:-1;;;;;;;;;;46158:549:0:o;47276:132::-;47337:6;47362:39;:31;:22;:8;:20;:22::i;:::-;-1:-1:-1;;47362:29:0;;:31::i;:::-;-1:-1:-1;;47362:37:0;;:39::i;48270:98::-;48315:6;35024:29;35042:10;34895:1;35024:29;:::i;:::-;48340:21;;48333:28;;48270:98;:::o;47135:135::-;47197:7;47223:40;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;47223:38:0;;:40::i;47872:156::-;47945:6;47970:51;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;47970:49:0;;:51::i;44826:862::-;45223:12;45247:18;45268:126;45297:11;45322;45347:10;45371:13;45268:15;:126::i;:::-;45247:147;;45405:20;45428:185;45461:13;45488:7;45509:6;45529:18;45561:10;45585:18;39644:242;;;6215:16:1;39644:242:0;;;6199:102:1;6423:3;6419:16;;;6320:66;6415:25;;;6402:11;;;6395:46;6457:11;;;6450:27;;;;6511:16;;;6507:25;;6493:12;;;6486:47;6567:16;;;6563:25;;6549:12;;;6542:47;6605:12;;;6598:28;;;;6660:16;;;6656:25;;;6642:12;;;6635:47;39644:242:0;;;;;;;;;6698:12:1;;;;39644:242:0;;;;39374:519;45428:185;45405:208;;45630:51;45652:7;45661:5;45668:12;45630:21;:51::i;:::-;45623:58;44826:862;-1:-1:-1;;;;;;;;;;;;;;44826:862:0:o;47564:141::-;47629:7;47655:43;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;47655:41:0;;:43::i;47414:144::-;47481:6;47506:45;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;47506:43:0;;:45::i;46854:135::-;46914:12;46945:37;:29;:22;:8;:20;:22::i;:::-;-1:-1:-1;;46945:27:0;;:29::i;46995:134::-;47057:6;47082:40;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;47082:38:0;;:40::i;48034:122::-;48094:7;48120:29;:22;:8;:20;:22::i;:::-;-1:-1:-1;;48120:27:0;;:29::i;47711:155::-;47783:7;47809:50;:31;:22;:8;:20;:22::i;:31::-;-1:-1:-1;;47809:48:0;;:50::i;36381:126::-;36448:7;36474:26;:8;33969:4;36474:12;:26::i;37058:299::-;37135:7;37116:8;34213:30;-1:-1:-1;;34213:16:0;;33969:4;34213:16;:30::i;:::-;;37173:177:::1;37199:8;37225:33;37237:8;37247:10;37225:11;:33::i;:::-;37276;37288:8;37298:10;37276:11;:33::i;:::-;34088:10;37173:8;:177::i;:::-;37154:196;;34253:1;37058:299:::0;;;;:::o;28308:632::-;28363:16;28391:11;28412:12;28427;28431:7;16492:2;16488:16;2670:26;16484:28;;16246:282;28427:12;28412:27;;;;28549:4;28543:11;28536:18;;28604:3;28597:10;;28650:33;28663:7;28672:3;28678:4;28672:10;28650:12;:33::i;:::-;-1:-1:-1;28807:14:0;;;28823:4;28803:25;28797:4;28790:39;28870:17;;28308:632;;-1:-1:-1;28308:632:0:o;36145:230::-;36288:7;36324:43;36338:7;36347:5;36354:12;36324:13;:43::i;:::-;36314:54;;;;;;36307:61;;36145:230;;;;;;:::o;36631:305::-;36710:7;36691:8;34213:30;-1:-1:-1;;34213:16:0;;33969:4;34213:16;:30::i;:::-;;36748:181:::1;36774:8;36800:35;36812:8;36822:12;36800:11;:35::i;:::-;36853:33;36865:8;36875:10;36853:11;:33::i;:::-;34025:12;37173:8;:177::i;40628:149::-:0;40703:6;40685:7;39313:37;34025:12;34018:20;-1:-1:-1;;39313:16:0;;;;:37::i;:::-;-1:-1:-1;40735:34:0::1;-1:-1:-1::0;;40735:17:0;::::1;39089:2;40767:1;40735:17;:34::i;40436:141::-:0;40512:7;40494;39313:37;34025:12;34018:20;;39313:37;-1:-1:-1;40538:32:0::1;-1:-1:-1::0;;40538:13:0;::::1;39041:1;40567:2;40538:13;:32::i;41272:174::-:0;41359:6;41341:7;39313:37;34025:12;34018:20;;39313:37;-1:-1:-1;41391:47:0::1;-1:-1:-1::0;;41391:17:0;::::1;39259:2;41436:1;41391:17;:47::i;42738:283::-:0;42931:83;;6968:16:1;42931:83:0;;;6952:102:1;7073:66;7176:3;7172:16;;;7168:25;;7155:11;;;7148:46;7228:16;;;7224:25;;7210:12;;;7203:47;7284:16;;;7280:25;;7266:12;;;7259:47;7340:16;;;7336:25;7322:12;;;7315:47;42900:12:0;;7378::1;;42931:83:0;;;;;;;;;;;;42924:90;;42738:283;;;;;;;:::o;35273:638::-;35569:14;;35418:12;;35526:17;;35024:29;35042:10;34895:1;35024:29;:::i;:::-;35546:13;;:38;;;;:::i;:::-;35526:58;;35594:17;35634:5;:12;35614:10;:33;;;;:::i;:::-;35594:53;-1:-1:-1;33745:1:0;35024:29;35042:10;34895:1;35024:29;:::i;:::-;35743:13;;35774:10;35802;35830:7;35855:5;35878:12;35676:228;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;35657:247;;;;35273:638;;;;;:::o;41061:147::-;41140:7;41122;39313:37;34025:12;34018:20;;39313:37;-1:-1:-1;41166:35:0::1;-1:-1:-1::0;;41166:13:0;::::1;39197:2;41198;41166:13;:35::i;40834:161::-:0;40915:6;40897:7;39313:37;34025:12;34018:20;;39313:37;-1:-1:-1;40947:40:0::1;-1:-1:-1::0;;40947:17:0;::::1;39144:2;40985:1;40947:17;:40::i;37479:190::-:0;37556:7;37537:8;34213:30;-1:-1:-1;;34213:16:0;;33969:4;34213:16;:30::i;:::-;;37582:80:::1;37591:8;37601:33;37613:8;37623:10;37601:11;:33::i;:::-;16492:2:::0;16488:16;;;2670:26;16484:28;34149:10:::1;37173:8;:177::i;40233:151::-:0;40309:6;40291:7;39313:37;34025:12;34018:20;;39313:37;-1:-1:-1;40341:35:0::1;-1:-1:-1::0;;40341:17:0;::::1;38992:1;40374;40341:17;:35::i;37730:170::-:0;37807:7;37788:8;34213:30;-1:-1:-1;;34213:16:0;;33969:4;34213:16;:30::i;:::-;-1:-1:-1;37876:17:0::1;-1:-1:-1::0;;37876:15:0;::::1;;:17::i;41515:145::-:0;41581:7;41607:46;41634:18;41644:7;41634:9;:18::i;:::-;33368:4;33255:127;13655:359;13759:10;;13725:7;;13906:4;13897:14;;13981:26;;;;13897:14;13759:10;13981:5;:26::i;:::-;13974:33;13655:359;-1:-1:-1;;;;;13655:359:0:o;10073:578::-;10151:7;10175:26;10182:7;10191:9;10175:6;:26::i;:::-;10170:451;;10220:9;10233:35;10251:15;10258:7;14417:3;14413:17;;14206:268;10251:15;10243:24;;10233:9;:35::i;:::-;10217:51;;;10285:9;10298:29;10316:9;10308:18;;10298:9;:29::i;:::-;10385:186;;9075:31:1;10385:186:0;;;9063:44:1;9126:66;9230:3;9226:16;;;9222:25;;9208:12;;;9201:47;9278:15;9264:12;;;9257:37;9328:16;;;9324:25;9310:12;;;9303:47;10282:45:0;;-1:-1:-1;10341:17:0;;-1:-1:-1;9366:12:1;;10385:186:0;;;;;;;;;;;;10341:244;;10606:3;10599:11;;;;;;;;;;;:::i;:::-;;;;;;;;10170:451;-1:-1:-1;10637:7:0;;10073:578;-1:-1:-1;10073:578:0:o;38191:164::-;38265:7;38291:57;34895:1;38318:5;38310:14;;;;;;;;:::i;:::-;:26;;;;:::i;:::-;-1:-1:-1;;38291:18:0;;;34895:1;38291:18;:57::i;37906:218::-;38047:7;38073:44;38088:5;38095:11;38088:5;38095:3;:11;:::i;:::-;-1:-1:-1;;38073:14:0;;;:44;38108:8;38073:14;:44::i;27036:902::-;27114:15;-1:-1:-1;;7972:15:0;;;;27141:69;;;;;;;10178:2:1;27141:69:0;;;10160:21:1;10217:2;10197:18;;;10190:30;10256:34;10236:18;;;10229:62;10327:10;10307:18;;;10300:38;10355:19;;27141:69:0;9976:404:1;27141:69:0;27228:16;27236:7;27228;:16::i;:::-;27220:72;;;;;;;10587:2:1;27220:72:0;;;10569:21:1;10626:2;10606:18;;;10599:30;10665:34;10645:18;;;10638:62;10736:13;10716:18;;;10709:41;10767:19;;27220:72:0;10385:407:1;27220:72:0;27302:12;27317;27321:7;16492:2;16488:16;2670:26;16484:28;;16246:282;27317:12;27302:27;;;;27339:15;27357:12;27361:7;15386:3;15382:17;2670:26;15378:29;;15059:364;27357:12;27339:30;;;;27380:11;27501:4;27495:11;27488:18;;27588:7;27583:3;27580:16;27577:94;;;27628:4;27622;27615:18;27577:94;27843:4;27834:7;27828:4;27819:7;27816:1;27809:5;27798:50;27794:55;27879:52;27900:15;27907:7;14417:3;14413:17;;14206:268;27900:15;12061:27;12065:2;12061:27;;;;12135:17;;12127:26;;12199:17;;12195:2;12191:26;;11811:446;27879:52;27869:62;27036:902;-1:-1:-1;;;;;;27036:902:0:o;21121:221::-;21240:14;21318:11;21323:6;21318:2;:11;:::i;:::-;21317:17;;21333:1;21317:17;:::i;:::-;21273:62;;21281:30;21287:7;21296:6;21304;21281:5;:30::i;:::-;21273:62;;;21121:221;-1:-1:-1;;;;21121:221:0:o;20004:771::-;20119:14;20149:6;:11;;20159:1;20149:11;20145:59;;-1:-1:-1;20191:1:0;20176:17;;20145:59;20235:12;20239:7;16492:2;16488:16;2670:26;16484:28;;16246:282;20235:12;20217:30;;:15;;;;:6;:15;:::i;:::-;:30;20213:137;;;20270:68;20286:12;20290:7;15386:3;15382:17;2670:26;15378:29;;15059:364;20286:12;20270:68;;20300:12;20304:7;16492:2;16488:16;2670:26;16484:28;;16246:282;20300:12;20270:68;;20314:6;20330;20322:15;;20270;:68::i;:::-;20263:76;;;;;;;;;;;:::i;20213:137::-;20377:2;20367:6;:12;;;;20359:83;;;;;;;11332:2:1;20359:83:0;;;11314:21:1;11371:2;11351:18;;;11344:30;11410:34;11390:18;;;11383:62;11481:28;11461:18;;;11454:56;11527:19;;20359:83:0;11130:422:1;20359:83:0;20523:1;20514:10;;20453:15;20559:12;20563:7;15386:3;15382:17;2670:26;15378:29;;15059:364;20559:12;20544:27;;;-1:-1:-1;20581:13:0;7488:66;7458:12;;;7437:131;20733:17;;;;20727:24;20723:36;;;-1:-1:-1;;;;;20004:771:0:o;22455:290::-;22511:14;22537:12;22552;22556:7;15386:3;15382:17;2670:26;15378:29;;15059:364;22552:12;22537:27;;;;22574:12;22589;22593:7;16492:2;16488:16;2670:26;16484:28;;16246:282;22589:12;22574:27;;22708:21;;;;22455:290;-1:-1:-1;;;22455:290:0:o;12796:462::-;12907:15;;12949:11;12956:4;12949;:11;:::i;:::-;12934:26;;13075:4;13069:11;13063:4;13060:21;13057:66;;;-1:-1:-1;13108:1:0;13057:66;13146:4;13154:1;13146:9;13142:51;;-1:-1:-1;;13171:11:0;;;;;13142:51;-1:-1:-1;;12065:2:0;12061:27;;;12135:17;;;;12127:26;;;12199:17;12195:2;12191:26;;12796:462::o;9643:132::-;9717:4;9759:9;9740:28;;:15;9747:7;14417:3;14413:17;;14206:268;9740:15;:28;;;;9643:132;-1:-1:-1;;;9643:132:0:o;5031:667::-;5085:13;;5141:2;5126:258;5149:2;5145:1;:6;;;5126:258;;;5169:11;5196:5;:1;5200;5196:5;:::i;:::-;5189:13;;:2;:13;;5169:34;;5226:14;5234:5;5226:7;:14::i;:::-;5217:23;;;;;;5258:1;:7;;5263:2;5258:7;5254:58;;5295:2;5285:12;;;;;5254:58;-1:-1:-1;5353:6:0;;5126:258;;;-1:-1:-1;5447:2:0;5432:260;5455:3;5451:1;:7;;;5432:260;;;5476:11;5503:5;:1;5507;5503:5;:::i;:::-;5496:13;;:2;:13;;5476:34;;5534:14;5542:5;5534:7;:14::i;:::-;5524:24;;;;;;5566:1;:6;;5571:1;5566:6;5562:58;;5603:2;5592:13;;;;;5562:58;-1:-1:-1;5661:6:0;;5432:260;;;;5031:667;;;:::o;17129:399::-;17268:7;17287:12;17302;17306:7;15386:3;15382:17;2670:26;15378:29;;15059:364;17302:12;17287:27;;;;17398:12;17402:7;17398:3;:12::i;:::-;17391:4;17375:13;17382:6;17375:4;:13;:::i;:::-;:20;;;;:::i;:::-;:35;17371:77;;;-1:-1:-1;;17426:11:0;;;;;17371:77;17465:13;17472:6;17465:4;:13;:::i;:::-;17458:20;;17495:26;17501:7;17495:26;;17510:4;17516;17495:5;:26::i;8645:333::-;8702:8;8726:15;8733:7;14417:3;14413:17;;14206:268;8726:15;:31;;8745:12;8726:31;8722:74;;-1:-1:-1;8780:5:0;;8645:333;-1:-1:-1;8645:333:0:o;8722:74::-;8805:12;8820;8824:7;8820:3;:12::i;:::-;8955:4;8949:11;-1:-1:-1;8936:26:0;;8645:333;-1:-1:-1;;;8645:333:0:o;18761:741::-;18907:17;18939:9;18952:15;18962:4;18952:9;:15::i;:::-;18936:31;;;18980:9;18993:15;19003:4;18993:9;:15::i;:::-;18977:31;;;19021:9;19034:17;19044:6;19034:9;:17::i;:::-;19018:33;;;19064:9;19077:17;19087:6;19077:9;:17::i;:::-;19061:33;;;19244:1;19306;19386;19448;19130:355;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;19104:391;;18926:576;;;;18761:741;;;;;;:::o;4508:199::-;4558:14;4595:18;4611:1;4605:2;:7;;;;4595:9;:18::i;:::-;4584:29;;4637:13;;;;;;4649:1;4637:13;4671;4681:2;4671:9;:13::i;:::-;4660:24;;;;4508:199;-1:-1:-1;4508:199:0:o;16702:147::-;16755:7;16820:12;16824:7;16492:2;16488:16;2670:26;16484:28;;16246:282;16820:12;16805;16809:7;15386:3;15382:17;2670:26;15378:29;;15059:364;16805:12;:27;16798:34;;;;16702:147;;;:::o;2943:1393::-;2995:10;3161:4;3156:9;;;;3207:15;;;;;3203:57;;-1:-1:-1;3245:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3203:57::-;3278:7;:15;;3289:4;3278:15;3274:57;;-1:-1:-1;3316:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3274:57::-;3349:7;:15;;3360:4;3349:15;3345:57;;-1:-1:-1;3387:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3345:57::-;3420:7;:15;;3431:4;3420:15;3416:57;;-1:-1:-1;3458:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3416:57::-;3491:7;:15;;3502:4;3491:15;3487:57;;-1:-1:-1;3529:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3487:57::-;3562:7;:15;;3573:4;3562:15;3558:57;;-1:-1:-1;3600:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3558:57::-;3633:7;:15;;3644:4;3633:15;3629:57;;-1:-1:-1;3671:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3629:57::-;3704:7;:15;;3715:4;3704:15;3700:57;;-1:-1:-1;3742:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3700:57::-;3775:7;:15;;3786:4;3775:15;3771:57;;-1:-1:-1;3813:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3771:57::-;3846:7;:15;;3857:4;3846:15;3842:57;;-1:-1:-1;3884:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3842:57::-;3917:7;:15;;3928:4;3917:15;3913:57;;-1:-1:-1;3955:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3913:57::-;3988:7;:15;;3999:4;3988:15;3984:57;;-1:-1:-1;4026:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;3984:57::-;4059:7;:15;;4070:4;4059:15;4055:57;;-1:-1:-1;4097:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4055:57::-;4130:7;:15;;4141:4;4130:15;4126:57;;-1:-1:-1;4168:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4126:57::-;4201:7;:15;;4212:4;4201:15;4197:57;;-1:-1:-1;4239:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;4197:57::-;4272:7;:15;;4283:4;4272:15;4268:57;;-1:-1:-1;4310:4:0;;2943:1393;-1:-1:-1;;2943:1393:0:o;14:184:1:-;66:77;63:1;56:88;163:4;160:1;153:15;187:4;184:1;177:15;203:777;245:5;298:3;291:4;283:6;279:17;275:27;265:55;;316:1;313;306:12;265:55;352:6;339:20;378:18;415:2;411;408:10;405:36;;;421:18;;:::i;:::-;555:2;549:9;617:4;609:13;;460:66;605:22;;;629:2;601:31;597:40;585:53;;;653:18;;;673:22;;;650:46;647:72;;;699:18;;:::i;:::-;739:10;735:2;728:22;774:2;766:6;759:18;820:3;813:4;808:2;800:6;796:15;792:26;789:35;786:55;;;837:1;834;827:12;786:55;901:2;894:4;886:6;882:17;875:4;867:6;863:17;850:54;948:1;941:4;936:2;928:6;924:15;920:26;913:37;968:6;959:15;;;;;;203:777;;;;:::o;985:320::-;1053:6;1106:2;1094:9;1085:7;1081:23;1077:32;1074:52;;;1122:1;1119;1112:12;1074:52;1162:9;1149:23;1195:18;1187:6;1184:30;1181:50;;;1227:1;1224;1217:12;1181:50;1250:49;1291:7;1282:6;1271:9;1267:22;1250:49;:::i;1310:258::-;1382:1;1392:113;1406:6;1403:1;1400:13;1392:113;;;1482:11;;;1476:18;1463:11;;;1456:39;1428:2;1421:10;1392:113;;;1523:6;1520:1;1517:13;1514:48;;;1558:1;1549:6;1544:3;1540:16;1533:27;1514:48;;1310:258;;;:::o;1573:316::-;1614:3;1652:5;1646:12;1679:6;1674:3;1667:19;1695:63;1751:6;1744:4;1739:3;1735:14;1728:4;1721:5;1717:16;1695:63;:::i;:::-;1803:2;1791:15;1808:66;1787:88;1778:98;;;;1878:4;1774:109;;1573:316;-1:-1:-1;;1573:316:1:o;1894:217::-;2041:2;2030:9;2023:21;2004:4;2061:44;2101:2;2090:9;2086:18;2078:6;2061:44;:::i;2116:163::-;2183:20;;2243:10;2232:22;;2222:33;;2212:61;;2269:1;2266;2259:12;2212:61;2116:163;;;:::o;2284:968::-;2420:6;2428;2436;2444;2452;2460;2468;2476;2529:3;2517:9;2508:7;2504:23;2500:33;2497:53;;;2546:1;2543;2536:12;2497:53;2569:28;2587:9;2569:28;:::i;:::-;2559:38;;2644:2;2633:9;2629:18;2616:32;2606:42;;2667:37;2700:2;2689:9;2685:18;2667:37;:::i;:::-;2657:47;;2723:37;2756:2;2745:9;2741:18;2723:37;:::i;:::-;2713:47;;2807:3;2796:9;2792:19;2779:33;2769:43;;2831:38;2864:3;2853:9;2849:19;2831:38;:::i;:::-;2821:48;;2920:3;2909:9;2905:19;2892:33;2944:18;2985:2;2977:6;2974:14;2971:34;;;3001:1;2998;2991:12;2971:34;3024:49;3065:7;3056:6;3045:9;3041:22;3024:49;:::i;:::-;3014:59;;3126:3;3115:9;3111:19;3098:33;3082:49;;3156:2;3146:8;3143:16;3140:36;;;3172:1;3169;3162:12;3140:36;;3195:51;3238:7;3227:8;3216:9;3212:24;3195:51;:::i;:::-;3185:61;;;2284:968;;;;;;;;;;;:::o;3829:179::-;3896:20;;3956:26;3945:38;;3935:49;;3925:77;;3998:1;3995;3988:12;4013:1042;4163:6;4171;4179;4187;4195;4203;4211;4219;4227;4235;4243:7;4297:3;4285:9;4276:7;4272:23;4268:33;4265:53;;;4314:1;4311;4304:12;4265:53;4337:28;4355:9;4337:28;:::i;:::-;4327:38;;4412:2;4401:9;4397:18;4384:32;4374:42;;4435:37;4468:2;4457:9;4453:18;4435:37;:::i;:::-;4425:47;;4491:37;4524:2;4513:9;4509:18;4491:37;:::i;:::-;4481:47;;4575:3;4564:9;4560:19;4547:33;4537:43;;4599:38;4632:3;4621:9;4617:19;4599:38;:::i;:::-;4589:48;;4656:38;4689:3;4678:9;4674:19;4656:38;:::i;:::-;4646:48;;4713:38;4746:3;4735:9;4731:19;4713:38;:::i;:::-;4703:48;;4770:38;4803:3;4792:9;4788:19;4770:38;:::i;:::-;4760:48;;4827:38;4860:3;4849:9;4845:19;4827:38;:::i;:::-;4817:48;;4916:3;4905:9;4901:19;4888:33;4944:18;4936:6;4933:30;4930:50;;;4976:1;4973;4966:12;4930:50;5000:49;5041:7;5032:6;5021:9;5017:22;5000:49;:::i;:::-;4989:60;;;4013:1042;;;;;;;;;;;;;;:::o;5291:184::-;5343:77;5340:1;5333:88;5440:4;5437:1;5430:15;5464:4;5461:1;5454:15;5480:184;5532:77;5529:1;5522:88;5629:4;5626:1;5619:15;5653:4;5650:1;5643:15;5669:238;5707:7;5747:4;5744:1;5740:12;5779:4;5776:1;5772:12;5839:3;5833:4;5829:14;5824:3;5821:23;5814:3;5807:11;5800:19;5796:49;5793:75;;;5848:18;;:::i;:::-;5888:13;;5669:238;-1:-1:-1;;;5669:238:1:o;7401:224::-;7440:3;7468:6;7501:2;7498:1;7494:10;7531:2;7528:1;7524:10;7562:3;7558:2;7554:12;7549:3;7546:21;7543:47;;;7570:18;;:::i;:::-;7606:13;;7401:224;-1:-1:-1;;;;7401:224:1:o;7630:1073::-;7955:3;7983:66;8092:2;8083:6;8078:3;8074:16;8070:25;8065:3;8058:38;8147:2;8138:6;8133:3;8129:16;8125:25;8121:1;8116:3;8112:11;8105:46;8202:2;8193:6;8188:3;8184:16;8180:25;8176:1;8171:3;8167:11;8160:46;8257:2;8248:6;8243:3;8239:16;8235:25;8231:1;8226:3;8222:11;8215:46;;8290:6;8284:13;8306:61;8360:6;8356:1;8351:3;8347:11;8340:4;8332:6;8328:17;8306:61;:::i;:::-;8427:13;;8386:16;;;;8449:62;8427:13;8498:1;8490:10;;8483:4;8471:17;;8449:62;:::i;:::-;8572:13;;8530:17;;;8594:62;8572:13;8643:1;8635:10;;8628:4;8616:17;;8594:62;:::i;:::-;8676:17;8695:1;8672:25;;7630:1073;-1:-1:-1;;;;;;;;;7630:1073:1:o;9613:228::-;9653:7;9779:1;9711:66;9707:74;9704:1;9701:81;9696:1;9689:9;9682:17;9678:105;9675:131;;;9786:18;;:::i;:::-;-1:-1:-1;9826:9:1;;9613:228::o;9846:125::-;9886:4;9914:1;9911;9908:8;9905:34;;;9919:18;;:::i;:::-;-1:-1:-1;9956:9:1;;9846:125::o;10797:195::-;10835:4;10872;10869:1;10865:12;10904:4;10901:1;10897:12;10929:3;10924;10921:12;10918:38;;;10936:18;;:::i;:::-;10973:13;;;10797:195;-1:-1:-1;;;10797:195:1:o;10997:128::-;11037:3;11068:1;11064:6;11061:1;11058:13;11055:39;;;11074:18;;:::i;:::-;-1:-1:-1;11110:9:1;;10997:128::o;11676:1391::-;12398:34;12386:47;;12463:23;12458:2;12449:12;;12442:45;12506:66;12610:3;12606:16;;;12602:25;;12597:2;12588:12;;12581:47;12647:17;12689:2;12680:12;;12673:24;;;12731:16;;;12727:25;;12722:2;12713:12;;12706:47;12783:34;12778:2;12769:12;;12762:56;12849:3;12843;12834:13;;12827:26;12888:16;;;12884:25;;12878:3;12869:13;;12862:48;12935:3;12926:13;;12919:25;12979:16;;;12975:25;12969:3;12960:13;;12953:48;11634:3;13056;13047:13;;11622:16;-1:-1:-1;11654:11:1;;;13017:44;11557:114","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"body","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"destination","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_originDomain","type":"uint32"},{"internalType":"bytes32","name":"_sender","type":"bytes32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"uint32","name":"_destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"_recipient","type":"bytes32"},{"internalType":"uint32","name":"_optimisticSeconds","type":"uint32"},{"internalType":"uint96","name":"_updaterTip","type":"uint96"},{"internalType":"uint96","name":"_relayerTip","type":"uint96"},{"internalType":"uint96","name":"_proverTip","type":"uint96"},{"internalType":"uint96","name":"_processorTip","type":"uint96"},{"internalType":"bytes","name":"_messageBody","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"headerOffset","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"leaf","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"bytes32","name":"_sender","type":"bytes32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"bytes32","name":"_recipient","type":"bytes32"},{"internalType":"uint32","name":"_optimisticSeconds","type":"uint32"},{"internalType":"bytes","name":"_tips","type":"bytes"},{"internalType":"bytes","name":"_body","type":"bytes"}],"name":"messageHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[],"name":"messageVersion","outputs":[{"internalType":"uint16","name":"","type":"uint16"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"nonce","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"optimisticSeconds","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"origin","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"recipient","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"recipientAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"sender","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"tips","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)":{"notice":"Returns leaf of formatted message with provided fields."}},"version":1},"developerDoc":{"kind":"dev","methods":{"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)":{"params":{"_body":"Raw bytes of message body","_destination":"Domain of destination chain","_nonce":"Destination-specific nonce number","_origin":"Domain of home chain","_recipient":"Address of recipient on destination chain as bytes32","_sender":"Address of sender as bytes32"},"returns":{"_0":"Leaf (hash) of formatted message*"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"body\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"destination\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_originDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_optimisticSeconds\",\"type\":\"uint32\"},{\"internalType\":\"uint96\",\"name\":\"_updaterTip\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_relayerTip\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_proverTip\",\"type\":\"uint96\"},{\"internalType\":\"uint96\",\"name\":\"_processorTip\",\"type\":\"uint96\"},{\"internalType\":\"bytes\",\"name\":\"_messageBody\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"headerOffset\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"leaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_optimisticSeconds\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_tips\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_body\",\"type\":\"bytes\"}],\"name\":\"messageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"messageVersion\",\"outputs\":[{\"internalType\":\"uint16\",\"name\":\"\",\"type\":\"uint16\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"optimisticSeconds\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"recipientAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"sender\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"tips\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)\":{\"params\":{\"_body\":\"Raw bytes of message body\",\"_destination\":\"Domain of destination chain\",\"_nonce\":\"Destination-specific nonce number\",\"_origin\":\"Domain of home chain\",\"_recipient\":\"Address of recipient on destination chain as bytes32\",\"_sender\":\"Address of sender as bytes32\"},\"returns\":{\"_0\":\"Leaf (hash) of formatted message*\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)\":{\"notice\":\"Returns leaf of formatted message with provided fields.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"MessageHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xd56bf4956dacf8171f3ad4aeb3a5b7d8caa7cbe9e8b69dfc8d9bd876eebd9a72\",\"urls\":[\"bzz-raw://ddfeebc4974db727553a7ca169c2faa33d43beeb304939917f1452adf389c71b\",\"dweb:/ipfs/QmS8RKA433rvBfZwRkF8JkTHbQi5X7a4ArQQo3wcwaTeuj\"]}},\"version\":1}"},"hashes":{"body(bytes)":"c97c703a","destination(bytes)":"c81aa9c8","formatMessage(uint32,bytes32,uint32,uint32,bytes32,uint32,uint96,uint96,uint96,uint96,bytes)":"81d030ef","headerOffset()":"639c5570","leaf(bytes)":"d7a7a72c","messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes,bytes)":"46fad66e","messageVersion()":"52617f3c","nonce(bytes)":"4e765004","optimisticSeconds(bytes)":"7c1cfff9","origin(bytes)":"cb3eb0e1","recipient(bytes)":"985a5c31","recipientAddress(bytes)":"f45387ba","sender(bytes)":"6dc3c4f7","tips(bytes)":"045c6c0b"}},"solidity/MessageHarness.sol:Tips":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b0756d9546e7b2b4430f26d5c0341e164889948353dd82e994099eb78e3d3c6f64736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220b0756d9546e7b2b4430f26d5c0341e164889948353dd82e994099eb78e3d3c6f64736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = Tips.formatTips(\n            _updaterTip,\n            _relayerTip,\n            _proverTip,\n            _processorTip\n        );\n\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n\n    function messageVersion() public pure returns (uint16) {\n        return Message.MESSAGE_VERSION;\n    }\n\n    function headerOffset() public pure returns (uint16) {\n        return Message.HEADER_OFFSET;\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"41664:2999:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;41664:2999:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"41664:2999:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"stateVariables":{"OFFSET_UPDATER":{"details":"Tips memory layout [000 .. 002): version            uint16\t 2 bytes [002 .. 014): updaterTip         uint96\t12 bytes [014 .. 026): relayerTip         uint96\t12 bytes [026 .. 038): proverTip          uint96\t12 bytes [038 .. 050): processorTip       uint96\t12 bytes"}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"stateVariables\":{\"OFFSET_UPDATER\":{\"details\":\"Tips memory layout [000 .. 002): version            uint16\\t 2 bytes [002 .. 014): updaterTip         uint96\\t12 bytes [014 .. 026): relayerTip         uint96\\t12 bytes [026 .. 038): proverTip          uint96\\t12 bytes [038 .. 050): processorTip       uint96\\t12 bytes\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"Tips\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xd56bf4956dacf8171f3ad4aeb3a5b7d8caa7cbe9e8b69dfc8d9bd876eebd9a72\",\"urls\":[\"bzz-raw://ddfeebc4974db727553a7ca169c2faa33d43beeb304939917f1452adf389c71b\",\"dweb:/ipfs/QmS8RKA433rvBfZwRkF8JkTHbQi5X7a4ArQQo3wcwaTeuj\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c35e25f0946b278c613f5ebbafe60a8a7c609ce7200241743e59bf36c324e16f64736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220c35e25f0946b278c613f5ebbafe60a8a7c609ce7200241743e59bf36c324e16f64736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = Tips.formatTips(\n            _updaterTip,\n            _relayerTip,\n            _proverTip,\n            _processorTip\n        );\n\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n\n    function messageVersion() public pure returns (uint16) {\n        return Message.MESSAGE_VERSION;\n    }\n\n    function headerOffset() public pure returns (uint16) {\n        return Message.HEADER_OFFSET;\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"32274:1110:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;32274:1110:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"32274:1110:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xd56bf4956dacf8171f3ad4aeb3a5b7d8caa7cbe9e8b69dfc8d9bd876eebd9a72\",\"urls\":[\"bzz-raw://ddfeebc4974db727553a7ca169c2faa33d43beeb304939917f1452adf389c71b\",\"dweb:/ipfs/QmS8RKA433rvBfZwRkF8JkTHbQi5X7a4ArQQo3wcwaTeuj\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.sol:TypedMemView":{"code":"0x60c9610038600b82828239805160001a607314602b57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f26be3fc146038575b600080fd5b605e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000909116815260200160405180910390f3fea2646970667358221220c22f1018f82777d7b0a5e7495d6d8c35c5962e2ace30e17414b6ee6723f7aaad64736f6c634300080d0033","runtime-code":"0x730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f26be3fc146038575b600080fd5b605e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000909116815260200160405180910390f3fea2646970667358221220c22f1018f82777d7b0a5e7495d6d8c35c5962e2ace30e17414b6ee6723f7aaad64736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\n//\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    /**\n     * @dev This is only updated if the whole message structure is changed,\n     *      i.e. if a new part is added.\n     *      If already existing part is changed, the message version does not get bumped.\n     */\n    uint16 internal constant MESSAGE_VERSION = 1;\n\n    /// @dev Parts.Last is used only for marking the last element of the enum\n    enum Parts {\n        Version,\n        Header,\n        Tips,\n        Body,\n        Last\n    }\n\n    uint40 internal constant MESSAGE_TYPE = 1337;\n    uint40 internal constant HEADER_TYPE = uint40(Parts.Header);\n    uint40 internal constant TIPS_TYPE = uint40(Parts.Tips);\n    uint40 internal constant BODY_TYPE = uint40(Parts.Body);\n\n    modifier onlyMessage(bytes29 _view) {\n        _view.assertType(MESSAGE_TYPE);\n        _;\n    }\n\n    /**\n     * @dev Message memory layout\n     *      All offsets are stored for backwards compatibility\n     * [000 .. 002): version            uint16  2 bytes\n     * [002 .. 004): header offset = 8  uint16  2 bytes\n     * [004 .. 006): tips offset (AAA)  uint16  2 bytes\n     * [006 .. 008): body offset (BBB)  uint16  2 bytes\n     * [008 .. AAA): header             bytes   ? bytes\n     * [AAA .. BBB): tips               bytes   ? bytes\n     * [BBB .. CCC): body               bytes   ? bytes\n     */\n\n    /// @dev How much bytes is used for storing the version, or a single offset value\n    uint8 internal constant TWO_BYTES = 2;\n    /// @dev This value reflects the header offset in the latest message version\n    uint16 internal constant HEADER_OFFSET = TWO_BYTES * uint8(Parts.Last);\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        // Version + Offsets + Header + Tips are supposed to fit within 65535 bytes\n        uint16 tipsOffset = HEADER_OFFSET + uint16(_header.length);\n        uint16 bodyOffset = tipsOffset + uint16(_tips.length);\n        return\n            abi.encodePacked(\n                MESSAGE_VERSION,\n                HEADER_OFFSET,\n                tipsOffset,\n                bodyOffset,\n                _header,\n                _tips,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _header Formatted header\n     * @param _messageBody Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        bytes memory _header,\n        bytes memory _tips,\n        bytes memory _messageBody\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_header, _tips, _messageBody));\n    }\n\n    function messageView(bytes memory _message) internal pure returns (bytes29) {\n        return _message.ref(MESSAGE_TYPE);\n    }\n\n    /// @notice Returns message's header field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function header(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Header),\n                _loadOffset(_message, Parts.Tips),\n                HEADER_TYPE\n            );\n    }\n\n    /// @notice Returns message's tips field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function tips(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return\n            _between(\n                _message,\n                _loadOffset(_message, Parts.Tips),\n                _loadOffset(_message, Parts.Body),\n                TIPS_TYPE\n            );\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure onlyMessage(_message) returns (bytes29) {\n        return _between(_message, _loadOffset(_message, Parts.Body), _message.len(), BODY_TYPE);\n    }\n\n    /// @notice Returns leaf of the formatted message.\n    function leaf(bytes29 _message) internal pure onlyMessage(_message) returns (bytes32) {\n        // TODO: do we actually need this?\n        return _message.keccak();\n    }\n\n    function _between(\n        bytes29 _message,\n        uint256 _from,\n        uint256 _to,\n        uint40 _newType\n    ) private pure returns (bytes29) {\n        return _message.slice(_from, _to - _from, _newType);\n    }\n\n    /// @notice Loads offset for a given part of the message\n    function _loadOffset(bytes29 _message, Parts _part) private pure returns (uint256) {\n        return _message.indexUint(uint256(_part) * TWO_BYTES, TWO_BYTES);\n    }\n}\n\nlibrary Header {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant HEADER_VERSION = 1;\n\n    /**\n     * @dev Header memory layout\n     * [000 .. 002): version            uint16   2 bytes\n     * [002 .. 006): originDomain       uint32   4 bytes\n     * [006 .. 038): sender             bytes32 32 bytes\n     * [038 .. 042): nonce              uint32   4 bytes\n     * [042 .. 046): destinationDomain  uint32   4 bytes\n     * [046 .. 078): recipient          bytes32 32 bytes\n     * [078 .. 082): optimisticSeconds  uint32   4 bytes\n     */\n\n    uint256 internal constant OFFSET_ORIGIN = 2;\n    uint256 internal constant OFFSET_SENDER = 6;\n    uint256 internal constant OFFSET_NONCE = 38;\n    uint256 internal constant OFFSET_DESTINATION = 42;\n    uint256 internal constant OFFSET_RECIPIENT = 46;\n    uint256 internal constant OFFSET_OPTIMISTIC_SECONDS = 78;\n\n    modifier onlyHeader(bytes29 _view) {\n        _view.assertType(Message.HEADER_TYPE);\n        _;\n    }\n\n    function formatHeader(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                HEADER_VERSION,\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds\n            );\n    }\n\n    function headerView(bytes memory _header) internal pure returns (bytes29) {\n        return _header.ref(Message.HEADER_TYPE);\n    }\n\n    function headerVersion(bytes29 _header) internal pure onlyHeader(_header) returns (uint16) {\n        return uint16(_header.indexUint(0, 2));\n    }\n\n    /// @notice Returns header's origin field\n    function origin(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_ORIGIN, 4));\n    }\n\n    /// @notice Returns header's sender field\n    function sender(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_SENDER, 32);\n    }\n\n    /// @notice Returns header's nonce field\n    function nonce(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_NONCE, 4));\n    }\n\n    /// @notice Returns header's destination field\n    function destination(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_DESTINATION, 4));\n    }\n\n    /// @notice Returns header's recipient field as bytes32\n    function recipient(bytes29 _header) internal pure onlyHeader(_header) returns (bytes32) {\n        return _header.index(OFFSET_RECIPIENT, 32);\n    }\n\n    /// @notice Returns header's optimistic seconds field\n    function optimisticSeconds(bytes29 _header) internal pure onlyHeader(_header) returns (uint32) {\n        return uint32(_header.indexUint(OFFSET_OPTIMISTIC_SECONDS, 4));\n    }\n\n    /// @notice Returns header's recipient field as an address\n    function recipientAddress(bytes29 _header) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_header));\n    }\n}\n\nlibrary Tips {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    uint16 internal constant TIPS_VERSION = 1;\n\n    /**\n     * @dev Tips memory layout\n     * [000 .. 002): version            uint16\t 2 bytes\n     * [002 .. 014): updaterTip         uint96\t12 bytes\n     * [014 .. 026): relayerTip         uint96\t12 bytes\n     * [026 .. 038): proverTip          uint96\t12 bytes\n     * [038 .. 050): processorTip       uint96\t12 bytes\n     */\n\n    uint256 internal constant OFFSET_UPDATER = 2;\n    uint256 internal constant OFFSET_RELAYER = 14;\n    uint256 internal constant OFFSET_PROVER = 26;\n    uint256 internal constant OFFSET_PROCESSOR = 38;\n\n    modifier onlyTips(bytes29 _view) {\n        _view.assertType(Message.TIPS_TYPE);\n        _;\n    }\n\n    /**\n     * @notice Returns formatted (packed) tips with provided fields\n     * @param _updaterTip Tip for the Updater\n     * @param _relayerTip Tip for the Relayer\n     * @param _proverTip Tip for the Prover\n     * @param _processorTip Tip for the Processor\n     * @return Formatted tips\n     **/\n    function formatTips(\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip\n    ) internal pure returns (bytes memory) {\n        return abi.encodePacked(TIPS_VERSION, _updaterTip, _relayerTip, _proverTip, _processorTip);\n    }\n\n    /**\n     * @notice Returns formatted empty tips\n     * @return Formatted tips\n     **/\n    function emptyTips() internal pure returns (bytes memory) {\n        return formatTips(0, 0, 0, 0);\n    }\n\n    /// @notice Returns view for the formatted tips\n    /// @dev Providing anything other than formatted tips will lead to unexpected behavior\n    function tipsView(bytes memory _tips) internal pure returns (bytes29) {\n        return _tips.ref(Message.TIPS_TYPE);\n    }\n\n    /// @notice Returns version of formatted tips\n    function tipsVersion(bytes29 _tips) internal pure onlyTips(_tips) returns (uint16) {\n        return uint16(_tips.indexUint(0, 2));\n    }\n\n    /// @notice Returns updaterTip field\n    function updaterTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_UPDATER, 12));\n    }\n\n    /// @notice Returns relayerTip field\n    function relayerTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_RELAYER, 12));\n    }\n\n    /// @notice Returns proverTip field\n    function proverTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROVER, 12));\n    }\n\n    /// @notice Returns processorTip field\n    function processorTip(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return uint32(_tips.indexUint(OFFSET_PROCESSOR, 12));\n    }\n\n    function totalTips(bytes29 _tips) internal pure onlyTips(_tips) returns (uint96) {\n        return updaterTip(_tips) + relayerTip(_tips) + proverTip(_tips) + processorTip(_tips);\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes;\n    using Message for bytes29;\n    using Header for bytes29;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        // tips params\n        uint96 _updaterTip,\n        uint96 _relayerTip,\n        uint96 _proverTip,\n        uint96 _processorTip,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        bytes memory _tips = Tips.formatTips(\n            _updaterTip,\n            _relayerTip,\n            _proverTip,\n            _processorTip\n        );\n\n        bytes memory _header = Header.formatHeader(\n            _originDomain,\n            _sender,\n            _nonce,\n            _destinationDomain,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.formatMessage(_header, _tips, _messageBody);\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _tips,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        bytes memory _header = Header.formatHeader(\n            _origin,\n            _sender,\n            _nonce,\n            _destination,\n            _recipient,\n            _optimisticSeconds\n        );\n        return Message.messageHash(_header, _tips, _body);\n    }\n\n    function tips(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().tips().clone();\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.messageView().body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().header().recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.messageView().header().recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.messageView().header().optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external pure returns (bytes32) {\n        return _message.messageView().leaf();\n    }\n\n    function messageVersion() public pure returns (uint16) {\n        return Message.MESSAGE_VERSION;\n    }\n\n    function headerOffset() public pure returns (uint16) {\n        return Message.HEADER_OFFSET;\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"26:32242:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;26:32242:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"26:32242:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;2539:94;;;;;;;;198:66:1;186:79;;;168:98;;156:2;141:18;2539:94:0;;;;;;","abiDefinition":[{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0xd56bf4956dacf8171f3ad4aeb3a5b7d8caa7cbe9e8b69dfc8d9bd876eebd9a72\",\"urls\":[\"bzz-raw://ddfeebc4974db727553a7ca169c2faa33d43beeb304939917f1452adf389c71b\",\"dweb:/ipfs/QmS8RKA433rvBfZwRkF8JkTHbQi5X7a4ArQQo3wcwaTeuj\"]}},\"version\":1}"},"hashes":{"NULL()":"f26be3fc"}}}