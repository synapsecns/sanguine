{"solidity/MessageHarness.sol:Message":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208646c6017fddc2d31041252c0c6093f8ea36f61cb11b6bce878eae37636b3fbb64736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea26469706673582212208646c6017fddc2d31041252c0c6093f8ea36f61cb11b6bce878eae37636b3fbb64736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\n// \nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Number of bytes in formatted message before `body` field\n    uint256 internal constant PREFIX_LENGTH = 80;\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _originDomain Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce\n     * @param _destinationDomain Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _body\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_origin, _sender, _nonce, _destination, _recipient, _optimisticSeconds, _body));\n    }\n\n    /// @notice Returns message's origin field\n    function origin(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(0, 4));\n    }\n\n    /// @notice Returns message's sender field\n    function sender(bytes29 _message) internal pure returns (bytes32) {\n        return _message.index(4, 32);\n    }\n\n    /// @notice Returns message's nonce field\n    function nonce(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(36, 4));\n    }\n\n    /// @notice Returns message's destination field\n    function destination(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(40, 4));\n    }\n\n    /// @notice Returns message's recipient field as bytes32\n    function recipient(bytes29 _message) internal pure returns (bytes32) {\n        return _message.index(44, 32);\n    }\n\n    /// @notice Returns the optimistic seconds from the message\n    function optimisticSeconds(bytes29 _message) internal pure returns (uint32){\n        return uint32(_message.indexUint(76, 4));\n    }\n\n    /// @notice Returns message's recipient field as an address\n    function recipientAddress(bytes29 _message) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_message));\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure returns (bytes29) {\n        return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\n    }\n\n    function leaf(bytes29 _message) internal view returns (bytes32) {\n        return\n            messageHash(\n                origin(_message),\n                sender(_message),\n                nonce(_message),\n                destination(_message),\n                recipient(_message),\n                optimisticSeconds(_message),\n                TypedMemView.clone(body(_message))\n            );\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            Message.formatMessage(\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        return Message.messageHash(_origin, _sender, _nonce, _destination, _recipient, _optimisticSeconds, _body);\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.ref(0).body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.ref(0).sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.ref(0).recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.ref(0).recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external view returns (bytes32) {\n        return _message.ref(0).leaf();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"33386:4048:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;33386:4048:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"33386:4048:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"Message\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0x409ea03fedc806ba4fb146f037253bb4b771c009e7eeed09af10f67a10d46c62\",\"urls\":[\"bzz-raw://afd27bb01573e8f9dadc6a7c853fc80ba941f70a85aa005b076d256c4771b0bd\",\"dweb:/ipfs/QmaJYLJmRuog3Xb6tCccHrjtcvRcbHkn9H8T4KFp49UjkV\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.sol:MessageHarness":{"code":"0x608060405234801561001057600080fd5b50611223806100206000396000f3fe608060405234801561001057600080fd5b50600436106100c95760003560e01c80639a1b300a11610081578063cb3eb0e11161005b578063cb3eb0e11461019b578063d7a7a72c146101ae578063f45387ba146101c157600080fd5b80639a1b300a14610155578063c81aa9c814610175578063c97c703a1461018857600080fd5b80636dc3c4f7116100b25780636dc3c4f71461011c5780637c1cfff91461012f578063985a5c311461014257600080fd5b8063311f82e3146100ce5780634e765004146100f4575b600080fd5b6100e16100dc366004610e32565b6101f9565b6040519081526020015b60405180910390f35b610107610102366004610ec5565b610216565b60405163ffffffff90911681526020016100eb565b6100e161012a366004610ec5565b610236565b61010761013d366004610ec5565b610250565b6100e1610150366004610ec5565b61026a565b610168610163366004610e32565b610284565b6040516100eb9190610f74565b610107610183366004610ec5565b610295565b610168610196366004610ec5565b6102af565b6101076101a9366004610ec5565b6102d8565b6100e16101bc366004610ec5565b6102f2565b6101d46101cf366004610ec5565b61030c565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100eb565b600061020a88888888888888610326565b98975050505050505050565b6000610230610225838361034b565b62ffffff191661036f565b92915050565b6000610230610245838361034b565b62ffffff1916610384565b600061023061025f838361034b565b62ffffff1916610399565b6000610230610279838361034b565b62ffffff19166103ae565b606061020a888888888888886103c3565b60006102306102a4838361034b565b62ffffff19166103fe565b60606102306102cd6102c284600061034b565b62ffffff1916610413565b62ffffff1916610446565b60006102306102e7838361034b565b62ffffff1916610499565b6000610230610301838361034b565b62ffffff19166104ad565b600061023061031b838361034b565b62ffffff19166104fe565b6000610337888888888888886103c3565b805190602001209050979650505050505050565b81516000906020840161036664ffffffffff8516828461050f565b95945050505050565b600061023062ffffff19831660246004610559565b600061023062ffffff19831660046020610589565b600061023062ffffff198316604c6004610559565b600061023062ffffff198316602c6020610589565b6060878787878787876040516020016103e29796959493929190610f87565b6040516020818303038152906040529050979650505050505050565b600061023062ffffff19831660286004610559565b6000610230605061043681601886901c6bffffffffffffffffffffffff16611035565b62ffffff19851691906000610784565b60606000806104638460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506040519150819250610488848360200161080a565b508181016020016040529052919050565b600061023062ffffff198316826004610559565b60006102306104bb83610499565b6104c484610384565b6104cd8561036f565b6104d6866103fe565b6104df876103ae565b6104e888610399565b6104f96104f48a610413565b610446565b610326565b600061023061050c836103ae565b90565b60008061051c838561104c565b905060405181111561052c575060005b806000036105415762ffffff19915050610552565b5050606083811b8317901b811760181b5b9392505050565b6000610566826020611064565b610571906008611087565b60ff1661057f858585610589565b901c949350505050565b60008160ff1660000361059e57506000610552565b6105b68460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff166105d160ff84168561104c565b111561066c576106306105f28560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff166106188660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff166109e3565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106639190610f74565b60405180910390fd5b60208260ff161115610700576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e2033322062797465730000000000006064820152608401610663565b60088202600061071e8660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60008061079f8660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506107b886610a51565b846107c3878461104c565b6107cd919061104c565b11156107e05762ffffff19915050610802565b6107ea858261104c565b90506107fe8364ffffffffff16828661050f565b9150505b949350505050565b600062ffffff19808416036108a1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f54797065644d656d566965772f636f7079546f202d204e756c6c20706f696e7460448201527f65722064657265660000000000000000000000000000000000000000000000006064820152608401610663565b6108aa83610a99565b610936576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f54797065644d656d566965772f636f7079546f202d20496e76616c696420706f60448201527f696e7465722064657265660000000000000000000000000000000000000000006064820152608401610663565b60006109508460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061097a8560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600060405190508481111561099f5760206060fd5b8285848460045afa506109d96109b58760d81c90565b70ffffffffff000000000000000000000000606091821b168717901b841760181b90565b9695505050505050565b606060006109f086610ad6565b91505060006109fe86610ad6565b9150506000610a0c86610ad6565b9150506000610a1a86610ad6565b91505083838383604051602001610a3494939291906110b0565b604051602081830303815290604052945050505050949350505050565b6000610a6b8260181c6bffffffffffffffffffffffff1690565b610a838360781c6bffffffffffffffffffffffff1690565b016bffffffffffffffffffffffff169050919050565b6000610aa58260d81c90565b64ffffffffff1664ffffffffff03610abf57506000919050565b6000610aca83610a51565b60405110199392505050565b600080601f5b600f8160ff161115610b49576000610af5826008611087565b60ff1685901c9050610b0681610bc0565b61ffff16841793508160ff16601014610b2157601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610adc565b50600f5b60ff8160ff161015610bba576000610b66826008611087565b60ff1685901c9050610b7781610bc0565b61ffff16831792508160ff16600014610b9257601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610b4d565b50915091565b6000610bd260048360ff16901c610bf2565b60ff1661ffff919091161760081b610be982610bf2565b60ff1617919050565b600060f08083179060ff82169003610c0d5750603092915050565b8060ff1660f103610c215750603192915050565b8060ff1660f203610c355750603292915050565b8060ff1660f303610c495750603392915050565b8060ff1660f403610c5d5750603492915050565b8060ff1660f503610c715750603592915050565b8060ff1660f603610c855750603692915050565b8060ff1660f703610c995750603792915050565b8060ff1660f803610cad5750603892915050565b8060ff1660f903610cc15750603992915050565b8060ff1660fa03610cd55750606192915050565b8060ff1660fb03610ce95750606292915050565b8060ff1660fc03610cfd5750606392915050565b8060ff1660fd03610d115750606492915050565b8060ff1660fe03610d255750606592915050565b8060ff1660ff03610d395750606692915050565b50919050565b803563ffffffff81168114610d5357600080fd5b919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d9857600080fd5b813567ffffffffffffffff80821115610db357610db3610d58565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610df957610df9610d58565b81604052838152866020858801011115610e1257600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600080600080600060e0888a031215610e4d57600080fd5b610e5688610d3f565b965060208801359550610e6b60408901610d3f565b9450610e7960608901610d3f565b935060808801359250610e8e60a08901610d3f565b915060c088013567ffffffffffffffff811115610eaa57600080fd5b610eb68a828b01610d87565b91505092959891949750929550565b600060208284031215610ed757600080fd5b813567ffffffffffffffff811115610eee57600080fd5b61080284828501610d87565b60005b83811015610f15578181015183820152602001610efd565b83811115610f24576000848401525b50505050565b60008151808452610f42816020860160208601610efa565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006105526020830184610f2a565b60007fffffffff00000000000000000000000000000000000000000000000000000000808a60e01b168352886004840152808860e01b166024840152808760e01b16602884015285602c840152808560e01b16604c840152508251610ff3816050850160208701610efa565b9190910160500198975050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008282101561104757611047611006565b500390565b6000821982111561105f5761105f611006565b500190565b600060ff821660ff84168082101561107e5761107e611006565b90039392505050565b600060ff821660ff84168160ff04811182151516156110a8576110a8611006565b029392505050565b7f54797065644d656d566965772f696e646578202d204f76657272616e2074686581527f20766965772e20536c696365206973206174203078000000000000000000000060208201527fffffffffffff000000000000000000000000000000000000000000000000000060d086811b821660358401527f2077697468206c656e6774682030780000000000000000000000000000000000603b840181905286821b8316604a8501527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060508501527f7800000000000000000000000000000000000000000000000000000000000000607085015285821b83166071850152607784015283901b1660868201527f2e00000000000000000000000000000000000000000000000000000000000000608c8201526000608d82016109d956fea2646970667358221220d6f14ac7903e5fe192d3954445afcd0a84175f2fb356db10b29a79a89fb43ece64736f6c634300080d0033","runtime-code":"0x608060405234801561001057600080fd5b50600436106100c95760003560e01c80639a1b300a11610081578063cb3eb0e11161005b578063cb3eb0e11461019b578063d7a7a72c146101ae578063f45387ba146101c157600080fd5b80639a1b300a14610155578063c81aa9c814610175578063c97c703a1461018857600080fd5b80636dc3c4f7116100b25780636dc3c4f71461011c5780637c1cfff91461012f578063985a5c311461014257600080fd5b8063311f82e3146100ce5780634e765004146100f4575b600080fd5b6100e16100dc366004610e32565b6101f9565b6040519081526020015b60405180910390f35b610107610102366004610ec5565b610216565b60405163ffffffff90911681526020016100eb565b6100e161012a366004610ec5565b610236565b61010761013d366004610ec5565b610250565b6100e1610150366004610ec5565b61026a565b610168610163366004610e32565b610284565b6040516100eb9190610f74565b610107610183366004610ec5565b610295565b610168610196366004610ec5565b6102af565b6101076101a9366004610ec5565b6102d8565b6100e16101bc366004610ec5565b6102f2565b6101d46101cf366004610ec5565b61030c565b60405173ffffffffffffffffffffffffffffffffffffffff90911681526020016100eb565b600061020a88888888888888610326565b98975050505050505050565b6000610230610225838361034b565b62ffffff191661036f565b92915050565b6000610230610245838361034b565b62ffffff1916610384565b600061023061025f838361034b565b62ffffff1916610399565b6000610230610279838361034b565b62ffffff19166103ae565b606061020a888888888888886103c3565b60006102306102a4838361034b565b62ffffff19166103fe565b60606102306102cd6102c284600061034b565b62ffffff1916610413565b62ffffff1916610446565b60006102306102e7838361034b565b62ffffff1916610499565b6000610230610301838361034b565b62ffffff19166104ad565b600061023061031b838361034b565b62ffffff19166104fe565b6000610337888888888888886103c3565b805190602001209050979650505050505050565b81516000906020840161036664ffffffffff8516828461050f565b95945050505050565b600061023062ffffff19831660246004610559565b600061023062ffffff19831660046020610589565b600061023062ffffff198316604c6004610559565b600061023062ffffff198316602c6020610589565b6060878787878787876040516020016103e29796959493929190610f87565b6040516020818303038152906040529050979650505050505050565b600061023062ffffff19831660286004610559565b6000610230605061043681601886901c6bffffffffffffffffffffffff16611035565b62ffffff19851691906000610784565b60606000806104638460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506040519150819250610488848360200161080a565b508181016020016040529052919050565b600061023062ffffff198316826004610559565b60006102306104bb83610499565b6104c484610384565b6104cd8561036f565b6104d6866103fe565b6104df876103ae565b6104e888610399565b6104f96104f48a610413565b610446565b610326565b600061023061050c836103ae565b90565b60008061051c838561104c565b905060405181111561052c575060005b806000036105415762ffffff19915050610552565b5050606083811b8317901b811760181b5b9392505050565b6000610566826020611064565b610571906008611087565b60ff1661057f858585610589565b901c949350505050565b60008160ff1660000361059e57506000610552565b6105b68460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff166105d160ff84168561104c565b111561066c576106306105f28560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff166106188660181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16858560ff166109e3565b6040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016106639190610f74565b60405180910390fd5b60208260ff161115610700576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152603a60248201527f54797065644d656d566965772f696e646578202d20417474656d70746564207460448201527f6f20696e646578206d6f7265207468616e2033322062797465730000000000006064820152608401610663565b60088202600061071e8660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff16905060007f80000000000000000000000000000000000000000000000000000000000000007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84011d91909501511695945050505050565b60008061079f8660781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff1690506107b886610a51565b846107c3878461104c565b6107cd919061104c565b11156107e05762ffffff19915050610802565b6107ea858261104c565b90506107fe8364ffffffffff16828661050f565b9150505b949350505050565b600062ffffff19808416036108a1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602860248201527f54797065644d656d566965772f636f7079546f202d204e756c6c20706f696e7460448201527f65722064657265660000000000000000000000000000000000000000000000006064820152608401610663565b6108aa83610a99565b610936576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152602b60248201527f54797065644d656d566965772f636f7079546f202d20496e76616c696420706f60448201527f696e7465722064657265660000000000000000000000000000000000000000006064820152608401610663565b60006109508460181c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600061097a8560781c6bffffffffffffffffffffffff1690565b6bffffffffffffffffffffffff169050600060405190508481111561099f5760206060fd5b8285848460045afa506109d96109b58760d81c90565b70ffffffffff000000000000000000000000606091821b168717901b841760181b90565b9695505050505050565b606060006109f086610ad6565b91505060006109fe86610ad6565b9150506000610a0c86610ad6565b9150506000610a1a86610ad6565b91505083838383604051602001610a3494939291906110b0565b604051602081830303815290604052945050505050949350505050565b6000610a6b8260181c6bffffffffffffffffffffffff1690565b610a838360781c6bffffffffffffffffffffffff1690565b016bffffffffffffffffffffffff169050919050565b6000610aa58260d81c90565b64ffffffffff1664ffffffffff03610abf57506000919050565b6000610aca83610a51565b60405110199392505050565b600080601f5b600f8160ff161115610b49576000610af5826008611087565b60ff1685901c9050610b0681610bc0565b61ffff16841793508160ff16601014610b2157601084901b93505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610adc565b50600f5b60ff8160ff161015610bba576000610b66826008611087565b60ff1685901c9050610b7781610bc0565b61ffff16831792508160ff16600014610b9257601083901b92505b507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01610b4d565b50915091565b6000610bd260048360ff16901c610bf2565b60ff1661ffff919091161760081b610be982610bf2565b60ff1617919050565b600060f08083179060ff82169003610c0d5750603092915050565b8060ff1660f103610c215750603192915050565b8060ff1660f203610c355750603292915050565b8060ff1660f303610c495750603392915050565b8060ff1660f403610c5d5750603492915050565b8060ff1660f503610c715750603592915050565b8060ff1660f603610c855750603692915050565b8060ff1660f703610c995750603792915050565b8060ff1660f803610cad5750603892915050565b8060ff1660f903610cc15750603992915050565b8060ff1660fa03610cd55750606192915050565b8060ff1660fb03610ce95750606292915050565b8060ff1660fc03610cfd5750606392915050565b8060ff1660fd03610d115750606492915050565b8060ff1660fe03610d255750606592915050565b8060ff1660ff03610d395750606692915050565b50919050565b803563ffffffff81168114610d5357600080fd5b919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b600082601f830112610d9857600080fd5b813567ffffffffffffffff80821115610db357610db3610d58565b604051601f83017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0908116603f01168101908282118183101715610df957610df9610d58565b81604052838152866020858801011115610e1257600080fd5b836020870160208301376000602085830101528094505050505092915050565b600080600080600080600060e0888a031215610e4d57600080fd5b610e5688610d3f565b965060208801359550610e6b60408901610d3f565b9450610e7960608901610d3f565b935060808801359250610e8e60a08901610d3f565b915060c088013567ffffffffffffffff811115610eaa57600080fd5b610eb68a828b01610d87565b91505092959891949750929550565b600060208284031215610ed757600080fd5b813567ffffffffffffffff811115610eee57600080fd5b61080284828501610d87565b60005b83811015610f15578181015183820152602001610efd565b83811115610f24576000848401525b50505050565b60008151808452610f42816020860160208601610efa565b601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0169290920160200192915050565b6020815260006105526020830184610f2a565b60007fffffffff00000000000000000000000000000000000000000000000000000000808a60e01b168352886004840152808860e01b166024840152808760e01b16602884015285602c840152808560e01b16604c840152508251610ff3816050850160208701610efa565b9190910160500198975050505050505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60008282101561104757611047611006565b500390565b6000821982111561105f5761105f611006565b500190565b600060ff821660ff84168082101561107e5761107e611006565b90039392505050565b600060ff821660ff84168160ff04811182151516156110a8576110a8611006565b029392505050565b7f54797065644d656d566965772f696e646578202d204f76657272616e2074686581527f20766965772e20536c696365206973206174203078000000000000000000000060208201527fffffffffffff000000000000000000000000000000000000000000000000000060d086811b821660358401527f2077697468206c656e6774682030780000000000000000000000000000000000603b840181905286821b8316604a8501527f2e20417474656d7074656420746f20696e646578206174206f6666736574203060508501527f7800000000000000000000000000000000000000000000000000000000000000607085015285821b83166071850152607784015283901b1660868201527f2e00000000000000000000000000000000000000000000000000000000000000608c8201526000608d82016109d956fea2646970667358221220d6f14ac7903e5fe192d3954445afcd0a84175f2fb356db10b29a79a89fb43ece64736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\n// \nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Number of bytes in formatted message before `body` field\n    uint256 internal constant PREFIX_LENGTH = 80;\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _originDomain Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce\n     * @param _destinationDomain Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _body\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_origin, _sender, _nonce, _destination, _recipient, _optimisticSeconds, _body));\n    }\n\n    /// @notice Returns message's origin field\n    function origin(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(0, 4));\n    }\n\n    /// @notice Returns message's sender field\n    function sender(bytes29 _message) internal pure returns (bytes32) {\n        return _message.index(4, 32);\n    }\n\n    /// @notice Returns message's nonce field\n    function nonce(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(36, 4));\n    }\n\n    /// @notice Returns message's destination field\n    function destination(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(40, 4));\n    }\n\n    /// @notice Returns message's recipient field as bytes32\n    function recipient(bytes29 _message) internal pure returns (bytes32) {\n        return _message.index(44, 32);\n    }\n\n    /// @notice Returns the optimistic seconds from the message\n    function optimisticSeconds(bytes29 _message) internal pure returns (uint32){\n        return uint32(_message.indexUint(76, 4));\n    }\n\n    /// @notice Returns message's recipient field as an address\n    function recipientAddress(bytes29 _message) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_message));\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure returns (bytes29) {\n        return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\n    }\n\n    function leaf(bytes29 _message) internal view returns (bytes32) {\n        return\n            messageHash(\n                origin(_message),\n                sender(_message),\n                nonce(_message),\n                destination(_message),\n                recipient(_message),\n                optimisticSeconds(_message),\n                TypedMemView.clone(body(_message))\n            );\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            Message.formatMessage(\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        return Message.messageHash(_origin, _sender, _nonce, _destination, _recipient, _optimisticSeconds, _body);\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.ref(0).body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.ref(0).sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.ref(0).recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.ref(0).recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external view returns (bytes32) {\n        return _message.ref(0).leaf();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"37440:2713:0:-:0;;;;;;;;;;;;;;;;;;;","srcMapRuntime":"37440:2713:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;38598:371;;;;;;:::i;:::-;;:::i;:::-;;;2052:25:1;;;2040:2;2025:18;38598:371:0;;;;;;;;39358:116;;;;;;:::i;:::-;;:::i;:::-;;;2587:10:1;2575:23;;;2557:42;;2545:2;2530:18;39358:116:0;2413:192:1;39233:119:0;;;;;;:::i;:::-;;:::i;39890:140::-;;;;;;:::i;:::-;;:::i;39614:125::-;;;;;;:::i;:::-;;:::i;37572:556::-;;;;;;:::i;:::-;;:::i;:::-;;;;;;;:::i;39480:128::-;;;;;;:::i;:::-;;:::i;38975:::-;;;;;;:::i;:::-;;:::i;39109:118::-;;;;;;:::i;:::-;;:::i;40036:115::-;;;;;;:::i;:::-;;:::i;39745:139::-;;;;;;:::i;:::-;;:::i;:::-;;;3592:42:1;3580:55;;;3562:74;;3550:2;3535:18;39745:139:0;3416:226:1;38598:371:0;38838:7;38864:98;38884:7;38893;38902:6;38910:12;38924:10;38936:18;38956:5;38864:19;:98::i;:::-;38857:105;38598:371;-1:-1:-1;;;;;;;;38598:371:0:o;39358:116::-;39419:6;39444:23;:15;:8;39419:6;39444:12;:15::i;:::-;-1:-1:-1;;39444:21:0;;:23::i;:::-;39437:30;39358:116;-1:-1:-1;;39358:116:0:o;39233:119::-;39295:7;39321:24;:15;:8;39295:7;39321:12;:15::i;:::-;-1:-1:-1;;39321:22:0;;:24::i;39890:140::-;39963:6;39988:35;:15;:8;39963:6;39988:12;:15::i;:::-;-1:-1:-1;;39988:33:0;;:35::i;39614:125::-;39679:7;39705:27;:15;:8;39679:7;39705:12;:15::i;:::-;-1:-1:-1;;39705:25:0;;:27::i;37572:556::-;37833:12;37876:245;37915:13;37946:7;37971:6;37995:18;38031:10;38059:18;38095:12;37876:21;:245::i;39480:128::-;39547:6;39572:29;:15;:8;39547:6;39572:12;:15::i;:::-;-1:-1:-1;;39572:27:0;;:29::i;38975:128::-;39035:12;39066:30;:22;:15;:8;39079:1;39066:12;:15::i;:::-;-1:-1:-1;;39066:20:0;;:22::i;:::-;-1:-1:-1;;39066:28:0;;:30::i;39109:118::-;39171:6;39196:24;:15;:8;39171:6;39196:12;:15::i;:::-;-1:-1:-1;;39196:22:0;;:24::i;40036:115::-;40096:7;40122:22;:15;:8;40096:7;40122:12;:15::i;:::-;-1:-1:-1;;40122:20:0;;:22::i;39745:139::-;39817:7;39843:34;:15;:8;39817:7;39843:12;:15::i;:::-;-1:-1:-1;;39843:32:0;;:34::i;35078:378::-;35320:7;35356:92;35370:7;35379;35388:6;35396:12;35410:10;35422:18;35442:5;35356:13;:92::i;:::-;35346:103;;;;;;35339:110;;35078:378;;;;;;;;;:::o;13659:359::-;13763:10;;13729:7;;13910:4;13901:14;;13985:26;;;;13901:14;13763:10;13985:5;:26::i;:::-;13978:33;13659:359;-1:-1:-1;;;;;13659:359:0:o;35846:121::-;35902:6;35934:25;-1:-1:-1;;35934:18:0;;35953:2;35957:1;35934:18;:25::i;35683:111::-;35740:7;35766:21;-1:-1:-1;;35766:14:0;;35781:1;35784:2;35766:14;:21::i;36404:132::-;36472:6;36503:25;-1:-1:-1;;36503:18:0;;36522:2;36526:1;36503:18;:25::i;36219:115::-;36279:7;36305:22;-1:-1:-1;;36305:14:0;;36320:2;36324;36305:14;:22::i;34055:553::-;34318:12;34395:13;34426:7;34451:6;34475:18;34511:10;34539:18;34575:12;34361:240;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;34342:259;;34055:553;;;;;;;;;:::o;36025:127::-;36087:6;36119:25;-1:-1:-1;;36119:18:0;;36138:2;36142:1;36119:18;:25::i;36875:152::-;36930:7;36956:64;33585:2;36986:30;33585:2;16496;16492:16;;;2674:26;16488:28;36986:30;:::i;:::-;-1:-1:-1;;36956:14:0;;;:64;37018:1;36956:14;:64::i;28312:632::-;28367:16;28395:11;28416:12;28431;28435:7;16496:2;16492:16;2674:26;16488:28;;16250:282;28431:12;28416:27;;;;28553:4;28547:11;28540:18;;28608:3;28601:10;;28654:33;28667:7;28676:3;28682:4;28676:10;28654:12;:33::i;:::-;-1:-1:-1;28811:14:0;;;28827:4;28807:25;28801:4;28794:39;28874:17;;28312:632;;-1:-1:-1;28312:632:0:o;35509:121::-;35566:6;35598:24;-1:-1:-1;;35598:18:0;;35566:6;35620:1;35598:18;:24::i;37033:399::-;37088:7;37126:299;37155:16;37162:8;37155:6;:16::i;:::-;37189;37196:8;37189:6;:16::i;:::-;37223:15;37229:8;37223:5;:15::i;:::-;37256:21;37268:8;37256:11;:21::i;:::-;37295:19;37305:8;37295:9;:19::i;:::-;37332:27;37350:8;37332:17;:27::i;:::-;37377:34;37396:14;37401:8;37396:4;:14::i;:::-;37377:18;:34::i;:::-;37126:11;:299::i;36606:147::-;36673:7;36699:47;36726:19;36736:8;36726:9;:19::i;:::-;33368:4;33255:127;12800:462;12911:15;;12953:11;12960:4;12953;:11;:::i;:::-;12938:26;;13079:4;13073:11;13067:4;13064:21;13061:66;;;-1:-1:-1;13112:1:0;13061:66;13150:4;13158:1;13150:9;13146:51;;-1:-1:-1;;13175:11:0;;;;;13146:51;-1:-1:-1;;12069:2:0;12065:27;;;12139:17;;12131:26;;12203:17;;12199:2;12195:26;12800:462;;;;;;:::o;21125:221::-;21244:14;21322:11;21327:6;21322:2;:11;:::i;:::-;21321:17;;21337:1;21321:17;:::i;:::-;21277:62;;21285:30;21291:7;21300:6;21308;21285:5;:30::i;:::-;21277:62;;;21125:221;-1:-1:-1;;;;21125:221:0:o;20008:771::-;20123:14;20153:6;:11;;20163:1;20153:11;20149:59;;-1:-1:-1;20195:1:0;20180:17;;20149:59;20239:12;20243:7;16496:2;16492:16;2674:26;16488:28;;16250:282;20239:12;20221:30;;:15;;;;:6;:15;:::i;:::-;:30;20217:137;;;20274:68;20290:12;20294:7;15390:3;15386:17;2674:26;15382:29;;15063:364;20290:12;20274:68;;20304:12;20308:7;16496:2;16492:16;2674:26;16488:28;;16250:282;20304:12;20274:68;;20318:6;20334;20326:15;;20274;:68::i;:::-;20267:76;;;;;;;;;;;:::i;:::-;;;;;;;;20217:137;20381:2;20371:6;:12;;;;20363:83;;;;;;;5798:2:1;20363:83:0;;;5780:21:1;5837:2;5817:18;;;5810:30;5876:34;5856:18;;;5849:62;5947:28;5927:18;;;5920:56;5993:19;;20363:83:0;5596:422:1;20363:83:0;20527:1;20518:10;;20457:15;20563:12;20567:7;15390:3;15386:17;2674:26;15382:29;;15063:364;20563:12;20548:27;;;-1:-1:-1;20585:13:0;7492:66;7462:12;;;7441:131;20737:17;;;;20731:24;20727:36;;;-1:-1:-1;;;;;20008:771:0:o;17133:399::-;17272:7;17291:12;17306;17310:7;15390:3;15386:17;2674:26;15382:29;;15063:364;17306:12;17291:27;;;;17402:12;17406:7;17402:3;:12::i;:::-;17395:4;17379:13;17386:6;17379:4;:13;:::i;:::-;:20;;;;:::i;:::-;:35;17375:77;;;-1:-1:-1;;17430:11:0;;;;;17375:77;17469:13;17476:6;17469:4;:13;:::i;:::-;17462:20;;17499:26;17505:7;17499:26;;17514:4;17520;17499:5;:26::i;:::-;17492:33;;;17133:399;;;;;;;:::o;27040:902::-;27118:15;-1:-1:-1;;7976:15:0;;;;27145:69;;;;;;;6225:2:1;27145:69:0;;;6207:21:1;6264:2;6244:18;;;6237:30;6303:34;6283:18;;;6276:62;6374:10;6354:18;;;6347:38;6402:19;;27145:69:0;6023:404:1;27145:69:0;27232:16;27240:7;27232;:16::i;:::-;27224:72;;;;;;;6634:2:1;27224:72:0;;;6616:21:1;6673:2;6653:18;;;6646:30;6712:34;6692:18;;;6685:62;6783:13;6763:18;;;6756:41;6814:19;;27224:72:0;6432:407:1;27224:72:0;27306:12;27321;27325:7;16496:2;16492:16;2674:26;16488:28;;16250:282;27321:12;27306:27;;;;27343:15;27361:12;27365:7;15390:3;15386:17;2674:26;15382:29;;15063:364;27361:12;27343:30;;;;27384:11;27505:4;27499:11;27492:18;;27592:7;27587:3;27584:16;27581:94;;;27632:4;27626;27619:18;27581:94;27847:4;27838:7;27832:4;27823:7;27820:1;27813:5;27802:50;27798:55;27883:52;27904:15;27911:7;14421:3;14417:17;;14210:268;27904:15;12065:27;12069:2;12065:27;;;;12139:17;;12131:26;;12203:17;;12199:2;12195:26;;11815:446;27883:52;27873:62;27040:902;-1:-1:-1;;;;;;27040:902:0:o;18765:741::-;18911:17;18943:9;18956:15;18966:4;18956:9;:15::i;:::-;18940:31;;;18984:9;18997:15;19007:4;18997:9;:15::i;:::-;18981:31;;;19025:9;19038:17;19048:6;19038:9;:17::i;:::-;19022:33;;;19068:9;19081:17;19091:6;19081:9;:17::i;:::-;19065:33;;;19248:1;19310;19390;19452;19134:355;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;19108:391;;18930:576;;;;18765:741;;;;;;:::o;16706:147::-;16759:7;16824:12;16828:7;16496:2;16492:16;2674:26;16488:28;;16250:282;16824:12;16809;16813:7;15390:3;15386:17;2674:26;15382:29;;15063:364;16809:12;:27;16802:34;;;;16706:147;;;:::o;8649:333::-;8706:8;8730:15;8737:7;14421:3;14417:17;;14210:268;8730:15;:31;;8749:12;8730:31;8726:74;;-1:-1:-1;8784:5:0;;8649:333;-1:-1:-1;8649:333:0:o;8726:74::-;8809:12;8824;8828:7;8824:3;:12::i;:::-;8959:4;8953:11;-1:-1:-1;8940:26:0;;8649:333;-1:-1:-1;;;8649:333:0:o;5035:667::-;5089:13;;5145:2;5130:258;5153:2;5149:1;:6;;;5130:258;;;5173:11;5200:5;:1;5204;5200:5;:::i;:::-;5193:13;;:2;:13;;5173:34;;5230:14;5238:5;5230:7;:14::i;:::-;5221:23;;;;;;5262:1;:7;;5267:2;5262:7;5258:58;;5299:2;5289:12;;;;;5258:58;-1:-1:-1;5357:6:0;;5130:258;;;-1:-1:-1;5451:2:0;5436:260;5459:3;5455:1;:7;;;5436:260;;;5480:11;5507:5;:1;5511;5507:5;:::i;:::-;5500:13;;:2;:13;;5480:34;;5538:14;5546:5;5538:7;:14::i;:::-;5528:24;;;;;;5570:1;:6;;5575:1;5570:6;5566:58;;5607:2;5596:13;;;;;5566:58;-1:-1:-1;5665:6:0;;5436:260;;;;5035:667;;;:::o;4512:199::-;4562:14;4599:18;4615:1;4609:2;:7;;;;4599:9;:18::i;:::-;4588:29;;4641:13;;;;;;4653:1;4641:13;4675;4685:2;4675:9;:13::i;:::-;4664:24;;;;4512:199;-1:-1:-1;4512:199:0:o;2947:1393::-;2999:10;3165:4;3160:9;;;;3211:15;;;;;3207:57;;-1:-1:-1;3249:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3207:57::-;3282:7;:15;;3293:4;3282:15;3278:57;;-1:-1:-1;3320:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3278:57::-;3353:7;:15;;3364:4;3353:15;3349:57;;-1:-1:-1;3391:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3349:57::-;3424:7;:15;;3435:4;3424:15;3420:57;;-1:-1:-1;3462:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3420:57::-;3495:7;:15;;3506:4;3495:15;3491:57;;-1:-1:-1;3533:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3491:57::-;3566:7;:15;;3577:4;3566:15;3562:57;;-1:-1:-1;3604:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3562:57::-;3637:7;:15;;3648:4;3637:15;3633:57;;-1:-1:-1;3675:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3633:57::-;3708:7;:15;;3719:4;3708:15;3704:57;;-1:-1:-1;3746:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3704:57::-;3779:7;:15;;3790:4;3779:15;3775:57;;-1:-1:-1;3817:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3775:57::-;3850:7;:15;;3861:4;3850:15;3846:57;;-1:-1:-1;3888:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3846:57::-;3921:7;:15;;3932:4;3921:15;3917:57;;-1:-1:-1;3959:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3917:57::-;3992:7;:15;;4003:4;3992:15;3988:57;;-1:-1:-1;4030:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;3988:57::-;4063:7;:15;;4074:4;4063:15;4059:57;;-1:-1:-1;4101:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;4059:57::-;4134:7;:15;;4145:4;4134:15;4130:57;;-1:-1:-1;4172:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;4130:57::-;4205:7;:15;;4216:4;4205:15;4201:57;;-1:-1:-1;4243:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;4201:57::-;4276:7;:15;;4287:4;4276:15;4272:57;;-1:-1:-1;4314:4:0;;2947:1393;-1:-1:-1;;2947:1393:0:o;4272:57::-;3011:1329;2947:1393;;;:::o;14:163:1:-;81:20;;141:10;130:22;;120:33;;110:61;;167:1;164;157:12;110:61;14:163;;;:::o;182:184::-;234:77;231:1;224:88;331:4;328:1;321:15;355:4;352:1;345:15;371:777;413:5;466:3;459:4;451:6;447:17;443:27;433:55;;484:1;481;474:12;433:55;520:6;507:20;546:18;583:2;579;576:10;573:36;;;589:18;;:::i;:::-;723:2;717:9;785:4;777:13;;628:66;773:22;;;797:2;769:31;765:40;753:53;;;821:18;;;841:22;;;818:46;815:72;;;867:18;;:::i;:::-;907:10;903:2;896:22;942:2;934:6;927:18;988:3;981:4;976:2;968:6;964:15;960:26;957:35;954:55;;;1005:1;1002;995:12;954:55;1069:2;1062:4;1054:6;1050:17;1043:4;1035:6;1031:17;1018:54;1116:1;1109:4;1104:2;1096:6;1092:15;1088:26;1081:37;1136:6;1127:15;;;;;;371:777;;;;:::o;1153:748::-;1271:6;1279;1287;1295;1303;1311;1319;1372:3;1360:9;1351:7;1347:23;1343:33;1340:53;;;1389:1;1386;1379:12;1340:53;1412:28;1430:9;1412:28;:::i;:::-;1402:38;;1487:2;1476:9;1472:18;1459:32;1449:42;;1510:37;1543:2;1532:9;1528:18;1510:37;:::i;:::-;1500:47;;1566:37;1599:2;1588:9;1584:18;1566:37;:::i;:::-;1556:47;;1650:3;1639:9;1635:19;1622:33;1612:43;;1674:38;1707:3;1696:9;1692:19;1674:38;:::i;:::-;1664:48;;1763:3;1752:9;1748:19;1735:33;1791:18;1783:6;1780:30;1777:50;;;1823:1;1820;1813:12;1777:50;1846:49;1887:7;1878:6;1867:9;1863:22;1846:49;:::i;:::-;1836:59;;;1153:748;;;;;;;;;;:::o;2088:320::-;2156:6;2209:2;2197:9;2188:7;2184:23;2180:32;2177:52;;;2225:1;2222;2215:12;2177:52;2265:9;2252:23;2298:18;2290:6;2287:30;2284:50;;;2330:1;2327;2320:12;2284:50;2353:49;2394:7;2385:6;2374:9;2370:22;2353:49;:::i;2610:258::-;2682:1;2692:113;2706:6;2703:1;2700:13;2692:113;;;2782:11;;;2776:18;2763:11;;;2756:39;2728:2;2721:10;2692:113;;;2823:6;2820:1;2817:13;2814:48;;;2858:1;2849:6;2844:3;2840:16;2833:27;2814:48;;2610:258;;;:::o;2873:316::-;2914:3;2952:5;2946:12;2979:6;2974:3;2967:19;2995:63;3051:6;3044:4;3039:3;3035:14;3028:4;3021:5;3017:16;2995:63;:::i;:::-;3103:2;3091:15;3108:66;3087:88;3078:98;;;;3178:4;3074:109;;2873:316;-1:-1:-1;;2873:316:1:o;3194:217::-;3341:2;3330:9;3323:21;3304:4;3361:44;3401:2;3390:9;3386:18;3378:6;3361:44;:::i;3647:825::-;3936:3;3964:66;4073:2;4064:6;4059:3;4055:16;4051:25;4046:3;4039:38;4106:6;4102:1;4097:3;4093:11;4086:27;4165:2;4156:6;4151:3;4147:16;4143:25;4138:2;4133:3;4129:12;4122:47;4221:2;4212:6;4207:3;4203:16;4199:25;4194:2;4189:3;4185:12;4178:47;4255:6;4250:2;4245:3;4241:12;4234:28;4314:2;4305:6;4300:3;4296:16;4292:25;4287:2;4282:3;4278:12;4271:47;;4347:6;4341:13;4363:62;4418:6;4413:2;4408:3;4404:12;4397:4;4389:6;4385:17;4363:62;:::i;:::-;4445:16;;;;4463:2;4441:25;;3647:825;-1:-1:-1;;;;;;;;3647:825:1:o;4477:184::-;4529:77;4526:1;4519:88;4626:4;4623:1;4616:15;4650:4;4647:1;4640:15;4666:125;4706:4;4734:1;4731;4728:8;4725:34;;;4739:18;;:::i;:::-;-1:-1:-1;4776:9:1;;4666:125::o;4796:128::-;4836:3;4867:1;4863:6;4860:1;4857:13;4854:39;;;4873:18;;:::i;:::-;-1:-1:-1;4909:9:1;;4796:128::o;4929:195::-;4967:4;5004;5001:1;4997:12;5036:4;5033:1;5029:12;5061:3;5056;5053:12;5050:38;;;5068:18;;:::i;:::-;5105:13;;;4929:195;-1:-1:-1;;;4929:195:1:o;5129:238::-;5167:7;5207:4;5204:1;5200:12;5239:4;5236:1;5232:12;5299:3;5293:4;5289:14;5284:3;5281:23;5274:3;5267:11;5260:19;5256:49;5253:75;;;5308:18;;:::i;:::-;5348:13;;5129:238;-1:-1:-1;;;5129:238:1:o;6963:1391::-;7685:34;7673:47;;7750:23;7745:2;7736:12;;7729:45;7793:66;7897:3;7893:16;;;7889:25;;7884:2;7875:12;;7868:47;7934:17;7976:2;7967:12;;7960:24;;;8018:16;;;8014:25;;8009:2;8000:12;;7993:47;8070:34;8065:2;8056:12;;8049:56;8136:3;8130;8121:13;;8114:26;8175:16;;;8171:25;;8165:3;8156:13;;8149:48;8222:3;8213:13;;8206:25;8266:16;;;8262:25;8256:3;8247:13;;8240:48;6921:3;8343;8334:13;;6909:16;-1:-1:-1;6941:11:1;;;8304:44;6844:114","abiDefinition":[{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"body","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"destination","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"uint32","name":"_originDomain","type":"uint32"},{"internalType":"bytes32","name":"_sender","type":"bytes32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"uint32","name":"_destinationDomain","type":"uint32"},{"internalType":"bytes32","name":"_recipient","type":"bytes32"},{"internalType":"uint32","name":"_optimisticSeconds","type":"uint32"},{"internalType":"bytes","name":"_messageBody","type":"bytes"}],"name":"formatMessage","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"leaf","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint32","name":"_origin","type":"uint32"},{"internalType":"bytes32","name":"_sender","type":"bytes32"},{"internalType":"uint32","name":"_nonce","type":"uint32"},{"internalType":"uint32","name":"_destination","type":"uint32"},{"internalType":"bytes32","name":"_recipient","type":"bytes32"},{"internalType":"uint32","name":"_optimisticSeconds","type":"uint32"},{"internalType":"bytes","name":"_body","type":"bytes"}],"name":"messageHash","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"nonce","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"optimisticSeconds","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"origin","outputs":[{"internalType":"uint32","name":"","type":"uint32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"recipient","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"recipientAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"pure","type":"function"},{"inputs":[{"internalType":"bytes","name":"_message","type":"bytes"}],"name":"sender","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"pure","type":"function"}],"userDoc":{"kind":"user","methods":{"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes)":{"notice":"Returns leaf of formatted message with provided fields."}},"version":1},"developerDoc":{"kind":"dev","methods":{"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes)":{"params":{"_body":"Raw bytes of message body","_destination":"Domain of destination chain","_nonce":"Destination-specific nonce number","_origin":"Domain of home chain","_recipient":"Address of recipient on destination chain as bytes32","_sender":"Address of sender as bytes32"},"returns":{"_0":"Leaf (hash) of formatted message*"}}},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"body\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"destination\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_originDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destinationDomain\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_optimisticSeconds\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_messageBody\",\"type\":\"bytes\"}],\"name\":\"formatMessage\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"leaf\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_nonce\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"_destination\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_recipient\",\"type\":\"bytes32\"},{\"internalType\":\"uint32\",\"name\":\"_optimisticSeconds\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"_body\",\"type\":\"bytes\"}],\"name\":\"messageHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"nonce\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"optimisticSeconds\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"origin\",\"outputs\":[{\"internalType\":\"uint32\",\"name\":\"\",\"type\":\"uint32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"recipient\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"recipientAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"sender\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes)\":{\"params\":{\"_body\":\"Raw bytes of message body\",\"_destination\":\"Domain of destination chain\",\"_nonce\":\"Destination-specific nonce number\",\"_origin\":\"Domain of home chain\",\"_recipient\":\"Address of recipient on destination chain as bytes32\",\"_sender\":\"Address of sender as bytes32\"},\"returns\":{\"_0\":\"Leaf (hash) of formatted message*\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes)\":{\"notice\":\"Returns leaf of formatted message with provided fields.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"MessageHarness\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0x409ea03fedc806ba4fb146f037253bb4b771c009e7eeed09af10f67a10d46c62\",\"urls\":[\"bzz-raw://afd27bb01573e8f9dadc6a7c853fc80ba941f70a85aa005b076d256c4771b0bd\",\"dweb:/ipfs/QmaJYLJmRuog3Xb6tCccHrjtcvRcbHkn9H8T4KFp49UjkV\"]}},\"version\":1}"},"hashes":{"body(bytes)":"c97c703a","destination(bytes)":"c81aa9c8","formatMessage(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes)":"9a1b300a","leaf(bytes)":"d7a7a72c","messageHash(uint32,bytes32,uint32,uint32,bytes32,uint32,bytes)":"311f82e3","nonce(bytes)":"4e765004","optimisticSeconds(bytes)":"7c1cfff9","origin(bytes)":"cb3eb0e1","recipient(bytes)":"985a5c31","recipientAddress(bytes)":"f45387ba","sender(bytes)":"6dc3c4f7"}},"solidity/MessageHarness.sol:TypeCasts":{"code":"0x60566037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d448e8387a2513d63cbeeac1ceb7053391478ba4b5a8413e1df0284d792537e464736f6c634300080d0033","runtime-code":"0x73000000000000000000000000000000000000000030146080604052600080fdfea2646970667358221220d448e8387a2513d63cbeeac1ceb7053391478ba4b5a8413e1df0284d792537e464736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\n// \nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Number of bytes in formatted message before `body` field\n    uint256 internal constant PREFIX_LENGTH = 80;\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _originDomain Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce\n     * @param _destinationDomain Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _body\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_origin, _sender, _nonce, _destination, _recipient, _optimisticSeconds, _body));\n    }\n\n    /// @notice Returns message's origin field\n    function origin(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(0, 4));\n    }\n\n    /// @notice Returns message's sender field\n    function sender(bytes29 _message) internal pure returns (bytes32) {\n        return _message.index(4, 32);\n    }\n\n    /// @notice Returns message's nonce field\n    function nonce(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(36, 4));\n    }\n\n    /// @notice Returns message's destination field\n    function destination(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(40, 4));\n    }\n\n    /// @notice Returns message's recipient field as bytes32\n    function recipient(bytes29 _message) internal pure returns (bytes32) {\n        return _message.index(44, 32);\n    }\n\n    /// @notice Returns the optimistic seconds from the message\n    function optimisticSeconds(bytes29 _message) internal pure returns (uint32){\n        return uint32(_message.indexUint(76, 4));\n    }\n\n    /// @notice Returns message's recipient field as an address\n    function recipientAddress(bytes29 _message) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_message));\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure returns (bytes29) {\n        return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\n    }\n\n    function leaf(bytes29 _message) internal view returns (bytes32) {\n        return\n            messageHash(\n                origin(_message),\n                sender(_message),\n                nonce(_message),\n                destination(_message),\n                recipient(_message),\n                optimisticSeconds(_message),\n                TypedMemView.clone(body(_message))\n            );\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            Message.formatMessage(\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        return Message.messageHash(_origin, _sender, _nonce, _destination, _recipient, _optimisticSeconds, _body);\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.ref(0).body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.ref(0).sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.ref(0).recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.ref(0).recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external view returns (bytes32) {\n        return _message.ref(0).leaf();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"32274:1110:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;32274:1110:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"32274:1110:0:-:0;;;;;;;;","abiDefinition":[],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"TypeCasts\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0x409ea03fedc806ba4fb146f037253bb4b771c009e7eeed09af10f67a10d46c62\",\"urls\":[\"bzz-raw://afd27bb01573e8f9dadc6a7c853fc80ba941f70a85aa005b076d256c4771b0bd\",\"dweb:/ipfs/QmaJYLJmRuog3Xb6tCccHrjtcvRcbHkn9H8T4KFp49UjkV\"]}},\"version\":1}"},"hashes":{}},"solidity/MessageHarness.sol:TypedMemView":{"code":"0x60c9610038600b82828239805160001a607314602b57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f26be3fc146038575b600080fd5b605e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000909116815260200160405180910390f3fea26469706673582212204fa828d35af921efe5d4e6f0a9cdd65ffd9f86461db607d57acc306abc0f4b5664736f6c634300080d0033","runtime-code":"0x730000000000000000000000000000000000000000301460806040526004361060335760003560e01c8063f26be3fc146038575b600080fd5b605e7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00000081565b6040517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000909116815260200160405180910390f3fea26469706673582212204fa828d35af921efe5d4e6f0a9cdd65ffd9f86461db607d57acc306abc0f4b5664736f6c634300080d0033","info":{"source":"pragma solidity 0.8.13;\n\n\n// \nlibrary TypedMemView {\n    // Why does this exist?\n    // the solidity `bytes memory` type has a few weaknesses.\n    // 1. You can't index ranges effectively\n    // 2. You can't slice without copying\n    // 3. The underlying data may represent any type\n    // 4. Solidity never deallocates memory, and memory costs grow\n    //    superlinearly\n\n    // By using a memory view instead of a `bytes memory` we get the following\n    // advantages:\n    // 1. Slices are done on the stack, by manipulating the pointer\n    // 2. We can index arbitrary ranges and quickly convert them to stack types\n    // 3. We can insert type info into the pointer, and typecheck at runtime\n\n    // This makes `TypedMemView` a useful tool for efficient zero-copy\n    // algorithms.\n\n    // Why bytes29?\n    // We want to avoid confusion between views, digests, and other common\n    // types so we chose a large and uncommonly used odd number of bytes\n    //\n    // Note that while bytes are left-aligned in a word, integers and addresses\n    // are right-aligned. This means when working in assembly we have to\n    // account for the 3 unused bytes on the righthand side\n    //\n    // First 5 bytes are a type flag.\n    // - ff_ffff_fffe is reserved for unknown type.\n    // - ff_ffff_ffff is reserved for invalid types/errors.\n    // next 12 are memory address\n    // next 12 are len\n    // bottom 3 bytes are empty\n\n    // Assumptions:\n    // - non-modification of memory.\n    // - No Solidity updates\n    // - - wrt free mem point\n    // - - wrt bytes representation in memory\n    // - - wrt memory addressing in general\n\n    // Usage:\n    // - create type constants\n    // - use `assertType` for runtime type assertions\n    // - - unfortunately we can't do this at compile time yet :(\n    // - recommended: implement modifiers that perform type checking\n    // - - e.g.\n    // - - `uint40 constant MY_TYPE = 3;`\n    // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n    // - instantiate a typed view from a bytearray using `ref`\n    // - use `index` to inspect the contents of the view\n    // - use `slice` to create smaller views into the same memory\n    // - - `slice` can increase the offset\n    // - - `slice can decrease the length`\n    // - - must specify the output type of `slice`\n    // - - `slice` will return a null view if you try to overrun\n    // - - make sure to explicitly check for this with `notNull` or `assertType`\n    // - use `equal` for typed comparisons.\n\n    // The null view\n    bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n    uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n    uint8 constant TWELVE_BYTES = 96;\n\n    /**\n     * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n     * @param _b    The byte\n     * @return      char - The encoded hex character\n     */\n    function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n        // This can probably be done more efficiently, but it's only in error\n        // paths, so we don't really care :)\n        uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n        if (_nibble == 0xf0) {\n            return 0x30;\n        } // 0\n        if (_nibble == 0xf1) {\n            return 0x31;\n        } // 1\n        if (_nibble == 0xf2) {\n            return 0x32;\n        } // 2\n        if (_nibble == 0xf3) {\n            return 0x33;\n        } // 3\n        if (_nibble == 0xf4) {\n            return 0x34;\n        } // 4\n        if (_nibble == 0xf5) {\n            return 0x35;\n        } // 5\n        if (_nibble == 0xf6) {\n            return 0x36;\n        } // 6\n        if (_nibble == 0xf7) {\n            return 0x37;\n        } // 7\n        if (_nibble == 0xf8) {\n            return 0x38;\n        } // 8\n        if (_nibble == 0xf9) {\n            return 0x39;\n        } // 9\n        if (_nibble == 0xfa) {\n            return 0x61;\n        } // a\n        if (_nibble == 0xfb) {\n            return 0x62;\n        } // b\n        if (_nibble == 0xfc) {\n            return 0x63;\n        } // c\n        if (_nibble == 0xfd) {\n            return 0x64;\n        } // d\n        if (_nibble == 0xfe) {\n            return 0x65;\n        } // e\n        if (_nibble == 0xff) {\n            return 0x66;\n        } // f\n    }\n\n    /**\n     * @notice      Returns a uint16 containing the hex-encoded byte.\n     * @param _b    The byte\n     * @return      encoded - The hex-encoded byte\n     */\n    function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n        encoded |= nibbleHex(_b \u003e\u003e 4); // top 4 bits\n        encoded \u003c\u003c= 8;\n        encoded |= nibbleHex(_b); // lower 4 bits\n    }\n\n    /**\n     * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n     *              `second` contains the encoded lower 16 bytes.\n     *\n     * @param _b    The 32 bytes as uint256\n     * @return      first - The top 16 bytes\n     * @return      second - The bottom 16 bytes\n     */\n    function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n        for (uint8 i = 31; i \u003e 15; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            first |= byteHex(_byte);\n            if (i != 16) {\n                first \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n\n        // abusing underflow here =_=\n        for (uint8 i = 15; i \u003c 255; ) {\n            uint8 _byte = uint8(_b \u003e\u003e (i * 8));\n            second |= byteHex(_byte);\n            if (i != 0) {\n                second \u003c\u003c= 16;\n            }\n            unchecked {\n                i -= 1;\n            }\n        }\n    }\n\n    /**\n     * @notice          Changes the endianness of a uint256.\n     * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n     * @param _b        The unsigned integer to reverse\n     * @return          v - The reversed value\n     */\n    function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n        v = _b;\n\n        // swap bytes\n        v =\n            ((v \u003e\u003e 8) \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n            ((v \u0026 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) \u003c\u003c 8);\n        // swap 2-byte long pairs\n        v =\n            ((v \u003e\u003e 16) \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n            ((v \u0026 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) \u003c\u003c 16);\n        // swap 4-byte long pairs\n        v =\n            ((v \u003e\u003e 32) \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n            ((v \u0026 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) \u003c\u003c 32);\n        // swap 8-byte long pairs\n        v =\n            ((v \u003e\u003e 64) \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n            ((v \u0026 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) \u003c\u003c 64);\n        // swap 16-byte long pairs\n        v = (v \u003e\u003e 128) | (v \u003c\u003c 128);\n    }\n\n    /**\n     * @notice      Create a mask with the highest `_len` bits set.\n     * @param _len  The length\n     * @return      mask - The mask\n     */\n    function leftMask(uint8 _len) private pure returns (uint256 mask) {\n        // ugly. redo without assembly?\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mask := sar(\n                sub(_len, 1),\n                0x8000000000000000000000000000000000000000000000000000000000000000\n            )\n        }\n    }\n\n    /**\n     * @notice      Return the null view.\n     * @return      bytes29 - The null view\n     */\n    function nullView() internal pure returns (bytes29) {\n        return NULL;\n    }\n\n    /**\n     * @notice      Check if the view is null.\n     * @return      bool - True if the view is null\n     */\n    function isNull(bytes29 memView) internal pure returns (bool) {\n        return memView == NULL;\n    }\n\n    /**\n     * @notice      Check if the view is not null.\n     * @return      bool - True if the view is not null\n     */\n    function notNull(bytes29 memView) internal pure returns (bool) {\n        return !isNull(memView);\n    }\n\n    /**\n     * @notice          Check if the view is of a valid type and points to a valid location\n     *                  in memory.\n     * @dev             We perform this check by examining solidity's unallocated memory\n     *                  pointer and ensuring that the view's upper bound is less than that.\n     * @param memView   The view\n     * @return          ret - True if the view is valid\n     */\n    function isValid(bytes29 memView) internal pure returns (bool ret) {\n        if (typeOf(memView) == 0xffffffffff) {\n            return false;\n        }\n        uint256 _end = end(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ret := not(gt(_end, mload(0x40)))\n        }\n    }\n\n    /**\n     * @notice          Require that a typed memory view be valid.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @return          bytes29 - The validated view\n     */\n    function assertValid(bytes29 memView) internal pure returns (bytes29) {\n        require(isValid(memView), \"Validity assertion failed\");\n        return memView;\n    }\n\n    /**\n     * @notice          Return true if the memview is of the expected type. Otherwise false.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bool - True if the memview is of the expected type\n     */\n    function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n        return typeOf(memView) == _expected;\n    }\n\n    /**\n     * @notice          Require that a typed memory view has a specific type.\n     * @dev             Returns the view for easy chaining.\n     * @param memView   The view\n     * @param _expected The expected type\n     * @return          bytes29 - The view with validated type\n     */\n    function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n        if (!isType(memView, _expected)) {\n            (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n            (, uint256 e) = encodeHex(uint256(_expected));\n            string memory err = string(\n                abi.encodePacked(\n                    \"Type assertion failed. Got 0x\",\n                    uint80(g),\n                    \". Expected 0x\",\n                    uint80(e)\n                )\n            );\n            revert(err);\n        }\n        return memView;\n    }\n\n    /**\n     * @notice          Return an identical view with a different type.\n     * @param memView   The view\n     * @param _newType  The new type\n     * @return          newView - The new view with the specified type\n     */\n    function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n        // then | in the new type\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // shift off the top 5 bytes\n            newView := or(newView, shr(40, shl(40, memView)))\n            newView := or(newView, shl(216, _newType))\n        }\n    }\n\n    /**\n     * @notice          Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Unsafe raw pointer construction. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function unsafeBuildUnchecked(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) private pure returns (bytes29 newView) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            newView := shl(96, or(newView, _type)) // insert type\n            newView := shl(96, or(newView, _loc)) // insert loc\n            newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n        }\n    }\n\n    /**\n     * @notice          Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @dev             Instantiate a new memory view. This should generally not be called\n     *                  directly. Prefer `ref` wherever possible.\n     * @param _type     The type\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @return          newView - The new view with the specified type, location and length\n     */\n    function build(\n        uint256 _type,\n        uint256 _loc,\n        uint256 _len\n    ) internal pure returns (bytes29 newView) {\n        uint256 _end = _loc + _len;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            if gt(_end, mload(0x40)) {\n                _end := 0\n            }\n        }\n        if (_end == 0) {\n            return NULL;\n        }\n        newView = unsafeBuildUnchecked(_type, _loc, _len);\n    }\n\n    /**\n     * @notice          Instantiate a memory view from a byte array.\n     * @dev             Note that due to Solidity memory representation, it is not possible to\n     *                  implement a deref, as the `bytes` type stores its len in memory.\n     * @param arr       The byte array\n     * @param newType   The type\n     * @return          bytes29 - The memory view\n     */\n    function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n        uint256 _len = arr.length;\n\n        uint256 _loc;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _loc := add(arr, 0x20) // our view is of the data, not the struct\n        }\n\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Return the associated type information.\n     * @param memView   The memory view\n     * @return          _type - The type associated with the view\n     */\n    function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 216 == 256 - 40\n            _type := shr(216, memView) // shift out lower 24 bytes\n        }\n    }\n\n    /**\n     * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the 5-byte type flag is equal\n     */\n    function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return (left ^ right) \u003e\u003e (2 * TWELVE_BYTES) == 0;\n    }\n\n    /**\n     * @notice          Return the memory address of the underlying bytes.\n     * @param memView   The view\n     * @return          _loc - The memory address\n     */\n    function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n            _loc := and(shr(120, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          The number of memory words this memory view occupies, rounded up.\n     * @param memView   The view\n     * @return          uint256 - The number of memory words\n     */\n    function words(bytes29 memView) internal pure returns (uint256) {\n        return (uint256(len(memView)) + 32) / 32;\n    }\n\n    /**\n     * @notice          The in-memory footprint of a fresh copy of the view.\n     * @param memView   The view\n     * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n     */\n    function footprint(bytes29 memView) internal pure returns (uint256) {\n        return words(memView) * 32;\n    }\n\n    /**\n     * @notice          The number of bytes of the view.\n     * @param memView   The view\n     * @return          _len - The length of the view\n     */\n    function len(bytes29 memView) internal pure returns (uint96 _len) {\n        uint256 _mask = LOW_12_MASK; // assembly can't use globals\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            _len := and(shr(24, memView), _mask)\n        }\n    }\n\n    /**\n     * @notice          Returns the endpoint of `memView`.\n     * @param memView   The view\n     * @return          uint256 - The endpoint of `memView`\n     */\n    function end(bytes29 memView) internal pure returns (uint256) {\n        unchecked {\n            return loc(memView) + len(memView);\n        }\n    }\n\n    /**\n     * @notice          Safe slicing without memory modification.\n     * @param memView   The view\n     * @param _index    The start index\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function slice(\n        bytes29 memView,\n        uint256 _index,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        uint256 _loc = loc(memView);\n\n        // Ensure it doesn't overrun the view\n        if (_loc + _index + _len \u003e end(memView)) {\n            return NULL;\n        }\n\n        _loc = _loc + _index;\n        return build(newType, _loc, _len);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function prefix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, 0, _len, newType);\n    }\n\n    /**\n     * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n     * @param memView   The view\n     * @param _len      The length\n     * @param newType   The new type\n     * @return          bytes29 - The new view\n     */\n    function postfix(\n        bytes29 memView,\n        uint256 _len,\n        uint40 newType\n    ) internal pure returns (bytes29) {\n        return slice(memView, uint256(len(memView)) - _len, _len, newType);\n    }\n\n    /**\n     * @notice          Construct an error message for an indexing overrun.\n     * @param _loc      The memory address\n     * @param _len      The length\n     * @param _index    The index\n     * @param _slice    The slice where the overrun occurred\n     * @return          err - The err\n     */\n    function indexErrOverrun(\n        uint256 _loc,\n        uint256 _len,\n        uint256 _index,\n        uint256 _slice\n    ) internal pure returns (string memory err) {\n        (, uint256 a) = encodeHex(_loc);\n        (, uint256 b) = encodeHex(_len);\n        (, uint256 c) = encodeHex(_index);\n        (, uint256 d) = encodeHex(_slice);\n        err = string(\n            abi.encodePacked(\n                \"TypedMemView/index - Overran the view. Slice is at 0x\",\n                uint48(a),\n                \" with length 0x\",\n                uint48(b),\n                \". Attempted to index at offset 0x\",\n                uint48(c),\n                \" with length 0x\",\n                uint48(d),\n                \".\"\n            )\n        );\n    }\n\n    /**\n     * @notice          Load up to 32 bytes from the view onto the stack.\n     * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n     *                  This can be immediately cast to a smaller fixed-length byte array.\n     *                  To automatically cast to an integer, use `indexUint`.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The 32 byte result\n     */\n    function index(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (bytes32 result) {\n        if (_bytes == 0) {\n            return bytes32(0);\n        }\n        if (_index + _bytes \u003e len(memView)) {\n            revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n        }\n        require(_bytes \u003c= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n        uint8 bitLength;\n        unchecked {\n            bitLength = _bytes * 8;\n        }\n        uint256 _loc = loc(memView);\n        uint256 _mask = leftMask(bitLength);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            result := and(mload(add(_loc, _index)), _mask)\n        }\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from the view at `_index`.\n     * @dev             Requires that the view have \u003e= `_bytes` bytes following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return uint256(index(memView, _index, _bytes)) \u003e\u003e ((32 - _bytes) * 8);\n    }\n\n    /**\n     * @notice          Parse an unsigned integer from LE bytes.\n     * @param memView   The view\n     * @param _index    The index\n     * @param _bytes    The bytes\n     * @return          result - The unsigned integer\n     */\n    function indexLEUint(\n        bytes29 memView,\n        uint256 _index,\n        uint8 _bytes\n    ) internal pure returns (uint256 result) {\n        return reverseUint256(uint256(index(memView, _index, _bytes)));\n    }\n\n    /**\n     * @notice          Parse an address from the view at `_index`. Requires that the view have \u003e= 20 bytes\n     *                  following that index.\n     * @param memView   The view\n     * @param _index    The index\n     * @return          address - The address\n     */\n    function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n        return address(uint160(indexUint(memView, _index, 20)));\n    }\n\n    /**\n     * @notice          Return the keccak256 hash of the underlying memory\n     * @param memView   The view\n     * @return          digest - The keccak256 hash of the underlying memory\n     */\n    function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            digest := keccak256(_loc, _len)\n        }\n    }\n\n    /**\n     * @notice          Return the sha2 digest of the underlying memory.\n     * @dev             We explicitly deallocate memory afterwards.\n     * @param memView   The view\n     * @return          digest - The sha2 hash of the underlying memory\n     */\n    function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n     * @param memView   The pre-image\n     * @return          digest - the Digest\n     */\n    function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n            pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n            digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n        }\n    }\n\n    /**\n     * @notice          Implements bitcoin's hash256 (double sha2)\n     * @param memView   A view of the preimage\n     * @return          digest - the Digest\n     */\n    function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n        uint256 _loc = loc(memView);\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n            pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n            digest := mload(ptr)\n        }\n    }\n\n    /**\n     * @notice          Return true if the underlying memory is equal. Else false.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the underlying memory is equal\n     */\n    function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return\n            (loc(left) == loc(right) \u0026\u0026 len(left) == len(right)) || keccak(left) == keccak(right);\n    }\n\n    /**\n     * @notice          Return false if the underlying memory is equal. Else true.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - False if the underlying memory is equal\n     */\n    function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !untypedEqual(left, right);\n    }\n\n    /**\n     * @notice          Compares type equality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are the same\n     */\n    function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return left == right || (typeOf(left) == typeOf(right) \u0026\u0026 keccak(left) == keccak(right));\n    }\n\n    /**\n     * @notice          Compares type inequality.\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param left      The first view\n     * @param right     The second view\n     * @return          bool - True if the types are not the same\n     */\n    function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n        return !equal(left, right);\n    }\n\n    /**\n     * @notice          Copy the view to a location, return an unsafe memory reference\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memView   The view\n     * @param _newLoc   The new location\n     * @return          written - the unsafe memory reference\n     */\n    function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n        require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n        require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n        uint256 _len = len(memView);\n        uint256 _oldLoc = loc(memView);\n\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _newLoc) {\n                revert(0x60, 0x20) // empty revert message\n            }\n\n            // use the identity precompile to copy\n            // guaranteed not to fail, so pop the success\n            pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n        }\n\n        written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n    }\n\n    /**\n     * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n     *                  the new memory\n     * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n     * @param memView   The view\n     * @return          ret - The view pointing to the new memory\n     */\n    function clone(bytes29 memView) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        uint256 _len = len(memView);\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n            ret := ptr\n        }\n        unchecked {\n            unsafeCopyTo(memView, ptr + 0x20);\n        }\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n            mstore(ptr, _len) // write len of new array (in bytes)\n        }\n    }\n\n    /**\n     * @notice          Join the views in memory, return an unsafe reference to the memory.\n     * @dev             Super Dangerous direct memory access.\n     *\n     *                  This reference can be overwritten if anything else modifies memory (!!!).\n     *                  As such it MUST be consumed IMMEDIATELY.\n     *                  This function is private to prevent unsafe usage by callers.\n     * @param memViews  The views\n     * @return          unsafeView - The conjoined view pointing to the new memory\n     */\n    function unsafeJoin(bytes29[] memory memViews, uint256 _location)\n        private\n        view\n        returns (bytes29 unsafeView)\n    {\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            let ptr := mload(0x40)\n            // revert if we're writing in occupied memory\n            if gt(ptr, _location) {\n                revert(0x60, 0x20) // empty revert message\n            }\n        }\n\n        uint256 _offset = 0;\n        for (uint256 i = 0; i \u003c memViews.length; i++) {\n            bytes29 memView = memViews[i];\n            unchecked {\n                unsafeCopyTo(memView, _location + _offset);\n                _offset += len(memView);\n            }\n        }\n        unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n    }\n\n    /**\n     * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The keccak256 digest\n     */\n    function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return keccak(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n     * @param memViews  The views\n     * @return          bytes32 - The sha256 digest\n     */\n    function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n        return sha2(unsafeJoin(memViews, ptr));\n    }\n\n    /**\n     * @notice          copies all views, joins them into a new bytearray.\n     * @param memViews  The views\n     * @return          ret - The new byte array\n     */\n    function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n        uint256 ptr;\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            ptr := mload(0x40) // load unused memory pointer\n        }\n\n        bytes29 _newView;\n        unchecked {\n            _newView = unsafeJoin(memViews, ptr + 0x20);\n        }\n        uint256 _written = len(_newView);\n        uint256 _footprint = footprint(_newView);\n\n        assembly {\n            // solhint-disable-previous-line no-inline-assembly\n            // store the legnth\n            mstore(ptr, _written)\n            // new pointer is old + 0x20 + the footprint of the body\n            mstore(0x40, add(add(ptr, _footprint), 0x20))\n            ret := ptr\n        }\n    }\n}\n\nlibrary TypeCasts {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n        _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n    }\n\n    // treat it as a null-terminated string of max 32 bytes\n    function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n        uint8 _slen = 0;\n        while (_slen \u003c 32 \u0026\u0026 _buf[_slen] != 0) {\n            _slen++;\n        }\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            _newStr := mload(0x40)\n            mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n            mstore(_newStr, _slen)\n            mstore(add(_newStr, 0x20), _buf)\n        }\n    }\n\n    // alignment preserving cast\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\n        return bytes32(uint256(uint160(_addr)));\n    }\n\n    // alignment preserving cast\n    function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n        return address(uint160(uint256(_buf)));\n    }\n}\n\nlibrary Message {\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    // Number of bytes in formatted message before `body` field\n    uint256 internal constant PREFIX_LENGTH = 80;\n\n    /**\n     * @notice Returns formatted (packed) message with provided fields\n     * @param _originDomain Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce\n     * @param _destinationDomain Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _messageBody Raw bytes of message body\n     * @return Formatted message\n     **/\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _messageBody\n    ) internal pure returns (bytes memory) {\n        return\n            abi.encodePacked(\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _body\n    ) internal pure returns (bytes32) {\n        return keccak256(formatMessage(_origin, _sender, _nonce, _destination, _recipient, _optimisticSeconds, _body));\n    }\n\n    /// @notice Returns message's origin field\n    function origin(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(0, 4));\n    }\n\n    /// @notice Returns message's sender field\n    function sender(bytes29 _message) internal pure returns (bytes32) {\n        return _message.index(4, 32);\n    }\n\n    /// @notice Returns message's nonce field\n    function nonce(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(36, 4));\n    }\n\n    /// @notice Returns message's destination field\n    function destination(bytes29 _message) internal pure returns (uint32) {\n        return uint32(_message.indexUint(40, 4));\n    }\n\n    /// @notice Returns message's recipient field as bytes32\n    function recipient(bytes29 _message) internal pure returns (bytes32) {\n        return _message.index(44, 32);\n    }\n\n    /// @notice Returns the optimistic seconds from the message\n    function optimisticSeconds(bytes29 _message) internal pure returns (uint32){\n        return uint32(_message.indexUint(76, 4));\n    }\n\n    /// @notice Returns message's recipient field as an address\n    function recipientAddress(bytes29 _message) internal pure returns (address) {\n        return TypeCasts.bytes32ToAddress(recipient(_message));\n    }\n\n    /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n    function body(bytes29 _message) internal pure returns (bytes29) {\n        return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\n    }\n\n    function leaf(bytes29 _message) internal view returns (bytes32) {\n        return\n            messageHash(\n                origin(_message),\n                sender(_message),\n                nonce(_message),\n                destination(_message),\n                recipient(_message),\n                optimisticSeconds(_message),\n                TypedMemView.clone(body(_message))\n            );\n    }\n}\n\n// \ncontract MessageHarness {\n    using Message for bytes29;\n    using TypedMemView for bytes;\n    using TypedMemView for bytes29;\n\n    function formatMessage(\n        uint32 _originDomain,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destinationDomain,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _messageBody\n    ) public pure returns (bytes memory) {\n        return\n            Message.formatMessage(\n                _originDomain,\n                _sender,\n                _nonce,\n                _destinationDomain,\n                _recipient,\n                _optimisticSeconds,\n                _messageBody\n            );\n    }\n\n    /**\n     * @notice Returns leaf of formatted message with provided fields.\n     * @param _origin Domain of home chain\n     * @param _sender Address of sender as bytes32\n     * @param _nonce Destination-specific nonce number\n     * @param _destination Domain of destination chain\n     * @param _recipient Address of recipient on destination chain as bytes32\n     * @param _body Raw bytes of message body\n     * @return Leaf (hash) of formatted message\n     **/\n    function messageHash(\n        uint32 _origin,\n        bytes32 _sender,\n        uint32 _nonce,\n        uint32 _destination,\n        bytes32 _recipient,\n        uint32 _optimisticSeconds,\n        bytes memory _body\n    ) public pure returns (bytes32) {\n        return Message.messageHash(_origin, _sender, _nonce, _destination, _recipient, _optimisticSeconds, _body);\n    }\n\n    function body(bytes memory _message) external view returns (bytes memory) {\n        return _message.ref(0).body().clone();\n    }\n\n    function origin(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).origin();\n    }\n\n    function sender(bytes memory _message) external pure returns (bytes32) {\n        return _message.ref(0).sender();\n    }\n\n    function nonce(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).nonce();\n    }\n\n    function destination(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).destination();\n    }\n\n    function recipient(bytes memory _message) external pure returns (bytes32) {\n        return _message.ref(0).recipient();\n    }\n\n    function recipientAddress(bytes memory _message) external pure returns (address) {\n        return _message.ref(0).recipientAddress();\n    }\n\n    function optimisticSeconds(bytes memory _message) external pure returns (uint32) {\n        return _message.ref(0).optimisticSeconds();\n    }\n\n    function leaf(bytes memory _message) external view returns (bytes32) {\n        return _message.ref(0).leaf();\n    }\n}","language":"Solidity","languageVersion":"0.8.13","compilerVersion":"0.8.13","compilerOptions":"--combined-json bin,bin-runtime,srcmap,srcmap-runtime,abi,userdoc,devdoc,metadata,hashes --optimize --optimize-runs 10000 --allow-paths ., ./, ../","srcMap":"30:32242:0:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;30:32242:0;;;;;;;;;;;;;;;;;","srcMapRuntime":"30:32242:0:-:0;;;;;;;;;;;;;;;;;;;;;;;;2543:94;;;;;;;;198:66:1;186:79;;;168:98;;156:2;141:18;2543:94:0;;;;;;","abiDefinition":[{"inputs":[],"name":"NULL","outputs":[{"internalType":"bytes29","name":"","type":"bytes29"}],"stateMutability":"view","type":"function"}],"userDoc":{"kind":"user","methods":{},"version":1},"developerDoc":{"kind":"dev","methods":{},"version":1},"metadata":"{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"name\":\"NULL\",\"outputs\":[{\"internalType\":\"bytes29\",\"name\":\"\",\"type\":\"bytes29\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/MessageHarness.sol\":\"TypedMemView\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"solidity/MessageHarness.sol\":{\"keccak256\":\"0x409ea03fedc806ba4fb146f037253bb4b771c009e7eeed09af10f67a10d46c62\",\"urls\":[\"bzz-raw://afd27bb01573e8f9dadc6a7c853fc80ba941f70a85aa005b076d256c4771b0bd\",\"dweb:/ipfs/QmaJYLJmRuog3Xb6tCccHrjtcvRcbHkn9H8T4KFp49UjkV\"]}},\"version\":1}"},"hashes":{"NULL()":"f26be3fc"}}}